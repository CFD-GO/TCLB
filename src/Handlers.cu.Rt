<?R
        source("conf.R")
	c_header();
?>

#include "pugixml.hpp"
#include "Global.h"
#include <mpi.h>
#ifdef GRAPHICS
	#include "gpu_anim.h"
#endif
#include "cross.h"
#include "Region.h"
#include "Node.h"
#include "LatticeContainer.h"
#include "Lattice.h"
#include "vtkLattice.h"
#include "Geometry.h"
#include "def.h"
#include "utils.h"
#include "unit.h"

#include <fstream>
#include <iostream>
#include <vector>
#include <iomanip>
#include <assert.h>

#include "Solver.h"




int vHandler::DoIt(Solver* solver) {
	printf("It is wrong (do it)!\n");
	exit(-1);
	return -1;
};

int vHandler::Init(Solver* solver) {
	printf("It is wrong (init)!\n");
	exit(-1);
	return -1;
};

int vHandler::Finish(Solver* solver) {
	printf("It is wrong (finish)!\n");
	exit(-1);
	return -1;
};

int vHandler::Type() {
	return 0;
};

class Callback : public vHandler {
public:
	int DoIt(Solver* solver) {
	}
	int Init(Solver* solver) {
		if (node.attribute("Iterations")) {
			int it = solver->Iterations(node);
			startIter = solver->iter;
			everyIter = it;
			std::cout << "Setting callback " << node.name() << " at " << it << " iterations\n";
		} else {
			std::cerr << "No Iterations attribute in " << node.name() << "\n";
			return -1;
		}
		return 0;
	}
	int Finish(Solver* solver) {
		return 0;
	}
	int Type() { return HANDLER_CALLBACK; }
};

class Action : public vHandler {
public:
	int DoIt(Solver* solver) {
	}
	int Init(Solver* solver) {
		if (node.attribute("Iterations")) {
			int it = solver->Iterations(node);
			startIter = solver->iter;
			everyIter = it;
			std::cout << "Setting action " << node.name() << " at " << it << " iterations\n";
		} else {
			startIter = solver->iter;
			everyIter = 0;
		}
		if (node.attribute("output")) {
			solver->setOutput(node.attribute("output").value());
		}
		return 0;
	}
	int Finish(Solver* solver) {
		return 0;
	}
	int Type() { return HANDLER_ACTION; }
};

class cbVTK: public Callback {
	std::string nm;
	public:
	int Init(Solver* solver) {
		Callback::Init(solver);
		pugi::xml_attribute attr = node.attribute("name");
		nm = "VTK";
		if (attr) nm = attr.value();
		return 0;
	}
	public:
	int DoIt(Solver* solver) {
		Callback::DoIt(solver);
		return solver->writeVTK(nm.c_str());
	};
};

class cbLog: public Callback {
	std::string filename;
	public:
	int Init(Solver* solver) {
		char fn[STRING_LEN];
		Callback::Init(solver);
		pugi::xml_attribute attr = node.attribute("name");
		std::string nm = "Log";
		if (attr) nm = attr.value();
		solver->outIterFile(nm.c_str(), ".csv", fn);
		filename = fn;
		solver->initLog(filename.c_str());
		return 0;
	}
	int DoIt(Solver* solver) {
		Callback::DoIt(solver);
		solver->LogIter = solver->iter;
		solver->writeLog(filename.c_str());
		return 0;
	}
};

class GenericAction: public Action {
	int stack;
	public:
	int Init(Solver* solver) {
		stack=0;
                for (pugi::xml_node par = node.first_child(); par; par = par.next_sibling()) {
			Handler hand(par, solver);
			if (hand) {
				if (hand.Type() & HANDLER_CALLBACK) {
					printf("adding %d\n", hand.hand->everyIter);
					solver->hands.push_back(hand);
					stack++;
				}
			} else return -1;
                }
		return 0;
	}
	int Finish(Solver* solver) {
		while(stack--) {
			solver->hands.pop_back();
		}
		
		return 0;
	}
};

class GenericContainer: public GenericAction {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		return GenericAction::Init(solver);
	}
};


class acSolve: public GenericAction {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		GenericAction::Init(solver);
		while (solver->iter < startIter+everyIter) {
			int next_it=startIter + everyIter - solver->iter;
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
			solver->lattice->Iterate(solver->steps, ITER_NORM);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					solver->hands[i].DoIt();
				}
			}
		}
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		return 0;
	}
};

class acParams: public Action {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		pugi::xml_attribute attr;
		<?R for (i in 1:nrow(Settings)) { v = Settings[i,]; ?>
			attr = node.attribute("<?%s v$name?>");
			if (attr) {
				double val = solver->units.alt(attr.value());
				solver->lattice-><?%s v$FunName ?>(val);
			}
		<?R } ?>
	}
};


class acModel: public GenericContainer {
	public:
	int Init(Solver* solver) {
		GenericContainer::Init(solver);
		solver->iter = 0;
		solver->lattice->Init();
		return 0;
	}
};


class acInit: public Action {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		solver->lattice->Init();
		return 0;
	}
};

class acGeometry: public Action {
	public:
	int Init(Solver* solver) {
			Geometry geometry(solver->region, solver->units);
			if (geometry.load(node)) {
				std::cerr << "Error while loading geometry\n";
				return -1;
			}
			char filename[STRING_LEN];
			solver->outIterFile("G", ".vti", filename);
			geometry.writeVTI(filename);
			solver->lattice->FlagOverwrite(geometry.geom,geometry.region);
			return 0;
	}
};

vHandler * getHandler(pugi::xml_node node) {
	vHandler * ret;
	std::string name(node.name());
	DEBUG1(std::cout << name << "\n";)
	if (name=="VTK") {
		ret = new cbVTK;
        } else if (name=="Log") {
		ret = new cbLog;
        } else if (name=="Solve") {
		ret = new acSolve;
        } else if (name=="Params") {
		ret = new acParams;
        } else if (name=="Units") {
		ret = new acParams;
        } else if (name=="Geometry") {
		ret = new acGeometry;
        } else if (name=="CLBConfig") {
		ret = new GenericContainer;
        } else if (name=="Model") {
		ret = new acModel;
        } else if (name=="Init") {
		ret = new acInit;
        } else {
		std::cerr << "Unknown element '" << node.name() << "' in xml\n";
		return NULL;
	}
	ret->node = node;
	return ret;
}
