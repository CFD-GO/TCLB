<?R
        source("conf.R")
	c_header();
?>

#include "pugixml.hpp"
#include "Global.h"
#include <mpi.h>
#ifdef GRAPHICS
	#include "gpu_anim.h"
#endif
#include "cross.h"
#include "Region.h"
#include "Node.h"
#include "LatticeContainer.h"
#include "Lattice.h"
#include "vtkLattice.h"
#include "Geometry.h"
#include "def.h"
#include "utils.h"
#include "unit.h"

#include <fstream>
#include <iostream>
#include <vector>
#include <iomanip>
#include <assert.h>

#include "Solver.h"




int vHandler::DoIt(Solver* solver) {
	printf("It is wrong (do it)!\n");
	exit(-1);
	return -1;
};

int vHandler::Init(Solver* solver) {
	printf("It is wrong (init)!\n");
	exit(-1);
	return -1;
};

int vHandler::Type() {
	return 0;
};

class Callback : public vHandler {
public:
	int DoIt(Solver* solver) {
	}
	int Init(Solver* solver) {
	}
	int Type() { return HANDLER_CALLBACK; }
};

class Action : public vHandler {
public:
	int DoIt(Solver* solver) {
	}
	int Init(Solver* solver) {
	}
	int Type() { return HANDLER_ACTION; }
};

class cbVTK: public Callback {
	public:
	int DoIt(Solver* solver) {
		Callback::DoIt(solver);
		printf("[%d]                                                     writing vtk [...", D_MPI_RANK);
		char filename[STRING_LEN];
		solver->outIterFile("VTK", ".vti", filename);
		vtkWriteLattice(filename, solver->lattice, solver->units);
		printf("]\n");
		return 0;
	};
};

class cbLog: public Callback {
	public:
	int DoIt(Solver* solver) {
		Callback::DoIt(solver);
		solver->LogIter = solver->iter;
		solver->writeLog(node.attribute("filename").value());
		return 0;
	}
};

class GenericAction: public Action {
	public:
	int Init(Solver* solver) {
                for (pugi::xml_node par = node.first_child(); par; par = par.next_sibling()) {
			Handler hand(par);
			if (hand) {
				int ret = hand.Init(solver);
				if (ret) return ret;
				if (hand.Type() & HANDLER_CALLBACK) solver->hands.push_back(hand);
			} else return -1;
                }
		return 0;
	}
};

class GenericContainer: public GenericAction {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		return GenericAction::Init(solver);
	}
};


class acSolve: public GenericAction {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		printf("Solve\n");
		GenericAction::Init(solver);
		return 0;
	}
};

class acParams: public Action {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		pugi::xml_attribute attr;
		<?R for (i in 1:nrow(Settings)) { v = Settings[i,]; ?>
			attr = node.attribute("<?%s v$name?>");
			if (attr) {
				double val = solver->units.alt(attr.value());
				solver->lattice-><?%s v$FunName ?>(val);
			}
		<?R } ?>
	}
};


class acModel: public GenericContainer {
	public:
	int Init(Solver* solver) {
		GenericContainer::Init(solver);
		solver->iter = 0;
		solver->lattice->Init();
		return 0;
	}
};


class acInit: public Action {
	public:
	int Init(Solver* solver) {
		Action::Init(solver);
		solver->lattice->Init();
		return 0;
	}
};

class acGeometry: public Action {
	public:
	int Init(Solver* solver) {
			Geometry geometry(solver->region, solver->units);
			if (geometry.load(node)) {
				std::cerr << "Error while loading geometry\n";
				return -1;
			}
			char filename[STRING_LEN];
			solver->outIterFile("G", ".vti", filename);
			geometry.writeVTI(filename);
			solver->lattice->FlagOverwrite(geometry.geom,geometry.region);
			return 0;
	}
};

vHandler * getHandler(pugi::xml_node node) {
	vHandler * ret;
	std::string name(node.name());
	DEBUG1(std::cout << name << "\n";)
	if (name=="VTK") {
		ret = new cbVTK;
        } else if (name=="Log") {
		ret = new cbLog;
        } else if (name=="Solve") {
		ret = new acSolve;
        } else if (name=="Params") {
		ret = new acParams;
        } else if (name=="Units") {
		ret = new acParams;
        } else if (name=="Geometry") {
		ret = new acGeometry;
        } else if (name=="CLBConfig") {
		ret = new GenericContainer;
        } else if (name=="Model") {
		ret = new acModel;
        } else if (name=="Init") {
		ret = new acInit;
        } else {
		std::cerr << "Unknown element '" << node.name() << "' in xml\n";
		return NULL;
	}
	ret->node = node;
	return ret;
}
