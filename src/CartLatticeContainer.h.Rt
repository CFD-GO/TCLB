<?R
	source("conf.R");
	c_header()
?>
/** \file CartLatticeContainer.h
  File defining CartLatticeContainer and some additional CUDA functions
*/

#ifndef LATTICECONTAINER_H
#define LATTICECONTAINER_H

#include "Consts.h"

/// Container class used for storing all the data needed on GPU
/**
  Main class for storing the data needed on GPU and running kernels.
  CartLatticeContainer is the container class which
  owns all the data needed by the kernels on device
  like pointers to the global gpu memory etc.
  It defines push/pop functions allowing access
  to node data stored in memory.
*/
class CartLatticeContainer {
	public:
  FTabs in; ///< Main FTabs used for Primal iteration as input
  FTabs out; ///< Main FTabs used for Primal iteration as output
#ifdef ADJOINT
  FTabs adjout; ///< FTabs used for Adjoint iteration as output
  FTabs adjin; ///< FTabs used for Adjoint iteration as input
#endif
  flag_t * NodeType; ///< Table of flags/NodeTypes of all the nodes
  cut_t* Q; 
  int nx, ny, nz; ///< Size of the Lattice region
  real_t px,py,pz;

  void Alloc (int,int,int);
  void Free();
  void ActivateCuts();
  CudaDeviceFunction void fill();
  
  CudaDeviceFunction flag_t getType(int x, int y, int z) const { return NodeType[(x + nx*(y + ny*z))]; }

  void Color( uchar4 *optr );
  template<class N> inline void RunBorderT(CudaStream_t);
  template<class N> inline void RunInteriorT(CudaStream_t);
  template < eOperationType I, eCalculateGlobals G, eStage S > void RunBorder(CudaStream_t);
  template < eOperationType I, eCalculateGlobals G, eStage S > void RunInterior(CudaStream_t);

  void CopyToConst();
};

template<class T> CudaGlobalFunction void Kernel();
template < eOperationType I, eCalculateGlobals G, eStage S > class InteriorExecutor;
template < eOperationType I, eCalculateGlobals G, eStage S > class BorderExecutor;

<?R
for (q in rows(Quantities)) { ifdef(q$adjoint);
        if (q$adjoint) {
          node = "Node_Adj"
        } else {
          node = "Node"
        }
?>
CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale); <?R
	for (tp in c("float","double"))
        { ?>
CudaGlobalFunction void get<?%s q$name ?>_<?%s tp ?>(lbRegion , <?%s tp ?> *, int);
<?R
	}
}
ifdef() ?>

void * BAlloc(size_t size);
void BPreAlloc(void **, size_t size);

static_assert(std::is_trivially_copyable<CartLatticeContainer>::value, "CartLatticeContainer must be trivially copyable");

#endif // LATTICECONTAINER_H
