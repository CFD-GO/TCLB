<?R
	source("conf.R")
	c_header();


# Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	rho =  PV("rho")
	J = PV("J",c("x","y","z"))
	tmp = PV("tmp")

# Extracting velocity set
	U = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy","dz")])

# Calculating equlibrium density set
	source("MRT/feq.R")
	EQ = MRT_eq(U, rho, J );
?>

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>;
}

CudaDeviceFunction real_t getP(){
	return ((<?R C(sum(f)) ?>)-1.0)/3.0;
}

CudaDeviceFunction vector_t getU(){
	real_t d = getRho();
	vector_t u;
<?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>
	u.x /= d;
	u.y /= d;
	u.z /= d;
	return u;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}

CudaDeviceFunction void BounceBack()
{
     real_t uf;
<?R
	uf = PV("uf")
	by(Density, Density$group, function(d) {
		i = order(d$dx,d$dy,d$dz)
		j = order(-d$dx,-d$dy,-d$dz)
		if (any(d[i,c("dx","dy","dz")]!=-d[j,c("dx","dy","dz")])) stop("Density directions are not fully symetric!");
		V = cbind(i,j);
		sel = V[,1] > V[,2]
		V = V[sel,, drop=F]
		if (nrow(V) > 0) {
		f = PV(d$name)
		apply(V,1,function(x) {
			C(uf,f[x[1]])
			C(f[x[1]],f[x[2]])
			C(f[x[2]],uf)
		})
		}
	NULL})
?>}

<?R

W1 = cbind(U,i=1:nrow(U))
W2 = cbind(-U,j=1:nrow(U))
ret = merge(W1,W2)
bounce = 1:nrow(U)
bounce[ret$i] = ret$j

C_pull = function(W, var) {
	ret = div.mod(W[[1]],var)
	cat(var, " = (", ToC(ret[[1]]), ") / (", ToC(ret[[2]]*(-1)), ");\n")
}

ZouHe = function(direction, sign, type) {
	sel = sign*U[,direction]>0
	fs = f
	Js = c("Jx","Jy","Jz")
	feq = EQ$Req %*% solve(EQ$mat)
	fs[sel] = (feq + (fs-feq)[bounce])[sel]
	Rs = fs %*% EQ$mat[,EQ$order<2] - EQ$Req[EQ$order<2]
	cat("real_t Jx, Jy, Jz, rho;\n")
	if (type == "pressure") {
		C( rho, PV("Pressure")*3+1);
		C_pull( Rs[1], Js[direction])
	} else if (type == "velocity") {
		nJ = PV("rho") * PV("Velocity")
		to_sub = list(nJ[[1]]); names(to_sub) = Js[direction]
		C_pull( subst(Rs[1], to_sub), "rho" ) 
		C( PV(Js[direction]), nJ )
	}
	for (i in 1:3) if (i != direction) C_pull( Rs[i+1], Js[i])
	C(f[sel], fs[sel])
}	

?>

CudaDeviceFunction void EVelocity()
{
	<?R ZouHe(1,-1,"velocity") ?>

}

CudaDeviceFunction void eqWVelocity()
{
}

CudaDeviceFunction void WVelocity()
{
	<?R ZouHe(1,1,"velocity") ?>
}

CudaDeviceFunction void WPressure()
{
	<?R ZouHe(1,1,"pressure") ?>
}

CudaDeviceFunction void WPressureLimited()
{

}



CudaDeviceFunction void EPressure()
{
	<?R ZouHe(1,-1,"pressure") ?>
}

CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_WPressureL:
		WPressureLimited();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
	case NODE_Wall:
	case NODE_Solid:
		BounceBack();
                break;
    }
    switch (NodeType & NODE_COLLISION) {
	case NODE_MRT:
		CollisionMRT();
		break;
    }
}

CudaDeviceFunction void SetEquilibrum(real_t rho, real_t Jx, real_t Jy, real_t Jz)
{
	<?R
		C(f, EQ$Req %*% solve(EQ$mat));
	?>
}

CudaDeviceFunction void Init() {
	SetEquilibrum(1.0 + Pressure * 3.0, Velocity, 0., 0.);
}

CudaDeviceFunction void CollisionMRT()
{
<?R
	wi = subst(EQ$Req, Jx=0, Jy=0, Jz=0)
	wi = subst(wi, rho=1)
	wi = gapply(wi,function(x) x$.M, simplify=TRUE)
	wi = wi %*% solve(EQ$mat)
	R = PV("R",1:27-1);
	R[EQ$order == 0] = rho
	R[EQ$order == 1] = J
?>
	real_t omT;
	real_t <?R C(R, sep=", ") ?>;
        real_t gamma1 = 1 - omega;
        real_t gamma2 = 1 - 1.5;// - 8.0 * ( 2.0 - omega )/( 8.0 - omega );
<?R
	S = PV("S",1:27);
	S[EQ$order  < 2] = 0;
	S[EQ$order == 2] = PV("gamma1");
	S[EQ$order  > 2] = PV("gamma2");
#	S[EQ$order >= 2] = PV("gamma1");
	selR = EQ$order >= 2
	C(R, f %*% EQ$mat);
	C(R[selR], (S*(R-EQ$Req))[selR]);
?>
    Jx += rho*ForceX;
    Jy += rho*ForceY;
    Jz += rho*ForceZ;
<?R
	C(R[selR], (R + EQ$Req)[selR]);
#	C( f, R %*% solve(EQ$mat));
	C( R, R %*% solve(t(EQ$mat) %*% EQ$mat))
	C( f, R %*% t(EQ$mat));
?>
}

