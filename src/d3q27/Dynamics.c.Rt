<?R
	source("conf.R")
	c_header();


# Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	rho =  PV("rho")
	J = PV("J",c("x","y","z"))
	tmp = PV("tmp")

# Extracting velocity set
	U = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy","dz")])

# Calculating equlibrium density set
	source("MRT/feq.R")
	EQ = MRT_eq(U, rho, J );
?>

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>;
}

CudaDeviceFunction real_t getP(){
	return ((<?R C(sum(f)) ?>)-1.0)/3.0;
}

CudaDeviceFunction vector_t getU(){
	real_t d = getRho();
	vector_t u;
<?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>
	u.x /= d;
	u.y /= d;
	u.z /= d;
	return u;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}

CudaDeviceFunction void BounceBack()
{
     real_t uf;
<?R
	uf = PV("uf")
	by(Density, Density$group, function(d) {
		i = order(d$dx,d$dy,d$dz)
		j = order(-d$dx,-d$dy,-d$dz)
		if (any(d[i,c("dx","dy","dz")]!=-d[j,c("dx","dy","dz")])) stop("Density directions are not fully symetric!");
		V = cbind(i,j);
		sel = V[,1] > V[,2]
		V = V[sel,, drop=F]
		if (nrow(V) > 0) {
		f = PV(d$name)
		apply(V,1,function(x) {
			C(uf,f[x[1]])
			C(f[x[1]],f[x[2]])
			C(f[x[2]],uf)
		})
		}
	NULL})
?>}

CudaDeviceFunction void EVelocity()
{

}

CudaDeviceFunction void eqWVelocity()
{
}

CudaDeviceFunction void WVelocity()
{

}

CudaDeviceFunction void WPressure()
{

}

CudaDeviceFunction void WPressureLimited()
{

}



CudaDeviceFunction void EPressure()
{

}

CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_WPressureL:
		WPressureLimited();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
	case NODE_Wall:
	case NODE_Solid:
		BounceBack();
                break;
    }
    switch (NodeType & NODE_COLLISION) {
	case NODE_MRT:
		CollisionMRT();
		break;
    }
}

CudaDeviceFunction void SetEquilibrum(real_t rho, real_t Jx, real_t Jy, real_t Jz)
{
	<?R
		C(f, EQ$Req %*% solve(EQ$mat));
	?>
}

CudaDeviceFunction void Init() {
	SetEquilibrum(1.0 + Pressure * 3.0, Velocity, 0., 0.);
}

CudaDeviceFunction void CollisionMRT()
{
<?R
	R = PV("R",1:27-1);
	R[EQ$order == 0] = rho
	R[EQ$order == 1] = J
?>
	real_t omT;
	real_t <?R C(R, sep=", ") ?>;
        real_t gamma1 = 1 - omega;
        real_t gamma2 = 1 - 1.5;// - 8.0 * ( 2.0 - omega )/( 8.0 - omega );
<?R
	S = PV("S",1:27);
	S[EQ$order  < 2] = 0;
	S[EQ$order == 2] = PV("gamma1");
	S[EQ$order  > 2] = PV("gamma2");
#	S[EQ$order >= 2] = PV("gamma1");
	selR = EQ$order >= 2
	C(R, f %*% EQ$mat);
	C(R[selR], (S*(R-EQ$Req))[selR]);
?>
    Jx += rho*ForceX;
    Jy += rho*ForceY;
    Jz += rho*ForceZ;
<?R
	C(R[selR], (R + EQ$Req)[selR]);
#	C( f, R %*% solve(EQ$mat));
	C( R, R %*% solve(t(EQ$mat) %*% EQ$mat))
	C( f, R %*% t(EQ$mat));
?>
}
