<?R
  source("conf.R")
  c_header();
?>

#include <iostream>
#include "Catalyst.h"
#include "Solver.h"

#include <vtkCellData.h>
#include <vtkCellType.h>
#include <vtkCPDataDescription.h>
#include <vtkCPInputDataDescription.h>
#include <vtkCPProcessor.h>
#include <vtkCPPythonScriptPipeline.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkImageData.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkPointData.h>

#ifdef CALC_DOUBLE_PRECISION
  typedef vtkDoubleArray vtkRealTArray;
#else
  typedef vtkFloatArray vtkRealTArray;
#endif
              

namespace
{
  vtkCPProcessor* Processor = NULL;
  vtkImageData* VTKGrid = NULL;
  bool exportCellData;
  int extent[6];
  int wholeExtent[6];
  lbRegion reg;
  
  void BuildVTKGrid(Solver& solver)
  {
    // The grid structure isn't changing so we only build it
    // the first time it's needed. If we needed the memory
    // we could delete it and rebuild as necessary.
    if(VTKGrid == NULL)
      {
      VTKGrid = vtkImageData::New();
      extent[0] = solver.lattice->region.dx;
      extent[1] = solver.lattice->region.dx + solver.lattice->region.nx;
      extent[2] = solver.lattice->region.dy;
      extent[3] = solver.lattice->region.dy + solver.lattice->region.ny;
      extent[4] = solver.lattice->region.dz;
      extent[5] = solver.lattice->region.dz + solver.lattice->region.nz;
      wholeExtent[0] = solver.lattice->mpi.totalregion.dx;
      wholeExtent[1] = solver.lattice->mpi.totalregion.dx + solver.lattice->mpi.totalregion.nx;
      wholeExtent[2] = solver.lattice->mpi.totalregion.dy;
      wholeExtent[3] = solver.lattice->mpi.totalregion.dy + solver.lattice->mpi.totalregion.ny;
      wholeExtent[4] = solver.lattice->mpi.totalregion.dz;
      wholeExtent[5] = solver.lattice->mpi.totalregion.dz + solver.lattice->mpi.totalregion.nz;
      if (! exportCellData) {
        if (extent[1] == wholeExtent[1]) extent[1]--;
        wholeExtent[1]--;
        if (extent[3] == wholeExtent[3]) extent[3]--;
        wholeExtent[3]--;
        if (extent[5] == wholeExtent[5]) extent[5]--;
        wholeExtent[5]--;
      }
      reg.dx = extent[0];
      reg.nx = extent[1]-extent[0];
      reg.dy = extent[2];
      reg.ny = extent[3]-extent[2];
      reg.dz = extent[4];
      reg.nz = extent[5]-extent[4];
      if (! exportCellData) {
        reg.nx++;
        reg.ny++;
        reg.nz++;
      }
      warning("extent: %d %d %d %d %d %d\n", extent[0], extent[1], extent[2], extent[3], extent[4], extent[5]);
      VTKGrid->SetExtent(extent);
      double spacing[3];
      spacing[0] = spacing[1] = spacing[2] = 1/solver.units.alt("m");
      VTKGrid->SetSpacing(spacing);
      }
  }

  void UpdateVTKAttributes(Solver& solver)
  {
    vtkIdType numberOf;
    if (exportCellData) {
      numberOf = VTKGrid->GetCellData()->GetNumberOfArrays();
    } else {
      numberOf = VTKGrid->GetPointData()->GetNumberOfArrays();
    }        
    if(numberOf == 0)
    {
      debug2("Creating Catalyst VTK objects\n");
      <?R for (q in rows(Quantities)) { ifdef(q$adjoint); ?>
      {
        debug1("Creating Catalyst VTK object for <?%s q$name ?>\n");
        vtkIdType size = static_cast<vtkIdType> (reg.size());
        vtkNew<vtkRealTArray> myArray;
        myArray->SetName("<?%s q$name ?>");
        <?R if (q$vector) { ?>
        myArray->SetNumberOfComponents(3);
        myArray->SetNumberOfTuples(size);
        <?R } else { ?>
        myArray->SetNumberOfComponents(1);
        myArray->SetNumberOfValues(size);
        <?R } ?>
        if (exportCellData) {
          VTKGrid->GetCellData()->AddArray(myArray.GetPointer());
        } else {
          VTKGrid->GetPointData()->AddArray(myArray.GetPointer());
        }        
      }
      <?R } ?>
    }
    <?R for (q in rows(Quantities)) { ifdef(q$adjoint); ?>
    {
      debug2("Filling Catalyst VTK object for <?%s q$name ?>\n");
      vtkIdType size = solver.lattice->region.size();
      vtkRealTArray* myArray;
      if (exportCellData) {
        myArray = vtkRealTArray::SafeDownCast(VTKGrid->GetCellData()->GetArray("<?%s q$name ?>"));
      } else {
        myArray = vtkRealTArray::SafeDownCast(VTKGrid->GetPointData()->GetArray("<?%s q$name ?>"));
      }      
      vtkIdType numTuples = myArray->GetNumberOfComponents();
      real_t * myArrayData = myArray->WritePointer(0,size * numTuples);
      double myUnit = solver.units.alt("<?%s q$unit ?>");
//      solver.lattice->Get<?%s q$name ?>(solver.lattice->region, (<?%s q$type ?>*)(myArrayData), 1/myUnit);
      solver.lattice->Get<?%s q$name ?>(reg, (<?%s q$type ?>*)(myArrayData), 1/myUnit);
    }
    <?R } ?>
  }

  void BuildVTKDataStructures(Solver& solver)
  {
    BuildVTKGrid(solver);
    UpdateVTKAttributes(solver);
  }
}

namespace CatalystAdaptor
{

  void Initialize(bool exportCellData_)
  {
    exportCellData = exportCellData_;
    if(Processor == NULL)
      {
      debug2("Initializing Catalyst coProcessor\n");
      Processor = vtkCPProcessor::New();
      Processor->Initialize();
      }
    else
      {
      debug2("Clearing Catalyst coProcessor\n");
      Processor->RemoveAllPipelines();
      }
  }
  
  void AddScript(const char * script)
  {
      notice("Adding Catalyst script: %s\n", script);
      vtkNew<vtkCPPythonScriptPipeline> pipeline;
      pipeline->Initialize(script);
      Processor->AddPipeline(pipeline.GetPointer());
  }

  void Finalize()
  {
    if(Processor)
    {
      Processor->Delete();
      Processor = NULL;
    }
    if(VTKGrid)
    {
      VTKGrid->Delete();
      VTKGrid = NULL;
    }
  }

  void CoProcess(Solver& solver, double time,
                 unsigned int timeStep, bool lastTimeStep)
  {
    debug2("Running Catalyst update procedure\n");
    vtkNew<vtkCPDataDescription> dataDescription;
    dataDescription->AddInput("input");
    dataDescription->SetTimeData(time, timeStep);
    if(lastTimeStep == true)
      {
      // assume that we want to all the pipelines to execute if it
      // is the last time step.
      dataDescription->ForceOutputOn();
      debug2("Last iteration in Catalyst\n");
      }
    if(Processor->RequestDataDescription(dataDescription.GetPointer()) != 0)
      {
      debug2("Data requested by Catalyst\n");
      BuildVTKDataStructures(solver);
      dataDescription->GetInputDescriptionByName("input")->SetGrid(VTKGrid);


      dataDescription->GetInputDescriptionByName("input")->SetWholeExtent(wholeExtent);
      debug2("Running Catalyst CoProcessing\n");
      Processor->CoProcess(dataDescription.GetPointer());
      }
      
  }
} // end of Catalyst namespace
