<?R
        source("conf.R")
	c_header();
?>
#include "Consts.h"
#include "pugixml.hpp"
#include "Global.h"
#include <mpi.h>
#include "cross.h"
#include "Region.h"
#include "LatticeContainer.h"
#include "Lattice.h"
#include "vtkLattice.h"
#include "Geometry.h"
#include "def.h"
#include "utils.h"
#include "unit.h"

#include <fstream>
#include <iostream>
#include <vector>
#include <iomanip>
#include <assert.h>
#include "Handlers.h"

#ifdef GRAPHICS
    const int desired_fps = 10;
	class GPUAnimBitmap;
#else
    const int desired_fps = 1;
#endif

using namespace std;

struct InfoBlock {
	char conffile[STRING_LEN];
	lbRegion region;
        lbRegion fileregion; // Size of input mesh
<?R
        for (v in rows(Settings)) { ?>
	real_t setting_<?%s v$name ?>;
	int ifset_<?%s v$name ?>; <?R
	}
?>
	int xsdim,ysdim;
        char outpath[STRING_LEN];
};

class Solver {
    public:
	InfoBlock info;
	MPIInfo mpi;
	MPI_Comm mpi_comm;
        Lattice * lattice; // Main lattice object
	Geometry * geometry;
	lbRegion region;
        int iter; // Iteration Number
        int opt_iter;
	int mpi_rank;
	int mpi_size;
	std::vector<Handler> hands;
	int steps;
	int saveN, saveI;
	char ** saveFile;
	UnitEnv units;
	int iter_type;
#ifdef GRAPHICS
	GPUAnimBitmap * bitmap;
#endif
	void print(const char * str);
	double LogScales[ GLOBALS + SETTINGS + SCALES ];
	inline Solver() : mpi_comm(MPI_COMM_WORLD) { Init(); };
	inline ~Solver() {
		if (lattice) delete lattice;
#ifdef GRAPHICS
		if (bitmap) delete bitmap;
#endif
		if (geometry) delete geometry;
	}
	inline Solver(MPI_Comm mpi_comm_) : mpi_comm(mpi_comm_) { Init(); };
	void Init();
	void saveInit(int n);
        inline void setWidth(int &w){region.nx = w;};
        inline void setHeight(int &h){region.ny = h;};
        inline int getWidth(){return region.nx;};
        inline int getHeight(){return region.ny;};
        inline void outIterFile(const char * name, const char * suffix, char * out) {
                sprintf(out, "%s_%s_P%02d_%08d%s", info.outpath, name, mpi_rank, iter, suffix);
        };
        inline void outGlobalFile(const char * name, const char * suffix, char * out) {
                sprintf(out, "%s_%s_P%02d%s", info.outpath, name, mpi_rank, suffix);
        };
	void setOutput(const char * out);
	void setUnit(std::string, std::string, std::string);
	void Gauge();
	int initLog(const char * filename);
	int writeLog(const char * filename);
	int writeVTK(const char * nm);
	int writeBIN(const char * nm);
	int setSize(int,int,int,int);
	int MPIDivision();
	int InitAll(int);
	int RunMainLoop();
	int EventLoop();

	int Par_size, *Par_sizes, *Par_disp;
	int getPars();
	int getDPar(double * wb);
	int getPar(double * wb);
	int setPar(const double * w);
	int saveComp(const char*, const char*);
	int loadComp(const char*, const char*);

	inline int getGlobal(const char * nm) { <?R
        for (v in rows(Globals)) { ?>
        	if (strcmp(nm,"<?%s v$name ?>") == 0) return <?%s v$Index ?>; <?R
	} ?>
	        return -1;
	};
	inline char * getGlobal(const int i) {
	        switch(i) { <?R
	for (v in rows(Globals)) { ?>
                	case <?%s v$Index ?>: return "<?%s v$name ?>"; <?R
	} ?>
	        }
	        return "UNKNOWN";
	};
	
};   


inline int SettingByName(const char * str) { <?R
 for (v in rows(Settings)) { ?>
  if (strcmp("<?%s v$name?>",str) == 0) return <?%s v$Index ?>; <?R
 } ?>
 return -1;
}

inline int GlobalByName(const char * str) { <?R
 for (v in rows(Globals)) { ?>
  if (strcmp("<?%s v$name?>",str) == 0) return <?%s v$Index ?>; <?R
 } ?>
 return -1;
}

inline int GlobalInObj(int i) { <?R 
   i = which(Settings$name == paste(Globals$name[1],"InObj",sep=""));
   if (length(i) != 1) { ?>
// Probably no adjoint
   return -1; <?R
   } else { ?>
   return i + <?%s Settings$Index[i] ?>; <?R
   } ?>
}
