<?R
        source("conf.R")
	c_header();
?>
#ifndef SOLVER_H
#define SOLVER_H

#include "Consts.h"
#include "pugixml.hpp"
#include "Global.h"
#include <mpi.h>
#include "cross.h"
#include "Lattice.h"
#include "ArbLattice.hpp"
#include "utils.h"
#include "unit.h"
#include "Handlers.h"

#include <fstream>
#include <iostream>
#include <vector>
#include <iomanip>
#include <cassert>
#include <filesystem>

/// Main solver class
/**
 This class is responsible for the solver initialization and run
*/
class Solver {
public:
    std::unique_ptr<LatticeBase> lattice; ///< Main Lattice object
    MPI_Comm mpi_comm; ///< Solver's MPMD.local
    int iter = 0; ///< Iteration (Now)
    int opt_iter = 0; ///< Optimization iteration
	int mpi_rank = 0; ///< MPI rank
	int mpi_size = 1; ///< MPI size
	std::vector<Handler> hands; ///< Stack of handlers
	int steps = 1; ///< steps to the next monitor-callback
	int saveN = 0, saveI = 0; ///< No idea what it is TODO
	pugi::xml_document configfile;
	std::string conffile_path; ///< Path to the config file
    std::string outpath; ///< Output prefix
	UnitEnv units; ///< Units object connected to this lattice
	std::map<std::string, int> setting_zones = {{"DefaultZone", 0}};
	int iter_type = ITER_NORM; ///< Iteration type (Now) - primal/adjoint/etc.
	double LogScales[ GLOBALS + SETTINGS + ZONESETTINGS + SCALES ];

    Solver() = default;
    Solver(const Solver&) = delete;
    Solver(Solver&&) = default;
    Solver& operator=(const Solver&) = delete;
    Solver& operator=(Solver&&) = default;
    ~Solver() = default;

    int initCartLattice(int,int,int,int);
    int initArbLattice(size_t num_snaps, pugi::xml_node arb_node);
    Lattice* getCartLattice() const;

    int EventLoop() const { return lattice->EventLoop(); }
	void print(const char * str);

	size_t getLocalLatticeSize() const { return lattice->getLocalSize(); }
	size_t getGlobalLatticeSize() const { return lattice->getGlobalSize(); }

    void initMPI(MPI_Comm comm);
    int initLog(const char * filename);
    int writeLog(const char * filename);

/// Generate a Iteration-specific filename
/**
 Generate a filename starting with the output prefix, continuing with the name, process number,
 iteration number and suffix
 \param name Appendix added to the filename
 \param suffix Suffix (.vti, .csv, etc) of the file
 \param out Buffer for the returned file name
*/
    std::string outIterFile(const std::string& name, const std::string& suffix) const {
        auto path = formatAsString("%s_%s_P%02d_%08d%s", outpath, name, mpi_rank, iter, suffix);
		mkdir_p(path);
		return path;
    }

/// Generate a Case-specific filename
/**
 Generate a filename starting with the output prefix, continuing with the name, process number,
 and finishing with a suffix
 \param name Appendix added to the filename
 \param suffix Suffix (.vti, .csv, etc) of the file
 \param out Buffer for the returned file name
*/
    std::string outGlobalFile(const std::string& name, const std::string& suffix) const {
        auto path = formatAsString("%s_%s_P%02d%s", outpath, name, mpi_rank, suffix);
        mkdir_p(path);
        return path;
    }

/// Generate a Iteration-specific collective filename
/**
 Generate a filename starting with the output prefix, continuing with the name,
 iteration number and suffix (without process number)
 \param name Appendix added to the filename
 \param suffix Suffix (.vti, .csv, etc) of the file
 \param out Buffer for the returned file name
*/
    std::string outIterCollectiveFile(const std::string& name, const std::string& suffix) {
        auto path = formatAsString("%s_%s_%08d%s", outpath, name, iter, suffix);
        mkdir_p(path);
        return path;
    }

	void setOutput(std::string out);
	void setUnit(std::string, std::string, std::string);
	void Gauge();

/// Gets a Global index by name
/**
 Gets the index of a Global by it's name
 \param name Name of the Global
 \return Index of the Global requested
*/
	int getGlobal(std::string_view name) { <?R
        for (v in rows(Globals)) { ?>
     	if (name == "<?%s v$name ?>") return <?%s v$Index ?>; <?R
	} ?>
            return -1;
	};

/// Gets a Global name by index
/**
 Gets the string name of a Global by it's index
 \param i Index of the Global
 \return char * constant name of the Global requested, or "UNKNOWN" if the index is wrong
*/
    char * getGlobal(const int i) {
	    switch(i) { <?R
	for (v in rows(Globals)) { ?>
            case <?%s v$Index ?>: return "<?%s v$name ?>"; <?R
	} ?>
	    }
	    return "UNKNOWN";
    }
};

/// Gets a Setting index by name
/**
 Gets the index of a Setting by it's name
 \param str Name of the Setting
 \return Index of the Setting requested
*/
inline int SettingByName(const char * str) { <?R
 for (v in rows(Settings)) { ?>
  if (strcmp("<?%s v$name?>",str) == 0) return <?%s v$Index ?>; <?R
 } ?>
 return -1;
}

/// Gets a Global index by name
/**
 Gets the index of a Global by it's name
 \param str Name of the Global
 \return Index of the Global requested
*/
inline int GlobalByName(const char * str) { <?R
 for (v in rows(Globals)) { ?>
  if (strcmp("<?%s v$name?>",str) == 0) return <?%s v$Index ?>; <?R
 } ?>
 return -1;
}


/// Gets the index of the Setting related to a weight of a Global in the objective
/**
 Gets the index of the Setting for the weight of some Global in the objective
 \param i Index of the Global
 \return Index of the Setting related to the Global
*/
inline int GlobalInObj(int i) { <?R 
   i = which(Settings$name == paste(Globals$name[1],"InObj",sep=""));
   if (length(i) != 1) { ?>
// Probably no adjoint
   return -1; <?R
   } else { ?>
   return i + <?%s Settings$Index[i] ?>; <?R
   } ?>
}

#endif
