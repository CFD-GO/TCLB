<?R source("conf.R") ?>

#include "Solver.h"

#ifdef GRAPHICS
    const int desired_fps = 10;
#else
    const int desired_fps = 1;
#endif

int vtkWriteLattice(char * filename, Lattice * lattice);

using namespace std;

void MouseMoveG( LBSolver * data, int x, int y, int nx, int ny );
void MainLoopG( uchar4* outputBitmap, LBSolver *data, int ticks );
void MainFreeG( LBSolver *data );
extern int _xsdim;

inline void stripbare(char * str)
{
	int i = 0, j=0;
	while (str[i])
	{
		str[j] = str[i];
		if (str[j] == '/') j = -1;
		i++;j++;
	}
	str[j] = 0;
	i = 0;
	j = -1;
	while (str[i]) {
		if (str[i] == '.') j =i;
		i++;
	}
	if (j == -1) j = i;
	str[j] = 0;
}



        void LBSolver::outIterFile(const char * name, char * suffix, char * out) {
		#ifdef PARALLEL
                    sprintf(out, "%s_%s_P%02d_%08d%s", info.outpath, name, mpi_rank, iter, suffix);
                #else
		    sprintf(out, "%s_%s_%08d%s", info.outpath, name, iter, suffix);
		#endif
        };
        void LBSolver::outGlobalFile(const char * name, char * suffix, char * out) {
		#ifdef PARALLEL
                    sprintf(out, "%s_%s_P%02d%s", info.outpath, name, mpi_rank, suffix);
		#else
                    sprintf(out, "%s_%s%s", info.outpath, name, suffix);
		#endif
        };

        // Mouse handler. Active while button hold.
        void LBSolver::MouseMove(int x, int y, int nx, int ny )
        {
                lbRegion r(
                        x,
                        region.ny - y - 1,
                        0,
                1,1,1);
                char NodeType = NODE_Solid;
                lattice->FlagOverwrite(&NodeType,r); // Overwrite mesh flags with flags from 'mask' table

        }

        // Main loop function
        void LBSolver::MainLoop( uchar4* outputBitmap, int ticks )
        {
            static int step = 10, i; // Steps per frame
            float   elapsedTime, outofTime; // Elapsed times
            CudaEventRecord( start, 0 );
            CudaEventSynchronize( start );
            CudaEventElapsedTime( &outofTime, stop, start );

        //---------------------------- MAIN LOOP ------------------------------//

        //screenDumpLattice(lattice);

            for (i =0; i<step;i++)
            {
                iter++;
                lattice->Iterate(); // LB iteration
                if (iter >= info.MaxIter) break;
                CudaThreadSynchronize();
                MPI_Barrier(MPI_COMM_WORLD);
            }
        //---------------------------- END of LOOP ----------------------------//

            // Time measurement
            CudaEventRecord( stop, 0 );
            CudaEventSynchronize( stop );
            CudaEventElapsedTime( &elapsedTime, start, stop );

            #ifdef GRAPHICS
	        lattice->Color(outputBitmap); // Updating graphics
            #endif
            if (mpi.rank == 0) {
                int ups = (1000*i)/elapsedTime; // Steps made per second
                int lbups = (info.region.size()*i)/elapsedTime; // kilo LB updates per second
        //        int fps = 1000/elapsedTime; // Frames made per second
                int desired_steps = ups/desired_fps; // Desired steps per frame (so that on next frame fps = desired_fps)
                // Print information
                printf("%8d it     %4.1f MLBUps                             Data: %5.2f GB/s\n", iter, ((double)lbups)/1000, ((double)lbups * NUMBER_OF_DENSITIES * sizeof(type_f))/1e6);
                printf("                                                        time:%5.1f, out-of-frame: %5.1f, elapsed: %4.1f MLBUps\n", elapsedTime, outofTime, ((double)(info.region.size()*i))/(elapsedTime+outofTime)/1000);
                step = desired_steps;
                if (step < 1) step = 1;
            }
            MPI_Bcast(&step, 1, MPI_INT, 0, MPI_COMM_WORLD);
     	    #ifdef GRAPHICS
            	if (iter >= info.MaxIter) glutLeaveMainLoop();
	    #endif
        }


	// Function for cleanup. Free memory, etc.
        void LBSolver::MainFree() {
            printf("cudaFree ...\n");
            CudaEventDestroy( start );
            CudaEventDestroy( stop );
            delete lattice;
        }

	LBSolver::~LBSolver() {
		MainFree();
	}

	// --------------------------------- constructor ---------------------------------------------
	LBSolver::LBSolver(int nx_, int ny_, int nz_) {
            // Error handling for scanf
            #define HANDLE_IOERR(x) if ((x) == EOF) { fprintf(stderr, "Error in fscanf.\n"); return -1; }

            #ifdef PARALLEL
		{ int argc = 1;
		  char * argv1[2] = {"czesc","cos"};
		  char ** argv = argv1;
                  MPI_Init(&argc, &argv);
		}
                MPI_Comm_rank(MPI_COMM_WORLD,  &mpi_rank);
                MPI_Comm_size(MPI_COMM_WORLD,  &mpi_size);
            #else
                mpi_rank = 0;
                mpi_size = 1;
            #endif

                mpi.node = new NodeInfo[mpi_size];
                mpi.size = mpi_size;
                mpi.rank = mpi_rank;
                for (int i=0;i < mpi_size; i++) mpi.node[i].rank = i;

        #ifdef CROSS_CPU
                info.xsdim = 1;
        #else
            #ifdef GRAPHICS
                    info.xsdim = 32;
            #else
            {
                    info.xsdim = GetMaxThreads();
                    printf( "Running at %d threads per block\n", info.xsdim);
            }
            #endif
        #endif

        if (info.xsdim > 512) info.xsdim = 512;

           if (mpi_rank == 0)
           {
		info.region.nx = nx_;
		info.region.ny = ny_;
		info.region.nz = nz_;
                printf("Mesh size: %dx%dx%d\n",info.region.nx, info.region.ny, info.region.nz);
		info.MaxIter = 30;
		info.outpath[0] = '\0';
           }

	   if (info.region.nx < info.xsdim) {
                info.xsdim = info.region.nx - 1 + 32 - ((info.region.nx - 1) % 32);
                printf("small mesh: resetting number of threads to: %d\n", info.xsdim);
           }
	   info.region.nx += info.xsdim - 1 - ((info.region.nx - 1) % info.xsdim);
           printf("Mesh size with margins: %dx%dx%d\n",info.region.nx, info.region.ny,info.region.nz);

           #ifdef PARALLEL
                MPI_Bcast(&info, sizeof(InfoBlock), MPI_BYTE, 0, MPI_COMM_WORLD);
           #endif
           #ifndef CROSS_CPU
                _xsdim = info.xsdim;
           #endif

           // MPI DIVISION
           if (mpi_rank == 0) {
                int divx,divy,com;
                int mincom = mpi_size * (info.region.ny+info.region.nx);
                for (divx = 1; divx <= mpi_size; divx ++)
                 if (mpi_size % divx == 0) {
                        divy = mpi_size / divx;
                        com = (divx-1) * info.region.ny + (divy-1) * info.region.nx;
                        printf("MPI division: %d x %d --> %d\n", divx, divy, com);
                        if (com < mincom) {
                                printf("better ...");
                                int * xlens = new int[divx];
                                int * ylens = new int[divy];
                                int mx,my;
                                mx = info.region.nx/info.xsdim;
        //			my = info.region.ny/YSDIM;
                                my = info.region.ny;
                                if (mx >= divx && my >= divy) {
                                        printf("Division X:");
                                        for (int i=0; i<divx; i++)
                                        {	xlens[i] = mx/(divx-i);
                                                mx -= xlens[i];
                                                xlens[i] *= info.xsdim;
                                                printf(" %d",xlens[i]);
                                        }
                                        printf(" Y:");
                                        for (int i=0; i<divy; i++)
                                        {	ylens[i] = my/(divy-i);
                                                my -= ylens[i];
        //					ylens[i] *= YSDIM;
                                                printf(" %d",ylens[i]);
                                        }
                                        printf("\n");
                                        int dx=0,dy=0,k=0;;
                                        for (int j=0; j<divy; j++) {
                                                dx = 0;
                                                for (int i=0; i<divx; i++) {
                                                //	printf("Processor %d %dx%d + %d,%d\n",k,xlens[i],ylens[j],dx,dy); 
                                                        mpi.node[k].region.dx = dx;
                                                        mpi.node[k].region.dy = dy;
                                                        mpi.node[k].region.nx = xlens[i];
                                                        mpi.node[k].region.ny = ylens[j];
                                                        mpi.node[k].region.dz = info.region.dz;
                                                        mpi.node[k].region.nz = info.region.nz;
                                                        dx += xlens[i];
                                                        k++;
                                                }
                                                dy += ylens[j];
                                        }
                                        fillSides(mpi, divx, divy, 1);
                                        k = 0;
                                        for (int i=0; i < mpi_size; i++) {
                                                if (k < mpi.node[i].region.size()) k = mpi.node[i].region.size();
                                        }
                                        float overhead = ((double)(  k*mpi_size - info.region.size()  )) / info.region.size();
                                        printf("Max region size: %d. Mesh size %d. Overhead: %2.f%%\n", k, info.region.size(), overhead * 100);
                                } else {
                                        printf("Mesh too small to divide\n");
                                }
                                delete[] xlens;
                                delete[] ylens;
                        }
                }
            }

           #ifdef PARALLEL
                MPI_Bcast(mpi.node, mpi_size * sizeof(NodeInfo), MPI_BYTE, 0, MPI_COMM_WORLD);
           #else
                mpi.node[0].region = info.region;
           #endif
           region = mpi.node[mpi_rank].region;
           mpi.totalregion = info.region;

        //    MPI_Barrier(MPI_COMM_WORLD); return 0;

            // Making a window
            #ifdef GRAPHICS
                printf("Running graphics at %dx%d\n", region.nx, region.ny);
                bitmap = new GPUAnimBitmap( region.nx, region.ny, this );
		glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE,
	              GLUT_ACTION_GLUTMAINLOOP_RETURNS);
            #endif

            // Creating Lattice (GPU allocation is here)
            lattice = new Lattice(region);
            lattice->mpi = mpi;

            // Timers initiation
            CudaEventCreate( &start );
            CudaEventCreate( &stop );
            CudaEventRecord( stop, 0 );
		iter = 0;
	}

	void LBSolver::Initialize()
	{
            lattice->Init();
	}

	void LBSolver::Iterate(int NextIter){
            // Main loop call
	    info.MaxIter = NextIter;
            #ifdef GRAPHICS
                bitmap->mouse_move( (void (*)(void*,int,int,int,int)) MouseMoveG);
                bitmap->anim_and_exit( (void (*)(uchar4*,void*,int)) MainLoopG, (void (*)(void*))MainFreeG );
            #else
                while (iter < info.MaxIter) {
//		   printf("%d / %d\n",iter, info.MaxIter);
                   MainLoop(NULL, 0);
                 }
            #endif
        }

	void LBSolver::FlagOverwrite(int dx, int dy, int dz, int nx, int ny, int nz, Rcpp::IntegerVector v)
	{
		lbRegion over(dx,dy,dz,nx,ny,nz);
		over.print();
		char * mask = new char[over.size()];
		int i;
		if (v.length() == 1) {
			for (i = 0; i<over.size(); i++) mask[i] = v[0];
		} else if (v.length() == over.size()) {
			for (i = 0; i<over.size(); i++) mask[i] = v[i];
		} else {
			printf("(CLB) ERROR: wrong length of the mask in FlagOverwrite\n");
		}
		lattice->FlagOverwrite(mask, over);
		delete[] mask;
	}


<?R
for (i in 1:nrow(Quantities)) {
	q = Quantities[i,,drop=F];
	j = 0;
	coef = "";
?>

	Rcpp::NumericVector LBSolver::Get<?%s q$name ?>(int dx, int dy, int dz, int nx, int ny, int nz)
	{
		lbRegion over(dx,dy,dz,nx,ny,nz);
		int size = over.size();
		<?%s q$type  ?> * vp = new <?%s q$type  ?>[size];
		lattice->Get<?%s q$name ?>(over, vp);
		<?R if (q$type == "type_v") { ?>		
		Rcpp::NumericMatrix v(size,3);
		<?R } else { ?>		
		Rcpp::NumericVector v(size);
		<?R } ?>	
		for (int i =0; i<size; i++) {
		<?R  if (q$type == "type_v") { ?>
//			printf("%lf\n", vp[i].x);		
			v(i,0) = vp[i].x;
			v(i,1) = vp[i].y;
			v(i,2) = vp[i].z;
		<?R  } else { ?>		
			v[i] = vp[i];
		<?R  }?>	
		}	
		return v;
	}

<?R } ?>

<?R for (i in 1:nrow(DensityAll)) { d = DensityAll[i,,drop=F]; ?>
	Rcpp::NumericVector LBSolver::Get_<?%s d$nicename ?>(int dx, int dy, int dz, int nx, int ny, int nz)
	{
		lbRegion over(dx,dy,dz,nx,ny,nz);
		int size = over.size();
		type_f * vp = new type_f[size];
		lattice->Get_<?%s d$nicename ?>(over, vp);
		Rcpp::NumericVector v(size);
		for (int i =0; i<size; i++) {
                        v[i] = vp[i];    
                }               
                return v;       
        }

	void LBSolver::Set_<?%s d$nicename ?>(int dx, int dy, int dz, int nx, int ny, int nz, Rcpp::NumericVector v)
	{
		lbRegion over(dx,dy,dz,nx,ny,nz);
		int size = over.size();
		type_f * vp = new type_f[size];
		if (v.length() == 1) {
                        for (int i = 0; i<over.size(); i++) vp[i] = v[0];
                } else if (v.length() == over.size()) {
                        for (int i = 0; i<over.size(); i++) vp[i] = v[i];
                } else {
                        printf("(CLB) ERROR: wrong length of the mask in Set_<?%s d$nicename ?>\n");
                }
		lattice->Set_<?%s d$nicename ?>(over, vp);
        }
<?R } ?>

	void LBSolver::WriteVTK(string name)
	{	char filename[256];
		outIterFile(name.c_str(), ".vti", filename);
		vtkWriteLattice(filename, lattice);
	}

<?R
for (i in 1:nrow(Settings))
{
	v = Settings[i,];
?>
	void LBSolver::Set_<?%s v$name ?>(double tmp) {
		setting_<?%s v$name ?> = tmp;
		<?%s v$FunName ?>((type_f) tmp);
	}
	double LBSolver::Get_<?%s v$name ?>() {
		return setting_<?%s v$name ?>;
	} <?R
} ?>

	string LBSolver::get_outpath() { string ret(info.outpath); return ret; }
	void LBSolver::set_outpath(string tmp) { strcpy(info.outpath, tmp.c_str()); }

void MouseMoveG( LBSolver * data, int x, int y, int nx, int ny )
{
	data->MouseMove(x,y,nx,ny);
}

void MainLoopG( uchar4* outputBitmap, LBSolver *data, int ticks )
{
	data->MainLoop( outputBitmap, ticks);
}

void MainFreeG( LBSolver *data )
{
	data->MainFree();
}


RCPP_MODULE(yada){
  using namespace Rcpp ;
  class_<LBSolver>("LBSolver")
   .constructor<int,int,int>()
   .field("Iteration", &LBSolver::iter)
   .method("Iterate", &LBSolver::Iterate, "Iterate a bit" )
   .method("WriteVTK", &LBSolver::WriteVTK, "Write to vtk" )
   .method("FlagOverwrite", &LBSolver::FlagOverwrite, "Iterate a bit" )
   .method("Initialize", &LBSolver::Initialize, "Initialize the lattice distributions" )
<?R for (i in 1:nrow(Quantities)) { q = Quantities[i,,drop=F]; tp="double"; ?>
   .method("Get<?%s q$name ?>", &LBSolver::Get<?%s q$name ?>, "Get <?%s q$name ?> from a region")
<?R } ?>
<?R for (i in 1:nrow(DensityAll)) { d = DensityAll[i,,drop=F]; ?>
   .method("Get_<?%s d$nicename ?>", &LBSolver::Get_<?%s d$nicename ?>, "Get <?%s d$name ?> from a region")
   .method("Set_<?%s d$nicename ?>", &LBSolver::Set_<?%s d$nicename ?>, "Set <?%s d$name ?> from a region")
<?R } ?>
<?R for (i in 1:nrow(Settings)) { v = Settings[i,]; ?>
   .method("Set_<?%s v$name ?>",&LBSolver::Set_<?%s v$name ?>, "Set <?%s v$comment ?>")
   .property("<?%s v$name ?>",&LBSolver::Get_<?%s v$name ?>,&LBSolver::Set_<?%s v$name ?>)
<?R } ?>
   .property("outpath",&LBSolver::get_outpath,&LBSolver::set_outpath)
  ;

}

