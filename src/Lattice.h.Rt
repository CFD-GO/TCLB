<?R
        source("conf.R")
	c_header();
?>
#ifndef LATTICE_H
#define LATTICE_H 1

#include "LatticeBase.hpp"
#include "CartLatticeLauncher.h"
#include "CartConnectivity.hpp"
#include "Sampler.h"
#include "Geometry.h"

#include <memory>

#ifdef GRAPHICS
    const int desired_fps = 10;
	#include "gpu_anim.h"
#else
    const int desired_fps = 1;
#endif

struct ParStruct {
    int Par_size;                     ///< Parameter space dimension
    std::unique_ptr<int[]> Par_sizes; ///< Parameter space dimensions on all the processors
    std::unique_ptr<int[]> Par_disp;  ///< Offsets in the Parameter vector for all the processors
};

/// Class for computations
/**
  Class for all the memory allocation, storage, calculation
  recording for unsteady adjoint etc.
*/
class Lattice : public LatticeBase {
public:
  CartConnectivity connectivity; ///< Who's my neighbor? Which regions do they own?
  std::unique_ptr<Geometry> geometry; ///< Main Geometry object

private:
  static constexpr int maxSnaps = 33;

  CartLatticeLauncher launcher; ///< Main execution context, encapsulates the lattice container
  storage_t *mpiin[27], *mpiout[27]; ///< MPI Buffers
  storage_t *gpuin[27], *gpuout[27], *gpubuf[27], *gpubuf2[27]; ///< GPU Buffers
  size_t bufsize[27]; ///< Sizes of the Buffers
  int nodein[27], nodeout[27]; ///< MPI Ranks of sources and destinations for Buffers
  int bufnumber; ///< Number of non-NULL Buffers
  int nSnaps; ///< Number of Snapshots
  std::unique_ptr<FTabs[]> Snaps; ///< Snapshots
  std::unique_ptr<int[]> iSnaps = std::make_unique<int[]>(maxSnaps); ///< Snapshot number (Now)
#ifdef ADJOINT
  std::array<FTabs, 2> aSnaps; ///< Adjoint Snapshots
#endif
#ifdef GRAPHICS
	std::unique_ptr<GPUAnimBitmap> bitmap; ///< Maybe we have a bitmap for animation
#endif

public:
  std::unique_ptr<Sampler> sample; //initializing sampler with zero size
  real_t px, py, pz;
  int Snap, aSnap = 0; ///< Snapshot and Adjoint Snapshot number (Now)

  Lattice (CartConnectivity connect, int ns, const UnitEnv& units_);
  Lattice(const Lattice&) = delete;
  Lattice(Lattice&&) = delete;
  Lattice& operator=(const Lattice&) = delete;
  Lattice& operator=(Lattice&&) = delete;
  ~Lattice ();

  const lbRegion& getLocalRegion() const { return connectivity.getLocalRegion(); }
  const lbRegion& getGlobalRegion() const { return connectivity.global_region; }
  size_t getLocalSize() const override { return static_cast<size_t>(getLocalRegion().size()); }
  size_t getGlobalSize() const override { return static_cast<size_t>(connectivity.global_region.size()); }
  const std::map<std::string,int>& getSettingZones() const override { return geometry->SettingZones; }

  int EventLoop() override;
  void MPIInit ();
  void Color(uchar4 *);
  int Offset(int,int,int);
  void setPosition(double, double, double);
  void FlagOverwrite(flag_t *, const lbRegion&);
  void CutsOverwrite(cut_t * Q, const lbRegion& over);
  void Init();
  void listTabs(FTabs&, int*n, size_t ** size, void *** ptr, size_t * maxsize);
  int save(FTabs&, const char * filename);
  int load(FTabs&, const char * filename);
  std::string saveSolution(const std::string& filename);
  void loadSolution(const char * filename);
  size_t sizeOfTab();
  void saveToTab(real_t * tab, int snap);
  void saveToTab(real_t * tab) { saveToTab(tab,Snap); }
  void loadFromTab(real_t * tab, int snap);
  void loadFromTab(real_t * tab) { loadFromTab(tab,Snap); }
  void startRecord();
  void rewindRecord();
  void stopRecord();
  void clearAdjoint();
  void clearDPar();
  void MarkIteration() {
    ++total_iterations;
    if (callback) callback_iter = callback(segment_iterations, total_iterations);
  }
  void FinalIteration() {
	total_iterations = segment_iterations;
    if (callback) callback_iter = callback(segment_iterations, total_iterations);
  }
  void InitialIteration(int segiter) {
    total_iterations = 0;
    segment_iterations = segiter;
    if (callback) callback_iter = callback(segment_iterations, total_iterations);
  }
  int getSnap(int );
  void MPIStream_A();
  void MPIStream_B(int );
  void MPIStream_B() { MPIStream_B(0); }
  void SetFirstTabs(int, int); <?R
for (a in rows(Actions)) { ?>
  void <?%s a$FunName ?>_Adj(int, int, int, int, int);
  void <?%s a$FunName ?>_Opt(int, int, int, int, int);
  void <?%s a$FunName ?>(int, int, int); <?R
} ?>
  void GetCoords(real_t*);
  void Get_Field(int, real_t * tab);
  void Set_Field(int, real_t * tab);
  void Get_Field_Adj(int, real_t * tab);
  void IterateAction(int action, int iter, int iter_type);
  void RunAction(int action, int a, int b, int iter_type) {
		switch (action) { <?R
    for (a in rows(Actions)) { ?>
		case <?%s a$Index ?>: return <?%s a$FunName ?>(a, b, iter_type); <?R
    } ?>
		}
	}
  void RunAction(int action, int iter_type) {
    RunAction(action, Snap, (Snap+1) % 2, iter_type);
  }

  int loadComp(const char* filename, const char* comp) const;

  void Iterate(int, int) override;
  void IterateTill(int, int) override;

  void GetFlags(const lbRegion&, flag_t *) const;
<?R for (d in rows(DensityAll)) { ?>
  void Get_<?%s d$nicename ?>(real_t * tab) const;
  void Clear_<?%s d$nicename ?>();
  void Set_<?%s d$nicename ?>(real_t * tab);
  void Get_<?%s d$nicename ?>_Adj(real_t * tab) const;
  void Clear_<?%s d$nicename ?>_Adj();
  void Set_<?%s d$nicename ?>_Adj(real_t * tab);
<?R } ?>
void GetQuantity(int quant, const lbRegion& over, real_t * tab, real_t scale);
<?R for (q in rows(Quantities)) { ifdef(q$adjoint); ?>
  void Get<?%s q$name ?>(const lbRegion& over, <?%s q$type ?> * tab, real_t scale);
  void GetSample<?%s q$name ?>(const lbRegion& over, real_t scale,real_t* tab);
  void Get<?%s q$name ?>(const lbRegion& over, <?%s q$type ?> * tab) { Get<?%s q$name ?>(over, tab, 1.0); }
  <?R tp = "double" ?>
  void Get<?%s q$name ?>_<?%s tp ?>(const lbRegion& over, <?%s tp ?> * tab, int row);
<?R }; ifdef() ?>

  int saveComp(const std::string& filename, const char* comp) const;

  int getPars(ParStruct& par_struct);
  int getDPar(const ParStruct& par_struct, double * wb);
  int getPar(const ParStruct& par_struct, double * wb);
  int setPar(const ParStruct& par_struct, double * w);

  void updateAllSamples();
  void resetAverage();
};

#endif
