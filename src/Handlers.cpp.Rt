<?R
        source("conf.R")
	c_header();
?>

#include "Consts.h"
#include "pugixml.hpp"
#include "Global.h"
#include <mpi.h>
#include "cross.h"
#include "Region.h"
#include "LatticeContainer.h"
#include "Lattice.h"
#include "vtkLattice.h"
#include "Geometry.h"
#include "def.h"
#include "utils.h"
#include "unit.h"

#include <fstream>
#include <iostream>
#include <vector>
#include <iomanip>
#include <assert.h>

#include "Solver.h"

#ifdef WITH_NLOPT
        #include  <nlopt.h>
#endif

#define ITERATION_STOP 1

int vHandler::DoIt() {
	ERROR("Called virtual function (DoIt)!\n");
	exit(-1);
	return -1;
};

int vHandler::Init() {
	ERROR("Called virtual function (Init)!\n");
	exit(-1);
	return -1;
};

int vHandler::Finish() {
	ERROR("Called virtual function (Finish)!\n");
	exit(-1);
	return -1;
};

int vHandler::Type() {
	return 0;
};

class Callback : public vHandler {
public:
	int DoIt() {
	}
	int Init() {
		pugi::xml_attribute attr = node.attribute("Iterations");
		startIter = solver->iter;
		if (attr) {
			double it = solver->units.alt(attr.value());
			everyIter = it;
			output("Setting callback %s at %lf iterations\n", node.name(), it);
		} else {
			everyIter = 0;
                        output("Callback %s with no Iterations attribute", node.name());
		}
		return 0;
	}
	int Finish() {
		return 0;
	}
	int Type() { return HANDLER_CALLBACK; }
};

class Action : public vHandler {
public:
	int DoIt() {
	}
	int Init() {
		pugi::xml_attribute attr = node.attribute("Iterations");
		if (attr) {
			double it = solver->units.alt(attr.value());
			startIter = solver->iter;
			everyIter = it;
			if (D_MPI_RANK == 0) {
        			output("Setting action %s at %lf iterations\n", node.name(), it);
			}
		} else {
			startIter = solver->iter;
			everyIter = 0;
		}
		if (node.attribute("output")) {
			solver->setOutput(node.attribute("output").value());
		}
		return 0;
	}
	int Finish() {
		return 0;
	}
	int Type() { return HANDLER_ACTION; }
};

class cbVTK: public Callback {
	std::string nm;
	name_set s;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		nm = "VTK";
		if (attr) nm = attr.value();
		attr = node.attribute("what");
		if (attr) {
		        s.add_from_string(attr.value(),',');
                } else {
                        s.add_from_string("all",',');
                }
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		return solver->writeVTK(nm.c_str(), &s);
	};
};

class cbBIN: public Callback {
	std::string nm;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		nm = "BIN";
		if (attr) nm = attr.value();
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		return solver->writeBIN(nm.c_str());
	};
};

class cbLog: public Callback {
	std::string filename;
	int old_iter_type;
	public:
	int Init() {
		char fn[STRING_LEN];
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		std::string nm = "Log";
		if (attr) nm = attr.value();
		solver->outIterFile(nm.c_str(), ".csv", fn);
		filename = fn;
		solver->initLog(filename.c_str());
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
		solver->writeLog(filename.c_str());
		return 0;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		Callback::Finish();
	}
};

class cbStop: public Callback {
        std::vector< int > what;
        std::vector< double > change;
        std::vector< double > old;
	int times, score;
	int old_iter_type;
	public:
	int Init() {
		Callback::Init();
		double stop;
		pugi::xml_attribute attr;
		<?R 
		        for (g in rows(Globals)) { ?>
		attr = node.attribute("<?%s g$name ?>Change");
		if (attr) {
			stop = attr.as_double();
			what.push_back(<?%s g$Index ?>);
			change.push_back(stop);
			old.push_back(-12341234);
		} <?R
		        } ?>
		if (what.size() < 1) {
			error("No *Change attribute in %s\n", node.name());
			return -1;
		}
		attr = node.attribute("Times");
		if (attr) {
			times = attr.as_int();
			if (times < 1) {
			        error("Minimal number for Times attribute is 1\n");
                                return -1;
                        }
		} else {
		        times = 1;
		}
		score = 0;
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
		int ret=0;
                if (solver->mpi_rank == 0) {
                        int any = 0;
                        output("Stop criterium:");
                        for (int i=0;i<what.size();i++) {
                                double v = solver->lattice->globals[ what[i] ];
                                if (fabs(old[i] - v) > change[i]) any++;
                                if (D_MPI_RANK == 0) {
                                        output("                 %4lg / %4lg", fabs(old[i] - v), change[i]);
                                }
                                old[i] = v;
                        }
                        if (!any) {
                                score++;
                        } else {
                                score = 0;
                        }
                        if (D_MPI_RANK == 0) {
                                output("Score: %d\n", score);
                        }
                        if (score >= times) {
                                if (D_MPI_RANK == 0) notice("Stop.\n");
                                ret = ITERATION_STOP;
                                for (int i=0;i<what.size();i++) {
                                        old[i] = -12341234;
                                }
                                score=0;
                        }
                }
                MPI_Bcast(&ret, 1, MPI_INT, 0, MPI_COMM_WORLD);
		return ret;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		Callback::Finish();
	}
};

class cbKeep: public Callback {
	int old_iter_type;
	int my_type;
	int what, whatInObj;
	double thr,force;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("What");
		if (attr) {
			what = GlobalByName(attr.value());
			if (what < 0) {
        			error("Unknown Global %s in %s\n", attr.value(), node.name());
        			return -1;
                        }
			whatInObj = GlobalInObj(what);
		} else {
			error("No What attribute in %s\n", node.name());
			return -1;
		}
		if (attr = node.attribute("Above")) {
			thr = attr.as_double();
                        my_type = 1;
		} else if (attr = node.attribute("Below")) {
			thr = attr.as_double();
                        my_type = -1;
		} else if (attr = node.attribute("Equal")) {
			thr = attr.as_double();
                        my_type = 0;
		} else {
			error("%s should have Above, Below or Equal attribute\n", node.name());
			return -1;		        
		}
		if (attr = node.attribute("Force")) {
			force = attr.as_double();
		} else {
		        force = 1;
                }
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
                double s = 0.0;
                if (solver->mpi_rank == 0) {
                        double v = solver->lattice->globals[ what ];
                        output("Keep: %le compared to %le\n", v, thr);
                        v = (thr - v)*force;
                        switch (my_type) {
                        case -1:
                                if (v<0) s=v;
                                break;
                        case 0:
                                s=v;
                                break;
                        case 1:
                                if (v>0) s=v;
                                break;
                        }
                }
                MPI_Bcast(&s, 1, MPI_INT, 0, MPI_COMM_WORLD);
                solver->lattice->setSetting(whatInObj, s);		
		return 0;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		Callback::Finish();
	}
};

class GenericAction: public Action {
	int stack;
	public:
	int Init() {
		stack=0;
		Action::Init();
	}
	int ExecuteInternal() {
		stack=0;
                for (pugi::xml_node par = node.first_child(); par; par = par.next_sibling()) {
			Handler hand(par, solver);
			if (hand) {
				if (hand.Type() & HANDLER_CALLBACK) {
					if (hand.hand->everyIter) {
						debug1("adding %lf\n", hand.hand->everyIter);
						solver->hands.push_back(hand);
						stack++;
					} else {
						hand.DoIt();
					}
				}
			} else return -1;
                }
		return 0;
	}
	int Unstack() {
		while(stack--) {
			solver->hands.pop_back();
		}
		return 0;
	}
	int Finish() {
		if (stack > 0) {
			WARNING("Generic action still stacked at finish\n");
			Unstack();
		}
	}
};

class GenericContainer: public GenericAction {
	public:
	int Init() {
		GenericAction::Init();
		return GenericAction::ExecuteInternal();
	}
	int Finish() {
		return GenericAction::Unstack();
		GenericAction::Finish();
	}
};


class acSolve: public GenericAction {
	public:
	int Init() {
		GenericAction::Init();
		if (GenericAction::ExecuteInternal()) return -1;
		int stop=0;
		do {
			int next_it = Next(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					int ret = solver->hands[i].DoIt();
					switch (ret) {
					case ITERATION_STOP:
						stop=1;
					case 0:
						break;
					default:
						return -1;
					}
				}
			}
			if (stop) break;
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		return 0;
	}
};

class acOptSolve: public GenericAction {
	public:
	int Init() {
		int old_iter_type = solver->iter_type;
		GenericAction::Init();
		if (GenericAction::ExecuteInternal()) return -1;
        	solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_OPT;
		int stop=0;
		do {
			int next_it = Next(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					int ret = solver->hands[i].DoIt();
					switch (ret) {
					case ITERATION_STOP:
						stop=1;
					case 0:
						break;
					default:
						return -1;
					}
				}
			}
			if (stop) break;
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		solver->iter_type = old_iter_type;
		GenericAction::Unstack();
		return 0;
	}
};

class acUSAdjoint: public GenericAction {
	int old_iter_type;
	public:
	int Init() {
		GenericAction::Init();
		old_iter_type = solver->iter_type;
		solver->iter_type = ITER_NORM | ITER_GLOBS;
		solver->lattice->startRecord();
		GenericAction::ExecuteInternal();
		everyIter = solver->iter - startIter;
		if (everyIter <= 0) {
			ERROR("No iterations done inside of Usteady Adjoint! Nothing to do\n");
			return -1;
		}
		solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_ADJOINT;
		do {
			int next_it = Prev(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Prev(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter -= solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					solver->hands[i].DoIt();
				}
			}
		} while (!Now(solver->iter));
		solver->lattice->stopRecord();
		solver->iter += everyIter*2;
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		solver->iter_type = old_iter_type;
		return 0;
	}
};

class acSAdjoint: public GenericAction {
	int old_iter_type;
	public:
	int Init() {
		GenericAction::Init();
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		GenericAction::ExecuteInternal();
		everyIter = std::max(everyIter,  (double) (solver->iter - startIter));
		if (everyIter <= 0) {
			WARNING("Warning: Zero iterations in steady adjoint. somethings is probaby wrong\n");
			return 0;
		}
		solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_ADJOINT;
		do {
			int next_it = Next(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
       			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					solver->hands[i].DoIt();
				}
			}
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		solver->iter_type = old_iter_type;
		return 0;
	}
};

#ifdef WITH_NLOPT
double FOptimize(unsigned int n, const double * x, double * grad, void * data);
double FMaterialMore(unsigned int n, const double * x, double * grad, void * data);
double FMaterialLess(unsigned int n, const double * x, double * grad, void * data);

class acOptimize: public GenericAction {
	int par;
	nlopt_opt opt;
	double material;
	std::string method;
	public:
	int Init() {
		double val;
		double * start = NULL;
		nlopt_result res;
		material=0.0;
		GenericAction::Init();
		DEBUG_M;
		par = solver->getPars();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			ERROR("Error: No parameters defined!\n");
        			return -1;
        		}			
			notice("Parameters in optimization: %d\n", par);
			start = new double[par];
		}
		DEBUG_M;
		solver->getPar(start);
		DEBUG_M;
		int msg=0;
		if (solver->mpi_rank == 0) {
		DEBUG_M;
		        method="MMA";
        		pugi::xml_attribute attr = node.attribute("Method");
        		if (attr) {
        		        method = attr.value();
                        }
                        if (method == "LBFGS") {
        			opt = nlopt_create(NLOPT_LD_LBFGS,par);
                        } else if (method == "MMA") {
        			opt = nlopt_create(NLOPT_LD_MMA,par);
                        } else {
       			        error("Unknown Method in Optimize: %s\n", method.c_str());
       			        exit(-1);
                        }
			{
				double * bound = new double[par];
				for (int i=0;i<par; i++) bound[i] = 0;
				nlopt_set_lower_bounds(opt, bound);
				for (int i=0;i<par; i++) bound[i] = 1;
				nlopt_set_upper_bounds(opt, bound);
				delete[] bound;
			}
                        res = nlopt_set_max_objective(opt, FOptimize, this);
                        if (res < 0) {
       			        ERROR("Error while appling objective in Optimize: nlopt_set_max_objective = %d\n", res);
       			        exit(-1);
                        }
        		attr = node.attribute("Material");
        		if (attr) {
        		        std::string matdir(attr.value());
        		        for (int i=0;i<par; i++) material += start[i];
        		        if (matdir == "more") {
        			        res = nlopt_add_inequality_constraint(opt, FMaterialMore, this, 1e-3);
        		        } else if (matdir == "less") {
        			        res = nlopt_add_inequality_constraint(opt, FMaterialLess, this, 1e-3);
        		        } else {
        			        error("Material attribute in Optimize should be \"more\" or \"less\"\n");
        			        exit(-1);
                                }
                                if (res < 0) {
        			        error("Error while appling Material constraint in Optimize: nlopt_add_inequality_constraint = %d\n", res);
        			        exit(-1);
                                }
                        }
<?R
        tab=data.frame(
                attr=c("XAbsTolerance","RelTolerance","AbsTolerance","StopAtValue","MaxEvaluations"),
                nlopt=c("xtol_abs1","ftol_rel","ftol_abs","stopval","maxeval"),
                positive=c(T,T,T,F,T),
                type=c(rep("double",4),"int")
        )
        for (crit in rows(tab)) { ?>
        		attr = node.attribute("<?%s crit$attr ?>");
        		if (attr) {
                                <?%s crit$type ?> crit = attr.as_<?%s crit$type ?>(); <?R
                if (crit$positive) { ?>
                                if (crit > 0) { <?R
                } ?>
                                        output("NLOPT: Setting <?%s crit$attr ?> to %d\n", crit);
                                        nlopt_set_<?%s crit$nlopt ?>(opt, crit); <?R
                if (crit$positive) { ?>
                                } else {
        			        error("<?%s crit$attr ?> in Optimize have to be above 0\n");
        			        exit(-1);
                                } <?R
                } ?>
                        } <?R
        }
?>
		DEBUG_M;
			nlopt_result res = nlopt_optimize(opt, start, &val);
                        msg = -1;
		DEBUG_M;
                        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
			notice("NLOpt result: %d\n", res);
			switch(res) {
                                case NLOPT_SUCCESS: notice("Optimization generic success!\n"); break;
                                case NLOPT_STOPVAL_REACHED: notice("Optimization reached desired value (StopAtValue) !\n"); break;
                                case NLOPT_FTOL_REACHED: notice("Optimization stoped with change of objective below tolerance (RelTolerance/AbsTolerance) !\n"); break;
                                case NLOPT_XTOL_REACHED: notice("Optimization stoped with change of parameters below tolerance (XAbsTolerance) !\n"); break;
                                case NLOPT_MAXEVAL_REACHED: notice("Optimization stoped, because maximal number of iterations was made (MaxIterations) !\n"); break;
                                case NLOPT_FAILURE: notice("Optimization failed, I don't know why!\n"); break;
                                case NLOPT_INVALID_ARGS: notice("Optimization call failed. Some wrong arguments!\n"); break;
                                case NLOPT_OUT_OF_MEMORY: notice("Optimization call failed. Out of memory!\n"); break;
                                case NLOPT_ROUNDOFF_LIMITED: notice("Optimization failed. Changes were below numeric tolerance (good?)\n"); break;
                                case NLOPT_FORCED_STOP: notice("Optimization failed. It was stoped from within the objective function (why?)\n"); break;
                                default: notice("NLOpt result: %d\n", res); break;
                        }
			notice("Final Objective value: %lf\n",val);
			nlopt_destroy(opt);
		} else {
		DEBUG_M;
		        double f;
		        while (msg == 0) {
		DEBUG_M;
        		        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
        		        if (msg != 0) break;
        		        Execute(NULL,NULL,&f);
                        }
                        
		}
		MPI_Barrier(MPI_COMM_WORLD);
		return 0;
	}
	int Execute(const double * x, double * grad, double * f) {
		DEBUG_M;
		solver->opt_iter++;
		solver->setPar(x);
		if (GenericAction::ExecuteInternal()) return -1;
		everyIter = solver->iter - startIter;
		solver->getDPar(grad);
		*f = solver->lattice->getObjective();
		output("Evaluated objective: %lg\n", *f);
		return 0;
	}
	friend double FOptimize(unsigned int n, const double * x, double * grad, void * data);
	friend double FMaterialMore(unsigned int n, const double * x, double * grad, void * data);
	friend double FMaterialLess(unsigned int n, const double * x, double * grad, void * data);
};

double FOptimize(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	assert(n == obj->par);
	double val;
        int msg = 0; 
        output("------- Optimization iteration %3d -------\n", obj->solver->opt_iter+1);
        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
	int ret = obj->Execute(x, grad, &val);
	if (ret) {
		ERROR("Error while executing calculations in optimize. exiting loop.\n");
		nlopt_force_stop(obj->opt);
	}
	return val;
}
double FMaterialMore(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	double material = 0.0;
	for (int i=0;i<n; i++) material += x[i];
	if (grad) {
        	for (int i=0;i<n; i++) grad[i] = 1;
        }
        output("Material %le (%le at start)\n", material, obj->material);
	return material - obj->material;
}
double FMaterialLess(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	double material = 0.0;
	for (int i=0;i<n; i++) material += x[i];
	if (grad) {
        	for (int i=0;i<n; i++) grad[i] = -1;
        }
        output("Material %le (%le at start)\n", material, obj->material);
	return obj->material - material;
}
#endif

class acThreshold: public GenericAction {
	int par;
	int levels;
	public:
	int Init() {
		double val;
		double * start = NULL;
		double * slice = NULL;
		levels = 5;
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Levels");
		if (attr) {
			levels = attr.as_int();
		} else {
		        levels = 5;
			WARNING("Warning: Using default (%d) Levels in %s\n", levels, node.name());
		}
		                        
		DEBUG_M;
		par = solver->getPars();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			ERROR( "No parameters defined!\n");
        			return -1;
        		}			
			output("Parameters: %d\n", par);
			start = new double[par];
			slice = new double[par];
		}
		DEBUG_M;
		solver->getPar(start);
		DEBUG_M;
		int msg=0;
		
		for (int i=0; i < levels; i++) {
		        double th = (1.0 * i)/(levels-1);
		        solver->lattice-><?%s Settings[Settings$name=="Threshold",]$FunName ?>(th);
		        if (slice != NULL) for (int j=0;j<par;j++) slice[j]=start[j]>th ? 1.0 : 0.0;
        		solver->setPar(slice);
        		if (GenericAction::ExecuteInternal()) return -1;
                }
		return 0;
	}
};

class acThresholdNow: public GenericAction {
	int par;
	double level;
	public:
	int Init() {
		double val;
		double * start = NULL;
		double * slice = NULL;
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Level");
		if (attr) {
			level = attr.as_int();
		} else {
		        level = 0.5;
		}
		DEBUG_M;
		par = solver->getPars();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			ERROR("No parameters defined!\n");
        			return -1;
        		}			
			output("Parameters: %d\n", par);
			start = new double[par];
			slice = new double[par];
		}
		DEBUG_M;
		solver->getPar(start);
		DEBUG_M;
		int msg=0;
	        solver->lattice-><?%s Settings[Settings$name=="Threshold",]$FunName ?>(level);
	        if (slice != NULL) for (int j=0;j<par;j++) slice[j]=start[j]>level ? 1.0 : 0.0;
       		solver->setPar(slice);
		return 0;
	}
};


class acRepeat: public GenericAction {
	int times;
	public:
	int Init() {
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Times");
		if (attr) {
			times = attr.as_int();
		} else {
			error("no Times parameter in %s\n");
			return -1;
		}
		for (int i=0; i < times; i++) {
        		if (GenericAction::ExecuteInternal()) return -1;
                }
		return 0;
	}
};




class conControl: public Action {
        int iter;
        std::map< std::string , std::vector<double> > context;
	public:
	int Params(pugi::xml_node n) {
	        std::string par, zone;
	        int zone_number = -1;
	        for (pugi::xml_attribute attr = n.first_attribute(); attr; attr = attr.next_attribute()) {
	                par = attr.name();
                        int i = par.find_first_of('-');
                        if (i == string::npos) {
                                zone = "";
                                zone_number = -1;
                        } else {
                                zone = par.substr(i+1);
                                par = par.substr(0,i);
                                zone_number = solver->geometry->SettingZones[zone];
                        }
                        debug1("%s set in zone %s (%d)\n", par.c_str(), zone.c_str(), zone_number);
                }
	}
	int Internal(pugi::xml_node n){
	        for (pugi::xml_node n2 = n.first_child(); n2; n2 = n2.next_sibling()) {
                        std::string name2 = n2.name();
                        if (name2 == "Params") {
                                debug0("Params in CSV\n");
                                Params(n2);
                        } else {
        		        error("Only Params allowed in %s in Control sub-element in config\n",n.name());
        		        return -1;
                        }
                }
        }
	int Init() {
		Action::Init();
		iter = -floor(-everyIter);
		if (iter <= 0) {
		        error("Zero (or less) iterations in Control element in config\n");
		        return -1;
                }
                output("Setting iterations for time-dependent settings at %d\n",iter);
                warning("clearing old control\n");
                solver->lattice->zSet.setLen(iter);
                for (pugi::xml_node n = node.first_child(); n; n = n.next_sibling()) {
                        std::string name = n.name();
                        if (name == "Params") {
                	        debug2("Params in Control\n");
                                Params(n);
                        } else if (name == "CSV") {
                                debug2("CSV in Control\n");
                                Internal(n);
                        } else {
        		        error("Element %s not allowed in Control element in config\n", name.c_str());
        		        return -1;
                        }
                }
                std::vector<double> s;
                for (int i=0;i<iter; i++) {
                        s.push_back(sin(i/500.)*0.01);
                }
//                solver->lattice->zSet.set( ZONESETTINGS_InletVelocity, 0, s );
		return 0;
	}
};


class acParams: public Action {
	public:
	int Init() {
	        std::string par, zone;
	        int zone_number = -1;
		Action::Init();
	        for (pugi::xml_attribute attr = node.first_attribute(); attr; attr = attr.next_attribute()) {
	                debug0("Params %s = %s (only saying that it exists - see below to know if it is used\n",attr.name(),attr.value());
	                par = attr.name();
                        int i = par.find_first_of('-');
                        if (i == string::npos) {
                                zone = "";
                                zone_number = -1;
                        } else {
                                zone = par.substr(i+1);
                                par = par.substr(0,i);
                                if (solver->geometry->SettingZones.count(zone) > 0) { 
                                        zone_number = solver->geometry->SettingZones[zone];
                                } else {
                                        WARNING("Unknown zone %s (found while setting parameter %s)\n", zone.c_str(), par.c_str());
                                        zone_number = -2;
                                        zone = "";
                                }
                        }
                        if (zone_number > -2) {
                        debug2("%s set in zone %s (%d)\n", par.c_str(), zone.c_str(), zone_number);
		<?R for (v in rows(Settings)) { ?>
		        if (par == "<?%s v$name?>") {
				double val = solver->units.alt(attr.value());
				solver->lattice-><?%s v$FunName ?>(val);
			}
		<?R } ?>
		<?R for (v in rows(ZoneSettings)) { ?>
		        if (par == "<?%s v$name?>") {
				double val = solver->units.alt(attr.value());
				solver->lattice->zSet.set(<?%s v$Index?>, zone_number, val);
			}
		<?R } ?>
		        }
		}
		return 0;
	}
};


class acModel: public GenericContainer {
	public:
	int Init() {
		GenericContainer::Init();
		solver->iter = 0;
		solver->lattice->Init();
		return 0;
	}
};

class acInit: public Action {
	public:
	int Init() {
		Action::Init();
		solver->lattice->Init();
		return 0;
	}
};

class acLoad: public Action {
	public:
	int Init() {
		Action::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				error("No file specified in Load\n");
				return -1;
			}
		}
		pugi::xml_attribute attr2= node.attribute("comp");
		if (attr2) {
			solver->loadComp(attr.value(), attr2.value());
		} else {
			solver->lattice->loadSolution(attr.value());
		}
		return 0;
	}
};

class cbSave: public Callback {
	std::string fn;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				char filename[STRING_LEN];
				solver->outIterFile("Save", "", filename);
				fn = filename;
			} else fn = attr.value();
		} else fn = ((std::string) solver->info.outpath) + "_" + attr.value();
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		pugi::xml_attribute attr= node.attribute("comp");
		if (attr) {
			solver->saveComp(fn.c_str(), attr.value());
		} else {
			solver->lattice->saveSolution(fn.c_str());
		}
		return 0;
	};
};

class acGeometry: public Action {
	public:
	int Init() {
			if (solver->geometry->load(node)) {
				error("Error while loading geometry\n");
				return -1;
			}
			char filename[STRING_LEN];
			solver->outIterFile("G", ".vti", filename);
			solver->geometry->writeVTI(filename);
			solver->lattice->FlagOverwrite(solver->geometry->geom,solver->geometry->region);
			return 0;
	}
};

vHandler * getHandler(pugi::xml_node node) {
	vHandler * ret = NULL;
	std::string name(node.name());
	debug1("Parsing xml element %s\n", name.c_str());
	if (name=="VTK") {
		ret = new cbVTK;
        } else if (name=="BIN") {
		ret = new cbBIN;
        } else if (name=="Log") {
		ret = new cbLog;
        } else if (name=="Save") {
		ret = new cbSave;
        } else if (name=="Load") {
		ret = new acLoad;
        } else if (name=="Stop") {
		ret = new cbStop;
        } else if (name=="Keep") {
		ret = new cbKeep;
        } else if (name=="Solve") {
		ret = new acSolve;
        } else if (name=="OptSolve") {
		ret = new acOptSolve;
        } else if (name=="Adjoint") {
		pugi::xml_attribute attr = node.attribute("type");
		if (attr) {
			std::string type(attr.value());
			if (type == "unsteady") {
				ret = new acUSAdjoint;
			} else if (type == "steady") {
				ret = new acSAdjoint;
			} else {
				error("Unknown type of adjoint in xml: %s", type.c_str());
			}
		} else {
			pugi::xml_attribute attr = node.attribute("Iterations");
                	if (attr) {
				ret = new acSAdjoint;
				WARNING("Makin a steady adjoint, becuase you gave me Iterations - better to state type explicitly.\n");
			} else {
				WARNING("default adjoint is unsteady - better state type explicitly next time.\n");
				ret = new acUSAdjoint;
			}
		}
        } else if (name=="Params") {
		ret = new acParams;
        } else if (name=="Units") {
		ret = new GenericContainer;
        } else if (name=="Geometry") {
		ret = new acGeometry;
        } else if (name=="Repeat") {
		ret = new acRepeat;
        } else if (name=="Threshold") {
		ret = new acThreshold;
        } else if (name=="ThresholdNow") {
		ret = new acThresholdNow;
        } else if (name=="CLBConfig") {
		ret = new GenericContainer;
        } else if (name=="Model") {
		ret = new acModel;
        } else if (name=="Optimize") {
#ifdef WITH_NLOPT
		ret = new acOptimize;
#else
                ERROR("No NLOpt support. configure with --with-nlopt to use Optimize element\n");
                exit(-1);
#endif
        } else if (name=="Init") {
		ret = new acInit;
        } else if (name=="Control") {
		ret = new conControl;
        } else {
		ERROR("Unknown element '%s'\n", node.name());
		return NULL;
	}
	if (ret != NULL) ret->node = node;
	return ret;
}
