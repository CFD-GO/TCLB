<?R
        source("conf.R")
	c_header();
?>

#ifdef EMBEDED_PYTHON
    #include "Python.h"
    #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
    #include <numpy/arrayobject.h>
//    #include <numpy/old_defines.h>
#endif


#include "Consts.h"
#include "pugixml.hpp"
#include "Global.h"
#include <mpi.h>
#include "cross.h"
#include "Region.h"
#include "LatticeContainer.h"
#include "Lattice.h"
#include "vtkLattice.h"
#include "Geometry.h"
#include "def.h"
#include "utils.h"
#include "unit.h"

#include <sstream>
#include <string>
#include <fstream>
#include <iostream>
#include <vector>
#include <iomanip>
#include <assert.h>

#include "Solver.h"

#ifdef WITH_NLOPT
        #include  <nlopt.h>
#endif

#ifdef WITH_CATALYST
        #include "Catalyst.h"
#endif

#define ITERATION_STOP 1

int vHandler::DoIt() {
	ERROR("Called virtual function (DoIt)!\n");
	exit(-1);
	return -1;
};

int vHandler::Init() {
	ERROR("Called virtual function (Init)!\n");
	exit(-1);
	return -1;
};

int vHandler::Finish() {
	ERROR("Called virtual function (Finish)!\n");
	exit(-1);
	return -1;
};

int vHandler::Type() {
	return 0;
};

int vHandler::NumberOfParameters() {
	ERROR("Called virtual function (NumberOfParameters)!\n");
	exit(-1);
	return -1;
};
int vHandler::Parameters(int type, double * tab) {
	ERROR("Called virtual function (Parameters, type: %d)!\n", type);
	exit(-1);
	return -1;
};

class Callback : public vHandler {
public:
	int DoIt() {
	        return 0;
	}
	int Init() {
		pugi::xml_attribute attr = node.attribute("Iterations");
		startIter = solver->iter;
		if (attr) {
			double it = solver->units.alt(attr.value());
			everyIter = it;
			output("Setting callback %s at %lf iterations\n", node.name(), it);
		} else {
			everyIter = 0;
                        output("Callback %s with no Iterations attribute", node.name());
		}
		return 0;
	}
	int Finish() {
		return 0;
	}
	int Type() { return HANDLER_CALLBACK; }
};



class Action : public vHandler {
public:
	int DoIt() {
	        return 0;
	}
	int Init() {
		pugi::xml_attribute attr = node.attribute("Iterations");
		if (attr) {
			double it = solver->units.alt(attr.value());
			startIter = solver->iter;
			everyIter = it;
			if (D_MPI_RANK == 0) {
        			output("Setting action %s at %lf iterations\n", node.name(), it);
			}
		} else {
			startIter = solver->iter;
			everyIter = 0;
		}
		if (node.attribute("output")) {
			solver->setOutput(node.attribute("output").value());
		}
		return 0;
	}
	int Finish() {
		return 0;
	}
	int Type() { return HANDLER_ACTION; }
	int NumberOfParameters() {
		return -1;
	};
	int Parameters(int type, double * tab) {
		return -1;
	};
};

class Design : public Callback {
public:
	int DoIt() {
		output("Design called!");
	        return 0;
	}
	int Init() {
		pugi::xml_attribute attr = node.attribute("Iterations");
		startIter = solver->iter;
		if (attr) {
			ERROR("Design element in xml %s shouldent have Iteration parameter!\n", node.name());
			exit(-1);
			return -1;
		} else {
			everyIter = 0;
                        output("Design %s with no Iterations attribute", node.name());
		}
		return 0;
	}
	int Finish() {
		return 0;
	}
	virtual int Type() { return HANDLER_DESIGN; }

};

class InternalTopology : public Design {
	int Pars;
public:
	int Init() {
		Pars = -1;
		return Design::Init();
	};
	int NumberOfParameters() {
		if (Pars < 0) {
			Pars =  solver->getPars();
		}
		return Pars;
	};
	int Parameters(int type, double * tab) {
		switch(type){
		case PAR_GET:
			return solver->getPar(tab);
		case PAR_SET:
			return solver->setPar(tab);
		case PAR_GRAD:
			return solver->getDPar(tab);
		case PAR_UPPER:
			for (int i=0;i<Pars;i++) tab[i]=1;
			return 0;
		case PAR_LOWER:
			for (int i=0;i<Pars;i++) tab[i]=0;
			return 0;
		default:
			ERROR("Unknown type %d in call to Parameters in %s\n",type,node.name());
			exit(-1);
		}
		return -1;	
	};
};

class OptimalControl : public Design {
	int Pars;
	int zone_number, par_index;
	int old_iter_type;
	FILE * f;
	double lower, upper;
public:
	int Init() {
		std::string par;
		std::string zone;
		zone_number = -10;
		par_index = -10;
		Pars = -1;
		pugi::xml_attribute attr = node.attribute("what");
		if (attr) {
	                par = attr.value();
                        unsigned int i = par.find_first_of('-');
                        if (i == string::npos) {
				ERROR("Can only optimal control a parameters in a specific zone\n");
				return -1;
                        } else {
                                zone = par.substr(i+1);
                                par = par.substr(0,i);
                                if (solver->geometry->SettingZones.count(zone) > 0) { 
                                        zone_number = solver->geometry->SettingZones[zone];
                                } else {
                                        ERROR("Unknown zone %s (found while setting parameter %s)\n", zone.c_str(), par.c_str());
					return -1;
                                }
                        }
		<?R for (v in rows(ZoneSettings)) { ?>
		        if (par == "<?%s v$name?>") par_index = <?%s v$Index?>;
		<?R } ?>
			if (par_index < 0) {
				error("Unknown param %s in OptimalControl\n", par.c_str());
				return -1;
			}
			output("Selected %s (%d) in zone \"%s\" (%d) for optimal control\n", par.c_str(), par_index, zone.c_str(), zone_number);
		} else {
			ERROR("Parameter \"what\" needed in %s\n",node.name());
			return -1;
		}
		Pars = solver->lattice->zSet.getLen(par_index, zone_number);
		output("Lenght of the control: %d\n", Pars);
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_GLOBS;
		attr = node.attribute("lower");
		if (attr) {
			lower = solver->units.alt(attr.value());
		} else {
			notice("lower bound not set in %s - setting to -1\n",node.name());
			lower = -1;
		}
		attr = node.attribute("upper");
		if (attr) {
			upper = solver->units.alt(attr.value());
		} else {
			notice("upper bound not set in %s - setting to 1\n",node.name());
			upper = 1;
		}
		f = fopen((par + "-" + zone + "_optimalControl.csv").c_str(),"w");
		assert( f != NULL );
		return Design::Init();
	};
	int NumberOfParameters() {
		return Pars;
	};
	int Parameters(int type, double * tab) {
		switch(type) {
		case PAR_GET:
			output("Getting the params from the zone\n");
			solver->lattice->zSet.get(par_index, zone_number, tab);
			fprintf(f,"GET");
			for (int i=0;i<Pars;i++) fprintf(f,",%lg",(double) tab[i]);
			fprintf(f,"\n");
			return 0;
		case PAR_SET:
			output("Setting the params in the zone\n");
			fprintf(f,"SET");
			for (int i=0;i<Pars;i++) fprintf(f,",%lg",(double) tab[i]);
			fprintf(f,"\n");
			solver->lattice->zSet.set(par_index, zone_number, tab);
			return 0;
		case PAR_GRAD:
			output("Getting gradient of a param in zone\n");
			solver->lattice->zSet.get_grad(par_index, zone_number, tab);
			fprintf(f,"GRAD");
			for (int i=0;i<Pars;i++) fprintf(f,",%lg",(double) tab[i]);
			fprintf(f,"\n");
			return 0;
		case PAR_UPPER:
			for (int i=0;i<Pars;i++) tab[i]=upper;
			return 0;
		case PAR_LOWER:
			for (int i=0;i<Pars;i++) tab[i]=lower;
			return 0;
		default:
			ERROR("Unknown type %d in call to Parameters in %s\n", type, node.name());
			exit(-1);
		}
	};
};

class OptimalControlSecond : public Design {
	int Pars;
	int Pars2;
	int zone_number, par_index;
	int old_iter_type;
	double * tab2;
	double lower, upper;
	FILE * f;
public:
	int Init() {
		std::string par;
		std::string zone;
		zone_number = -10;
		par_index = -10;
		Pars = -1;
		pugi::xml_attribute attr = node.attribute("what");
		if (attr) {
	                par = attr.value();
                        unsigned int i = par.find_first_of('-');
                        if (i == string::npos) {
				ERROR("Can only optimal control a parameters in a specific zone\n");
				return -1;
                        } else {
                                zone = par.substr(i+1);
                                par = par.substr(0,i);
                                if (solver->geometry->SettingZones.count(zone) > 0) { 
                                        zone_number = solver->geometry->SettingZones[zone];
                                } else {
                                        ERROR("Unknown zone %s (found while setting parameter %s)\n", zone.c_str(), par.c_str());
					return -1;
                                }
                        }
		<?R for (v in rows(ZoneSettings)) { ?>
		        if (par == "<?%s v$name?>") par_index = <?%s v$Index?>;
		<?R } ?>
			if (par_index < 0) {
				error("Unknown param %s in OptimalControl\n", par.c_str());
				return -1;
			}
			output("Selected %s (%d) in zone \"%s\" (%d) for optimal control\n", par.c_str(), par_index, zone.c_str(), zone_number);
		} else {
			ERROR("Parameter \"what\" needed in %s\n",node.name());
			return -1;
		}
		Pars2 = solver->lattice->zSet.getLen(par_index, zone_number);
		Pars = Pars2 / 2;
		tab2 = new double[Pars2];
		output("Lenght of the control: %d\n", Pars);
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_GLOBS;

		attr = node.attribute("lower");
		if (attr) {
			lower = solver->units.alt(attr.value());
		} else {
			notice("lower bound not set in %s - setting to -1\n",node.name());
			lower = -1;
		}
		attr = node.attribute("upper");
		if (attr) {
			upper = solver->units.alt(attr.value());
		} else {
			notice("upper bound not set in %s - setting to 1\n",node.name());
			upper = 1;
		}

		f = fopen((par + "-" + zone + "_optimalControl.csv").c_str(),"w");
		assert( f != NULL );
		return Design::Init();
	};
	int NumberOfParameters() {
		return Pars;
	};
	int Parameters(int type, double * tab) {
		switch(type) {
		case PAR_GET:
			output("Getting the params from the zone\n");
			solver->lattice->zSet.get(par_index, zone_number, tab2);
			for (int i=0; i<Pars2;i+=2) tab[i/2]=tab2[i];
			fprintf(f,"GET");
			for (int i=0;i<Pars;i++) fprintf(f,",%lg",(double) tab[i]);
			fprintf(f,"\n");
			return 0;
		case PAR_SET:
			output("Setting the params in the zone\n");
			fprintf(f,"SET");
			for (int i=0;i<Pars;i++) fprintf(f,",%lg",(double) tab[i]);
			fprintf(f,"\n");
			for (int i=0; i<Pars;i++) {
				if (2*i<Pars2) tab2[2*i] = tab[i];
				if (2*i+1<Pars2) {
					if (i+1<Pars) tab2[2*i+1]=(tab[i]+tab[i+1])/2;
					else tab2[2*i+1]=tab[i];
				}
			}
			solver->lattice->zSet.set(par_index, zone_number, tab2);
			return 0;
		case PAR_GRAD:
			output("Getting gradient of a param (%d) in zone(%d)\n", par_index, zone_number);
			solver->lattice->zSet.get_grad(par_index, zone_number, tab2);
			for (int i=0; i<Pars;i++) tab[i]=0;
			for (int i=0; i<Pars;i++) {
				if (2*i<Pars2) tab[i] += tab2[2*i];
				if (2*i+1<Pars2) {
					if (i+1<Pars) {
						tab[i] += tab2[2*i+1]/2;
						tab[i+1] += tab2[2*i+1]/2;
					}
					else tab[i] += tab2[2*i+1];
				}
			}
			fprintf(f,"GRAD");
			for (int i=0;i<Pars;i++) fprintf(f,",%lg",(double) tab[i]);
			fprintf(f,"\n");
			return 0;
		case PAR_UPPER:
			for (int i=0;i<Pars;i++) tab[i]=upper;
			return 0;
		case PAR_LOWER:
			for (int i=0;i<Pars;i++) tab[i]=lower;
			return 0;
		default:
			ERROR("Unknown type %d in call to Parameters in %s\n", type, node.name());
			exit(-1);
		}
	};
};

class Fourier : public Design {
	int Pars;
	int Pars2;
	double * tab2;
	double lower, upper;
	FILE * f;
	Handler * hand;
	double pi;
public:
	int Init() {
		Pars = -1;
		pi = atan(1) * 4;
		pugi::xml_attribute attr;
                pugi::xml_node par = node.first_child();
		if (! par) {
			ERROR("%s needs exacly one child! - none found\n", node.name());
			return -1;
		}
		hand = new Handler(par, solver);
		par = par.next_sibling();
		if (par) {
			ERROR("%s needs exacly one child! - more found\n", node.name());
			return -1;
		}
		if (! (*hand)) return -1;
		if ((*hand).Type() != HANDLER_DESIGN) {
			ERROR("%s needs child of design type!\n", node.name());
			return -1;
		}

		Pars2 = (*hand)->NumberOfParameters();
		attr = node.attribute("modes");
		if (attr) {
			Pars = attr.as_int();
		} else {
			Pars = 10;
			notice("number of modes not set in %s - setting to %d\n",node.name(), Pars);
		}
		if (Pars % 2 != 1) {
			Pars = Pars + 1;
			notice("number of modes in %s not odd - setting to %d\n",node.name(), Pars);
		}
		output("Lenght of time-resolved control: %d\n", Pars2);
		tab2 = new double[Pars2];
		output("Lenght of fourier control: %d\n", Pars);

		attr = node.attribute("lower");
		if (attr) {
			lower = solver->units.alt(attr.value());
		} else {
			notice("lower bound not set in %s - setting to -1\n",node.name());
			lower = -1;
		}
		attr = node.attribute("upper");
		if (attr) {
			upper = solver->units.alt(attr.value());
		} else {
			notice("upper bound not set in %s - setting to 1\n",node.name());
			upper = 1;
		}
		return Design::Init();
	};
	int Finish() {
		delete hand;
		double w = pi;
		return 0;
	}
	int NumberOfParameters() {
		return Pars;
	};
	int Parameters(int type, double * tab) {
		double s = 0.5*(upper - lower);
		switch(type) {
		case PAR_GET:
			output("Getting the params and making fourier decomposition\n");
			(*hand)->Parameters(type, tab2);
			for (int i=0; i<Pars;i++) {
				int i0 = (i+1)>>1; int i1 = i & 1;
				tab[i] = 0;
				for (int j=0; j<Pars2; j++) {
					if (i1) {
						tab[i] += sin(i0*pi*2*j/Pars2) * tab2[j];
					} else {
						tab[i] += cos(i0*pi*2*j/Pars2) * tab2[j];
					}
				}
				if (i == 0) {
					tab[i] = tab[i] / Pars2;
				} else {
					tab[i] = 2 * tab[i] / Pars2;
				}
				output("%s[%d] = %lf\n", node.name(), i, tab[i]);
			}
			return 0;
		case PAR_SET:
			output("Setting the params with a fourier series\n");
			for (int j=0; j<Pars2; j++) {
				tab2[j] = 0;
				for (int i=0; i<Pars;i++) {
					int i0 = (i+1)>>1; int i1 = i & 1;
					if (i1) {
						tab2[j] += sin(i0*pi*2*j/Pars2) * tab[i];
					} else {
						tab2[j] += cos(i0*pi*2*j/Pars2) * tab[i];
					}
				}
			}
			(*hand)->Parameters(type, tab2);
			return 0;
		case PAR_GRAD:
			output("Getting gradient and making fourier decomposition\n");
			(*hand)->Parameters(type, tab2);
			for (int i=0; i<Pars;i++) {
				int i0 = (i+1)>>1; int i1 = i & 1;
				tab[i] = 0;
				for (int j=0; j<Pars2; j++) {
					if (i1) {
						tab[i] += sin(i0*pi*2*j/Pars2) * tab2[j];
					} else {
						tab[i] += cos(i0*pi*2*j/Pars2) * tab2[j];
					}
				}
			}
			return 0;
		case PAR_UPPER:
			for (int i=0;i<Pars;i++) {
				int i0 = (i+1)>>1; int i1 = i & 1;
				tab[i]=s/i0;
			}
			tab[0] = upper;
			return 0;
		case PAR_LOWER:
			for (int i=0;i<Pars;i++) {
				int i0 = (i+1)>>1; int i1 = i & 1;
				tab[i]= -s/i0;
			}
			tab[0] = lower;
			return 0;
		default:
			ERROR("Unknown type %d in call to Parameters in %s\n", type, node.name());
			exit(-1);
		}
	};
};


class cbVTK: public Callback {
	std::string nm;
	name_set s;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		nm = "VTK";
		if (attr) nm = attr.value();
		attr = node.attribute("what");
		if (attr) {
		        s.add_from_string(attr.value(),',');
                } else {
                        s.add_from_string("all",',');
                }
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		return solver->writeVTK(nm.c_str(), &s);
	};
};

class cbTXT: public Callback {
	std::string nm;
	name_set s;
	int txt_type;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		nm = "TXT";
		if (attr) nm = attr.value();
		attr = node.attribute("what");
		if (attr) {
		        s.add_from_string(attr.value(),',');
                } else {
                        s.add_from_string("all",',');
                }
		txt_type = 0;
		attr = node.attribute("gzip");
		if (attr) {
		        txt_type = 1;
                } else {
                }
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		return solver->writeTXT(nm.c_str(), &s, txt_type);
	};
};


#ifdef WITH_CATALYST
class cbCatalyst: public Callback {
	std::string nm;
	static int script_number;
	static bool cellData;
//	name_set s;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr;
		attr = node.attribute("export");
		bool cellDataNew = cellData;
                if (attr) {
                        std::string val = attr.value();
                        if (val == "CellData") {
                                cellDataNew = true;
                        } else if (val == "PointData") {
                                cellDataNew = false;
                        } else {
                                error("Unknown export value in Catalyst xml element: %s. Can be CellData or PointData\n",val.c_str());
                                return -1;
                        }
                }
		if (script_number == 0) {
		        CatalystAdaptor::Initialize(cellDataNew);
		        cellData = cellDataNew;
                } else {
                        if (cellData != cellDataNew) {
                                ERROR("Cannot mix CellData and PointData Catalyst outputs in one xml config\n");
                                return -1;
                        }
                }
                script_number ++;
		attr = node.attribute("script");
		if (attr) {
		        nm = attr.value();
                } else {
                        error("No script provided in Catalyst");
                        return -1;
                }
                attr = node.attribute("preprocess");
                int preprocess = 1;
                if (attr) {
                        std::string val = attr.value();
                        if (val == "yes") {
                                preprocess = 1;
                        } else if (val == "no") {
                                preprocess = 0;
                        } else {
                                error("Unknown preprocess value in Catalyst xml element: %s. Can be yes or no\n",val.c_str());
                                return -1;
                        }
                }
                if (preprocess) {
                        char fn[STRING_LEN];
                        char short_nm[STRING_LEN];
                        sprintf(short_nm, "SCRIPT%d", script_number);
//            		solver->outGlobalFile(short_nm, ".py", fn);
                        sprintf(fn, "%s_%s.py", solver->info.outpath, short_nm);
                        if (D_MPI_RANK == 0) {
                                notice("Preprocessing script %s --> %s\n", nm.c_str(), fn);
                                std::string prefix = "";
                                for (char * buf = solver->info.outpath; *buf; buf++) {
                                        if ((*buf) == '/') prefix += '\\';
                                        if ((*buf) == '\\' || (*buf) == '&' || (*buf) == ';' || (*buf) == ' ') {
                                                ERROR("illegal character in output prefix: %c!\n",*buf);
                                                return -1;                                        
                                        }
                                        prefix += *buf;
                                }
                                prefix += "_";
                                std::string com = "cat " + nm + " | sed";
                              //  com = com + " -e 's/\\([.]CreateView([^,]*,[^\"]*\\)\"\\([^\"]*\\)\"/\\1\"" + prefix + "\\2\"/g'";
                              //  com = com + " -e 's/\\([.]CreateWriter([^,]*,[^\"]*\\)\"\\([^\"]*\\)\"/\\1\"" + prefix + "\\2\"/g'";
				com = com + " -e \"s/[^/'\\\"]*\\.\\(png\\|pvti\\|pvtp\\)['\\\"]/" + prefix + "\\0/g\"";
                                com = com + " > " + fn;
                                debug2("preprocessing command: %s\n", com.c_str());
                                int ret = system(com.c_str());
                                if (ret) {
                                        ERROR("py preprocessing command failed\n");
                                        ERROR("commandline: %s\n", com.c_str());
                                        return -1;
                                }
                        }
                        nm = fn;                                                                                
                        MPI_Barrier(MPI_COMM_WORLD);
                }
//		attr = node.attribute("what");
//		if (attr) {
//		        s.add_from_string(attr.value(),',');
//                } else {
//                        s.add_from_string("all",',');
//                }
                CatalystAdaptor::AddScript(nm.c_str());
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		solver->print("running Catalyst");
		CatalystAdaptor::CoProcess(*solver, solver->iter, solver->iter, 0);
		return 0;
	};
	int Finish() {
	        CatalystAdaptor::Finalize();
	        return 0;
	};
};

int cbCatalyst::script_number = 0;
bool cbCatalyst::cellData = true;

#endif

class cbBIN: public Callback {
	std::string nm;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		nm = "BIN";
		if (attr) nm = attr.value();
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		return solver->writeBIN(nm.c_str());
	};
};

class cbLog: public Callback {
	std::string filename;
	int old_iter_type;
	public:
	int Init() {
		char fn[STRING_LEN];
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		std::string nm = "Log";
		if (attr) nm = attr.value();
		solver->outIterFile(nm.c_str(), ".csv", fn);
		filename = fn;
		solver->initLog(filename.c_str());
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
		solver->writeLog(filename.c_str());
		return 0;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		return Callback::Finish();
	}
};

class cbStop: public Callback {
        std::vector< int > what;
        std::vector< double > change;
        std::vector< double > old;
	int times, score;
	int old_iter_type;
	public:
	int Init() {
		Callback::Init();
		double stop;
		pugi::xml_attribute attr;
		<?R 
		        for (g in rows(Globals)) { ?>
		attr = node.attribute("<?%s g$name ?>Change");
		if (attr) {
			stop = attr.as_double();
			what.push_back(<?%s g$Index ?>);
			change.push_back(stop);
			old.push_back(-12341234);
		} <?R
		        } ?>
		if (what.size() < 1) {
			error("No *Change attribute in %s\n", node.name());
			return -1;
		}
		attr = node.attribute("Times");
		if (attr) {
			times = attr.as_int();
			if (times < 1) {
			        error("Minimal number for Times attribute is 1\n");
                                return -1;
                        }
		} else {
		        times = 1;
		}
		score = 0;
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
		int ret=0;
                if (solver->mpi_rank == 0) {
                        int any = 0;
                        output("Stop criterium:");
                        for (size_t i=0;i<what.size();i++) {
                                double v = solver->lattice->globals[ what[i] ];
                                if (fabs(old[i] - v) > change[i]) any++;
                                if (D_MPI_RANK == 0) {
                                        output("                 %4lg / %4lg", fabs(old[i] - v), change[i]);
                                }
                                old[i] = v;
                        }
                        if (!any) {
                                score++;
                        } else {
                                score = 0;
                        }
                        if (D_MPI_RANK == 0) {
                                output("Score: %d\n", score);
                        }
                        if (score >= times) {
                                if (D_MPI_RANK == 0) notice("Stop.\n");
                                ret = ITERATION_STOP;
                                for (size_t i=0;i<what.size();i++) {
                                        old[i] = -12341234;
                                }
                                score=0;
                        }
                }
                MPI_Bcast(&ret, 1, MPI_INT, 0, MPI_COMM_WORLD);
		return ret;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		return Callback::Finish();
	}
};
class cbAveraging: public Callback{
        public:
        int Init() {
		Callback::Init();
		solver->lattice->resetAverage();
                return 0;
        }
        int DoIt() {
                Callback::DoIt();
                solver->lattice->resetAverage(); // reseting averages-storing densities and setting reset_iter to iter
                return 0;
        }
        int Finish() {
                return Callback::Finish();
        }
};

class cbFailcheck: public Callback {
	lbRegion reg;
	int rkept;
	public:
	int Init() {
		Callback::Init();
		reg.dx = solver->region.dx;
		reg.dy = solver->region.dy;
		reg.dz = solver->region.dz;
		rkept = 1;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
        	int ret = 0;
		int cond,fin;
		fin = false;
		cond = false;
		<?R for (q in rows(Quantities)) { ifdef(q$adjoint); ?>
		if (!cond) {
			<?%s q$type ?> tmp;
			solver->lattice->Get<?%s q$name ?>(reg,&tmp);
			<?R if (q$vector) { ?>
	                cond = ((std::isnan(tmp.x)) || (std::isnan(tmp.y)) || (std::isnan(tmp.z)));  
			<?R } else { ?>  
			cond = (std::isnan(tmp));
			<?R } ?>
		}
		<?R }; ifdef(); ?>
		MPI_Allreduce(&cond,&fin,1,MPI_INT,MPI_LOR,MPI_COMM_WORLD);
	        if ((fin) && (rkept)) {
                         rkept = 0;
			 notice("NaN value discovered. Executing final actions from the Failcheck element before full stop...\n");
                         for (pugi::xml_node par = node.first_child(); par; par = par.next_sibling()) {
                         	Handler hand(par, solver);
                                if (hand) hand.DoIt();
                         }
                         notice("Stopping due to Nan value\n");
                         ret = ITERATION_STOP;
                }
		return ret;
	}	
	int Finish() {
		return Callback::Finish();
	}
};	
class cbSample: public Callback{
	name_set s;
        std::string filename; 
	public:
	int Init(){
		std::string nm="Sampler";
		char fn[STRING_LEN];
		Callback::Init();
		pugi::xml_attribute attr=node.attribute("what");
		if (attr) {
			s.add_from_string(attr.value(),',');
		}
		else {
			s.add_from_string("all",',');
		}
		for (pugi::xml_node par = node.first_child(); par; par = par.next_sibling()) {
			if (strcmp(par.name(),"Point") == 0) {
				lbRegion loc;
				attr = par.attribute("dx");
				if (attr) {
					loc.dx = solver->units.alt(attr.value());
				}
				attr = par.attribute("dy");
				if (attr) {
					loc.dy = solver->units.alt(attr.value());
				}
				attr = par.attribute("dz");
				if (attr) {
					loc.dz = solver->units.alt(attr.value());
				}
				loc = solver->region.intersect(loc);
				if (loc.nx == 1)  solver->lattice->sample->addPoint(loc,solver->mpi.rank);
			} else {
				error("Uknown element in Sampler\n");
				return -1;
			}
		} 
		solver->outIterFile(nm.c_str(),".csv",fn);
		filename = fn;
		solver->lattice->sample->units = solver->units;
		solver->lattice->sample->mpis = solver->mpi;		
		solver->lattice->sample->Allocate(&s,startIter,everyIter); 
		solver->lattice->sample->initCSV(filename.c_str());
		return 0;
		}
	int DoIt() {
		Callback::DoIt();
		solver->lattice->sample->writeHistory(solver->iter);
		solver->lattice->sample->startIter = solver->iter;
		return 0;
		}
	int Finish(){
	   solver->lattice->sample->Finish();
	   return Callback::Finish();
	 }	 
};

class cbKeep: public Callback {
	int old_iter_type;
	int my_type;
	int what, whatInObj;
	double thr,force;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("What");
		if (attr) {
			what = GlobalByName(attr.value());
			if (what < 0) {
        			error("Unknown Global %s in %s\n", attr.value(), node.name());
        			return -1;
                        }
			whatInObj = GlobalInObj(what);
		} else {
			error("No What attribute in %s\n", node.name());
			return -1;
		}
		if ( (attr = node.attribute("Above")) ) {
			thr = attr.as_double();
                        my_type = 1;
		} else if ( (attr = node.attribute("Below")) ) {
			thr = attr.as_double();
                        my_type = -1;
		} else if ( (attr = node.attribute("Equal")) ) {
			thr = attr.as_double();
                        my_type = 0;
		} else {
			error("%s should have Above, Below or Equal attribute\n", node.name());
			return -1;		        
		}
		if ( (attr = node.attribute("Force")) ) {
			force = attr.as_double();
		} else {
		        force = 1;
                }
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
                double s = 0.0;
                if (solver->mpi_rank == 0) {
                        double v = solver->lattice->globals[ what ];
                        output("Keep: %le compared to %le\n", v, thr);
                        v = (thr - v)*force;
                        switch (my_type) {
                        case -1:
                                if (v<0) s=v;
                                break;
                        case 0:
                                s=v;
                                break;
                        case 1:
                                if (v>0) s=v;
                                break;
                        }
                }
                MPI_Bcast(&s, 1, MPI_INT, 0, MPI_COMM_WORLD);
                solver->lattice->setSetting(whatInObj, s);		
		return 0;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		return Callback::Finish();
	}
};

class GenericAction: public Action {
	int stack;
	public:
	int Init() {
		stack=0;
		parSize= -1;
		return Action::Init();
	}
	int ExecuteInternal() {
		stack=0;
                for (pugi::xml_node par = node.first_child(); par; par = par.next_sibling()) {
			Handler hand(par, solver);
			if (hand) {
				if (hand.Type() & HANDLER_DESIGN) {
					output("Adding %s to the solver hands\n",(*hand).node.name());
					solver->hands.push_back(hand);
					stack++;
				} else if (hand.Type() & HANDLER_CALLBACK) {
					if ((hand.hand->everyIter != 0) || (hand.Type() & HANDLER_DESIGN)) {
						debug1("adding %lf\n", hand.hand->everyIter);
						output("Adding %s to the solver hands\n",(*hand).node.name());
						solver->hands.push_back(hand);
						stack++;
					} else {
						hand.DoIt();
					}
				}
			} else return -1;
                }
		return 0;
	}
	int Unstack() {
		while(stack--) {
			solver->hands.pop_back();
		}
		return 0;
	}
	int Finish() {
		if (stack > 0) {
			WARNING("Generic action still stacked at finish\n");
			Unstack();
		}
		return 0;
	}
	int parSize;
	int NumberOfParameters() {
		output("Collecting parameters from Design elements\n");
		if (parSize < 0) {
			parSize = 0;
			for (size_t i=0; i<solver->hands.size(); i++) if (solver->hands[i].Type()  == HANDLER_DESIGN) {
				output("Getting number of parameters from %s\n", solver->hands[i]->node.name());
				int k = solver->hands[i]->NumberOfParameters();
				parSize += k;
			}
		} else {
			output("Done some time ago\n");
		}
		return parSize;
	};
	int Parameters(int type, double * tab) {
		int offset = 0, size = 0, ret=0;
		for (size_t i=0; i<solver->hands.size(); i++) if (solver->hands[i].Type()  == HANDLER_DESIGN) {
			output("Parameters from %s (%d)\n", solver->hands[i]->node.name(), type);
			size = solver->hands[i]->NumberOfParameters();
			if (offset + size > parSize) { offset = offset + size; break; }
			ret = solver->hands[i]->Parameters(type, tab+offset);
			if (ret) return ret;
			offset += size;
		}
		if (offset != parSize) {
				ERROR("Numer of parameters is inconsistent with first call to NumberOfParameters (in Parameters(%d)!", type);
				exit(-1);
				return -1;
		}
		return 0;
	};

};

class GenericContainer: public GenericAction {
	public:
	int Init() {
		GenericAction::Init();
		return GenericAction::ExecuteInternal();
	}
	int Finish() {
		GenericAction::Unstack();
		return GenericAction::Finish();
	}
};

class MainContainer: public GenericAction {
	public:
	int Init() {
		GenericAction::Init();
		char filename[STRING_LEN];
		solver->outIterFile("config", ".xml", filename);
		pugi::xml_node n = solver->configfile.append_child("Run");
		n.append_attribute("model").set_value(MODEL);
		pugi::xml_node c = n.append_child("Code");
		c.append_attribute("version").set_value(VERSION);
		#ifdef CALC_DOUBLE_PRECISION
			c.append_attribute("precision").set_value("double");
		#else
			c.append_attribute("precision").set_value("float");
		#endif
		#ifdef CROSS_CPU
			c.append_attribute("cross").set_value("CPU");
		#else
			c.append_attribute("cross").set_value("GPU");
		#endif
		solver->configfile.save_file(filename);
		return GenericAction::ExecuteInternal();
	}
	int Finish() {
		GenericAction::Unstack();
		return GenericAction::Finish();
	}
};


class acSolve: public GenericAction {
	public:
	int Init() {
		GenericAction::Init();
		if (GenericAction::ExecuteInternal()) return -1;
		int stop=0;
		do {
			int next_it = Next(solver->iter);
			for (size_t i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (size_t i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					int ret = solver->hands[i].DoIt();
					switch (ret) {
					case ITERATION_STOP:
						stop=1;
					case 0:
						break;
					default:
						return -1;
					}
				}
			}
			if (stop) break;
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		return 0;
	}
};

class acOptSolve: public GenericAction {
	public:
	int Init() {
		int old_iter_type = solver->iter_type;
		GenericAction::Init();
		if (GenericAction::ExecuteInternal()) return -1;
        	solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_OPT;
		int stop=0;
		do {
			int next_it = Next(solver->iter);
			for (size_t i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (size_t i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					int ret = solver->hands[i].DoIt();
					switch (ret) {
					case ITERATION_STOP:
						stop=1;
					case 0:
						break;
					default:
						return -1;
					}
				}
			}
			if (stop) break;
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		solver->iter_type = old_iter_type;
		GenericAction::Unstack();
		return 0;
	}
};

class acUSAdjoint: public GenericAction {
	int old_iter_type;
	public:
	int Init() {
		GenericAction::Init();
		old_iter_type = solver->iter_type;
		solver->iter_type = ITER_NORM | ITER_GLOBS;
		solver->lattice->startRecord();
		GenericAction::ExecuteInternal();
		everyIter = solver->iter - startIter;
		if (everyIter <= 0) {
			ERROR("No iterations done inside of Usteady Adjoint! Nothing to do\n");
			return -1;
		}
		solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_ADJOINT;
		do {
			int next_it = Prev(solver->iter);
			for (size_t i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Prev(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter -= solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (size_t i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					solver->hands[i].DoIt();
				}
			}
		} while (!Now(solver->iter));
		solver->lattice->stopRecord();
		solver->iter += everyIter*2;
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		solver->iter_type = old_iter_type;
		return 0;
	}
};

class acSAdjoint: public GenericAction {
	int old_iter_type;
	public:
	int Init() {
		GenericAction::Init();
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		GenericAction::ExecuteInternal();
		everyIter = std::max(everyIter,  (double) (solver->iter - startIter));
		if (everyIter <= 0) {
			WARNING("Warning: Zero iterations in steady adjoint. somethings is probaby wrong\n");
			return 0;
		}
		solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_ADJOINT;
		do {
			int next_it = Next(solver->iter);
			for (size_t i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
       			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (size_t i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					solver->hands[i].DoIt();
				}
			}
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		solver->iter_type = old_iter_type;
		return 0;
	}
};

#ifdef WITH_NLOPT
double FOptimize(unsigned int n, const double * x, double * grad, void * data);
double FMaterialMore(unsigned int n, const double * x, double * grad, void * data);
double FMaterialLess(unsigned int n, const double * x, double * grad, void * data);

class acOptimize: public GenericAction {
	int par;
	nlopt_opt opt;
	double material;
	std::string method;
	public:
	int Init() {
		double val;
		double * start = NULL;
		nlopt_result res;
		material=0.0;
		GenericAction::Init();
		DEBUG_M;
//		par = solver->getPars();
		par = NumberOfParameters();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			ERROR("Error: No parameters defined!\n");
        			return -1;
        		}			
			notice("Parameters in optimization: %d\n", par);
			start = new double[par];
		}
		DEBUG_M;
//		solver->getPar(start);
		GetParameters(start);
		DEBUG_M;
		int msg=0;
		if (solver->mpi_rank == 0) {
		DEBUG_M;
		        method="MMA";
        		pugi::xml_attribute attr = node.attribute("Method");
        		if (attr) {
        		        method = attr.value();
                        }
			<?R 
				methods = data.frame(
					name=c("LBFGS","MMA","COBYLA","NELDERMEAD"),
					type=c("LD","LD","LN","LN")
				)
				for (method in rows(methods)) {
			?> if (method == "<?%s method$name ?>") {
        			opt = nlopt_create(NLOPT_<?%s method$type ?>_<?%s method$name ?>,par);
                        } else <?R } ?> {
       			        error("Unknown Method in Optimize: %s\n", method.c_str());
       			        exit(-1);
                        }
			{
				double * bound = new double[par];
				Parameters(PAR_LOWER, bound);
				output("lower set to %lf\n", bound[0]);
				nlopt_set_lower_bounds(opt, bound);
				for (int i=0;i<par;i++) if (start[i] < bound[i]) start[i] = bound[i];
				Parameters(PAR_UPPER, bound);
				output("upper set to %lf\n", bound[0]);
				nlopt_set_upper_bounds(opt, bound);
				for (int i=0;i<par;i++) if (start[i] > bound[i]) start[i] = bound[i];
				delete[] bound;
			}
                        res = nlopt_set_max_objective(opt, FOptimize, this);
                        if (res < 0) {
       			        ERROR("Error while appling objective in Optimize: nlopt_set_max_objective = %d\n", res);
       			        exit(-1);
                        }
        		attr = node.attribute("Material");
        		if (attr) {
        		        std::string matdir(attr.value());
        		        for (int i=0;i<par; i++) material += start[i];
        		        if (matdir == "more") {
        			        res = nlopt_add_inequality_constraint(opt, FMaterialMore, this, 1e-3);
        		        } else if (matdir == "less") {
        			        res = nlopt_add_inequality_constraint(opt, FMaterialLess, this, 1e-3);
        		        } else {
        			        error("Material attribute in Optimize should be \"more\" or \"less\"\n");
        			        exit(-1);
                                }
                                if (res < 0) {
        			        error("Error while appling Material constraint in Optimize: nlopt_add_inequality_constraint = %d\n", res);
        			        exit(-1);
                                }
                        }
<?R
        tab=data.frame(
                attr=c("XAbsTolerance","RelTolerance","AbsTolerance","StopAtValue","MaxEvaluations"),
                nlopt=c("xtol_abs1","ftol_rel","ftol_abs","stopval","maxeval"),
                positive=c(T,T,T,F,T),
                type=c(rep("double",4),"int")
        )
        for (crit in rows(tab)) { ?>
        		attr = node.attribute("<?%s crit$attr ?>");
        		if (attr) {
                                <?%s crit$type ?> crit = attr.as_<?%s crit$type ?>(); <?R
                if (crit$positive) { ?>
                                if (crit > 0) { <?R
                } ?>
                                        output("NLOPT: Setting <?%s crit$attr ?> to %d\n", crit);
                                        nlopt_set_<?%s crit$nlopt ?>(opt, crit); <?R
                if (crit$positive) { ?>
                                } else {
        			        error("<?%s crit$attr ?> in Optimize have to be above 0\n");
        			        exit(-1);
                                } <?R
                } ?>
                        } <?R
        }
?>
		DEBUG_M;
			nlopt_result res = nlopt_optimize(opt, start, &val);
                        msg = -1;
		DEBUG_M;
                        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
			notice("NLOpt result: %d\n", res);
			switch(res) {
                                case NLOPT_SUCCESS: notice("Optimization generic success!\n"); break;
                                case NLOPT_STOPVAL_REACHED: notice("Optimization reached desired value (StopAtValue) !\n"); break;
                                case NLOPT_FTOL_REACHED: notice("Optimization stoped with change of objective below tolerance (RelTolerance/AbsTolerance) !\n"); break;
                                case NLOPT_XTOL_REACHED: notice("Optimization stoped with change of parameters below tolerance (XAbsTolerance) !\n"); break;
                                case NLOPT_MAXEVAL_REACHED: notice("Optimization stoped, because maximal number of iterations was made (MaxIterations) !\n"); break;
                                case NLOPT_FAILURE: notice("Optimization failed, I don't know why!\n"); break;
                                case NLOPT_INVALID_ARGS: notice("Optimization call failed. Some wrong arguments!\n"); break;
                                case NLOPT_OUT_OF_MEMORY: notice("Optimization call failed. Out of memory!\n"); break;
                                case NLOPT_ROUNDOFF_LIMITED: notice("Optimization failed. Changes were below numeric tolerance (good?)\n"); break;
                                case NLOPT_FORCED_STOP: notice("Optimization failed. It was stoped from within the objective function (why?)\n"); break;
                                default: notice("NLOpt result: %d\n", res); break;
                        }
			notice("Final Objective value: %lf\n",val);
			nlopt_destroy(opt);
		} else {
		DEBUG_M;
		        double f;
		        while (msg == 0) {
		DEBUG_M;
        		        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
        		        if (msg != 0) break;
        		        Execute(NULL,NULL,&f);
                        }
                        
		}
		MPI_Barrier(MPI_COMM_WORLD);
		return 0;
	}
	int Execute(const double * x, double * grad, double * f) {
		DEBUG_M;
		solver->opt_iter++;
//		solver->setPar(x);
		SetParameters(x);
		if (GenericAction::ExecuteInternal()) return -1;
		everyIter = solver->iter - startIter;
//		solver->getDPar(grad);
		GetGradient(grad);
		*f = solver->lattice->getObjective();
		output("Evaluated objective: %lg\n", *f);
		return 0;
	}
	friend double FOptimize(unsigned int n, const double * x, double * grad, void * data);
	friend double FMaterialMore(unsigned int n, const double * x, double * grad, void * data);
	friend double FMaterialLess(unsigned int n, const double * x, double * grad, void * data);
};

double FOptimize(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	assert(n == (unsigned int)obj->par);
	double val = NAN;
        int msg = 0; 
        output("------- Optimization iteration %3d -------\n", obj->solver->opt_iter+1);
        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
	int ret = obj->Execute(x, grad, &val);
	if (ret) {
		ERROR("Error while executing calculations in optimize. exiting loop.\n");
		nlopt_force_stop(obj->opt);
	}
	return val;
}
double FMaterialMore(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	double material = 0.0;
	for (size_t i=0;i<n; i++) material += x[i];
	if (grad) {
        	for (size_t i=0;i<n; i++) grad[i] = 1;
        }
        output("Material %le (%le at start)\n", material, obj->material);
	return material - obj->material;
}
double FMaterialLess(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	double material = 0.0;
	for (size_t i=0;i<n; i++) material += x[i];
	if (grad) {
        	for (size_t i=0;i<n; i++) grad[i] = -1;
        }
        output("Material %le (%le at start)\n", material, obj->material);
	return obj->material - material;
}
#endif

class acThreshold: public GenericAction {
	int par;
	int levels;
	public:
	int Init() {
		double val;
		double * start = NULL;
		double * slice = NULL;
		levels = 5;
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Levels");
		if (attr) {
			levels = attr.as_int();
		} else {
		        levels = 5;
			WARNING("Warning: Using default (%d) Levels in %s\n", levels, node.name());
		}
		                        
		DEBUG_M;
//		par = solver->getPars();
		par = NumberOfParameters();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			ERROR( "No parameters defined!\n");
        			return -1;
        		}			
			output("Parameters: %d\n", par);
			start = new double[par];
			slice = new double[par];
		}
		DEBUG_M;
//		solver->getPar(start);
		GetParameters(start);
		DEBUG_M;
		int msg=0;
		
		for (int i=0; i < levels; i++) {
		        double th = (1.0 * i)/(levels-1);
		        solver->lattice-><?%s Settings[Settings$name=="Threshold",]$FunName ?>(th);
		        if (slice != NULL) for (int j=0;j<par;j++) slice[j]=start[j]>th ? 1.0 : 0.0;
//        		solver->setPar(slice);
			SetParameters(slice);
        		if (GenericAction::ExecuteInternal()) return -1;
                }
		return 0;
	}
};

class acThresholdNow: public GenericAction {
	int par;
	double level;
	public:
	int Init() {
		double val;
		double * start = NULL;
		double * slice = NULL;
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Level");
		if (attr) {
			level = attr.as_int();
		} else {
		        level = 0.5;
		}
		DEBUG_M;
//		par = solver->getPars();
		par = NumberOfParameters();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			ERROR("No parameters defined!\n");
        			return -1;
        		}			
			output("Parameters: %d\n", par);
			start = new double[par];
			slice = new double[par];
		}
		DEBUG_M;
//		solver->getPar(start);
		GetParameters(start);
		DEBUG_M;
		int msg=0;
	        solver->lattice-><?%s Settings[Settings$name=="Threshold",]$FunName ?>(level);
	        if (slice != NULL) for (int j=0;j<par;j++) slice[j]=start[j]>level ? 1.0 : 0.0;
//       		solver->setPar(slice);
		SetParameters(slice);
		return 0;
	}
};


class acRepeat: public GenericAction {
	int times;
	public:
	int Init() {
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Times");
		if (attr) {
			times = attr.as_int();
		} else {
			error("no Times parameter in %s\n");
			return -1;
		}
		for (int i=0; i < times; i++) {
        		if (GenericAction::ExecuteInternal()) return -1;
                }
		return 0;
	}
};




class conControl: public Action {
        int iter;
        typedef std::map< std::string , std::vector<double> > Context;
        Context context;
	public:
	int Params(pugi::xml_node n) {
	        std::string par, zone;
	        int zone_number = -1;
	        for (pugi::xml_attribute attr = n.first_attribute(); attr; attr = attr.next_attribute()) {
	                debug0("Params %s = %s (only saying that it exists - see below to know if it is used\n",attr.name(),attr.value());
	                par = attr.name();
                        size_t i = par.find_first_of('-');
                        if (i == string::npos) {
                                zone = "";
                                zone_number = -1;
                        } else {
                                zone = par.substr(i+1);
                                par = par.substr(0,i);
                                if (solver->geometry->SettingZones.count(zone) > 0) { 
                                        zone_number = solver->geometry->SettingZones[zone];
                                } else {
                                        WARNING("Unknown zone %s (found while setting parameter %s)\n", zone.c_str(), par.c_str());
                                        zone_number = -2;
                                        zone = "";
                                }
                        }
                        if (zone_number > -2) {
                        debug2("%s set in zone %s (%d)\n", par.c_str(), zone.c_str(), zone_number);
		<?R for (v in rows(ZoneSettings)) { ?>
		        if (par == "<?%s v$name?>") {
				//double val = solver->units.alt(attr.value());
				std::vector<double> val;
				get( context, attr.value(), 1, val);
				solver->lattice->zSet.set(<?%s v$Index?>, zone_number, val);
			}
		<?R } ?>
		        }
                }
                return 0;
	}
	int get(Context& cont, const char * svar, double scale, std::vector<double>& fill) {
	        Context::iterator it;
	        it = cont.begin();
                if (it->second.size() != fill.size()) {
                        fill.resize(it->second.size());
                }
                for (size_t i=0; i < it->second.size(); i++) {
                        fill[i] = 0;
                }
                
	        std::istringstream s(svar);
                std::string var;
                int sum_i = 0;
                while (std::getline(s, var, '+'))
                {
                        std::istringstream ss(var);
                        std::string token;
                        std::getline(ss, token, '*');
                        Context::iterator it = cont.find(token);
                        double nscale;
                        bool ret = 0;
                        if (it == cont.end()) {
                                if (sum_i == 0) {
                                        error("Variable %s not found in context in Control in xml config\n", token.c_str());
                                        error("Syntax of time-dependent settings is: [Variable]*[scale with unit]");
                                        return -1;
                                }
                                ret = 1;
                        } else {
                                ret = std::getline(ss, token, '*');
                        }
                        if (ret) {
                                nscale = solver->units.alt(token);
                                if (std::getline(ss, token, '*')) {
                                        error("Too many \"*\" in Control in xml config\n");
                                        error("Syntax of time-dependent settings is: [Variable]*[scale with unit]");
                                        return -1;
                                }
                        } else {
                                nscale = 1;
                        }    
                        if (it == cont.end()) {
                                output("Setting 1 with a scale of %lf (*%lf)\n", nscale, scale);
                                for (size_t i=0; i < fill.size(); i++) {
                                        fill[i] += nscale * scale;
                                }
                        } else {
                                output("Getting %s from context with a scale of %lf (*%lf)\n", it->first.c_str(), nscale, scale);
                                for (size_t i=0; i < fill.size(); i++) {
                                        fill[i] += it->second[i] * nscale * scale;
                                }
                        }
                        sum_i++;
                }
                return 0;
	}
	int Internal(pugi::xml_node n){
	        const char * nm;
	        {
                        pugi::xml_attribute attr = n.attribute("file");
                        if (! attr) {
                                error("No file attribute in CSV in xml config\n");
                                return -1;
                        }
                        nm = attr.value();
                }
                {
                        std::vector< std::string > names;
                        Context csv_data;
                        std::string val;
                        std::string line;
                        std::ifstream myfile(nm);
                        if (! myfile.is_open()) {
                                error("Could not open file CSV %s\n", nm);
                                return -1;
                        }
                        if (! std::getline(myfile, line)) {
                                error("Empty file CSV %s\n", nm);
                                return -1;
                        }
                        {
                                std::istringstream ss(line);
                                std::string token;
                                while(std::getline(ss, token, ',')) {
                                        if (token[0] == '"') {
                                                if (token[token.size()-1] != '"') {
                                                        error("Column name in header started with \", but didn't end: %s\n", token.c_str());
                                                        return -1;
                                                }
                                                token = token.substr(1,token.size()-2);
                                        }
                                        names.push_back(token);
                                }                
                        }
                        {
                                int j=0;
                                while (std::getline(myfile, line)) {
                                        std::istringstream ss(line);
                                        std::string token;
                                        size_t i = 0;
                                        while(std::getline(ss, token, ',')) {
                                                if (i >= names.size()) {
                                                        error("More data then names in header in CSV file %s\n", nm);
                                                        return -1;
                                                }
                                                csv_data[ names[i] ].push_back( solver->units.alt(token.c_str()) );
                                                i++;
                                        }           
                                        if (i != names.size()) {
                                                error("Less data then names in header in CSV file %s\n", nm);
                                                return -1;
                                        }
                                        csv_data[ "_index" ].push_back( j );
                                        j++;     
                                }
                                output("Read %d rows from %s file\n", j, nm);
                        }
                        {
                                pugi::xml_attribute attr = n.attribute("Time");
                                const char * time_str;
                                double time_scale;
                                if (! attr) {
                                        time_scale = (double)iter/csv_data["_index"].size();
                                        time_str = "_index";
                                } else {
                                        time_str = attr.value();
                                        time_scale = 1;                                
                                }
                                csv_data["_time"];
                                if (get(csv_data, time_str, time_scale, csv_data["_time"])) {
                                        return -1;
                                }
                        }
                        int k = 0;
                        int max_k = csv_data[ "_time" ].size() - 2;
                        if (max_k < 0) {
                                error("Not enaugh records in CSV file or something went terribly wrong\n");
                                return -1;
                        }
                                
                        for (int i=0;i<iter; i++) {
                                double alpha;
                                while ((i > csv_data[ "_time" ][k+1]) && (k < max_k)) k++;
                                if (i < csv_data[ "_time" ][k]) {
                                        alpha = 0;
                                } else if (i > csv_data[ "_time" ][k+1]) {
                                        alpha = 1;
                                } else {
                                        alpha = (1.0 * i - csv_data[ "_time" ][k])/(csv_data[ "_time" ][k+1]-csv_data[ "_time" ][k]);
                                }
                                for (size_t j=0; j<names.size(); j++) {
                                        double val = csv_data[ names[j] ][k]*(1-alpha) + csv_data[ names[j] ][k+1]*alpha;
                                        context[ names[j] ].push_back(val);
                                }
                        }
                        
                }
	        for (pugi::xml_node n2 = n.first_child(); n2; n2 = n2.next_sibling()) {
                        std::string name2 = n2.name();
                        if (name2 == "Params") {
                                debug0("Params in CSV\n");
                                Params(n2);
                        } else {
        		        error("Only Params allowed in %s in Control sub-element in config\n",n.name());
        		        return -1;
                        }
                }
                return 0;
        }
	int Init() {
		Action::Init();
		iter = -floor(-everyIter);
		if (iter <= 0) {
		        error("Zero (or less) iterations in Control element in config\n");
		        return -1;
                }
                output("Setting iterations for time-dependent settings at %d\n",iter);
                warning("clearing old control\n");
                solver->lattice->zSet.setLen(iter);
                for (pugi::xml_node n = node.first_child(); n; n = n.next_sibling()) {
                        std::string name = n.name();
                        if (name == "Params") {
                	        debug2("Params in Control\n");
                                if (Params(n)) return -1;
                        } else if (name == "CSV") {
                                debug2("CSV in Control\n");
                                if (Internal(n)) return -1;
                        } else {
        		        error("Element %s not allowed in Control element in config\n", name.c_str());
        		        return -1;
                        }
                }
                std::vector<double> s;
                for (int i=0;i<iter; i++) {
                        s.push_back(sin(i/500.)*0.01);
                }
//                solver->lattice->zSet.set( ZONESETTINGS_InletVelocity, 0, s );
		return 0;
	}
};

class conFieldParameter : public Action {
	public:
	int Init() {
		Action::Init();
		pugi::xml_attribute attr = node.attribute("field");
		if (!attr) {
			ERROR("No \"field\" attribute in GeometryParameter\n");
			return -1;
		}
		std::string str = attr.value();
		

		return 0;
	}
};

class conControlParameter : public Action {
	public:
	int Init() {
		Action::Init();
		pugi::xml_attribute attr = node.attribute("field");
		if (!attr) {
			ERROR("No \"field\" attribute in GeometryParameter\n");
			return -1;
		}
		std::string str = attr.value();
		

		return 0;
	}
};


class acParams: public Action {
	public:
	int Init() {
	        std::string par, zone;
	        int zone_number = -1;
		Action::Init();
	        for (pugi::xml_attribute attr = node.first_attribute(); attr; attr = attr.next_attribute()) {
	                debug0("Params %s = %s (only saying that it exists - see below to know if it is used\n",attr.name(),attr.value());
	                par = attr.name();
                        size_t i = par.find_first_of('-');
                        if (i == string::npos) {
                                zone = "";
                                zone_number = -1;
                        } else {
                                zone = par.substr(i+1);
                                par = par.substr(0,i);
                                if (solver->geometry->SettingZones.count(zone) > 0) { 
                                        zone_number = solver->geometry->SettingZones[zone];
                                } else {
                                        WARNING("Unknown zone %s (found while setting parameter %s)\n", zone.c_str(), par.c_str());
                                        zone_number = -2;
                                        zone = "";
                                }
                        }
                        if (zone_number > -2) {
		<?R for (v in rows(Settings)) { ?>
		        if (par == "<?%s v$name?>") {
				double val = solver->units.alt(attr.value());
	                        output("Setting %s to %s (%lf)\n", par.c_str(), attr.value(), val);
				solver->lattice-><?%s v$FunName ?>(val);
			}
		<?R } ?>
		<?R for (v in rows(ZoneSettings)) { ?>
		        if (par == "<?%s v$name?>") {
				double val = solver->units.alt(attr.value());
	                        output("Setting %s in zone %s (%d) to %s (%lf)\n", par.c_str(), zone.c_str(), zone_number, attr.value(), val);
				solver->lattice->zSet.set(<?%s v$Index?>, zone_number, val);
			}
		<?R } ?>
		        }
		}
		return 0;
	}
};

class acSyntheticTurbulence: public Action {
	public:
	int ReadWaveNumer(std::string name, double * var) {
		int set = 0;
		double val = *var;
		pugi::xml_attribute attr;
		attr = node.attribute((name + "WaveLength").c_str());
		if (attr) {
			set++;
			val = 1.0 / solver->units.alt(attr.value());
		}
		attr = node.attribute((name + "WaveNumber").c_str());
		if (attr) {
			set++;
			val = solver->units.alt(attr.value());
		}
		attr = node.attribute((name + "WaveFrequency").c_str());
		if (attr) {
			set++;
			val = solver->units.alt(attr.value())*8*atan(1.0);
		}
		if (set) {
			if (set > 1) {
				NOTICE("Only one of WaveLength, WaveNumber or Frequency, can be set for a Turbulence parameter \"%s\". Taking the last.\n", name.c_str());
			}
			*var = val;
			return 0;
		} else {
			return -1;
		}
	}
	int Init() {
		int nmodes;
		Action::Init();
		pugi::xml_attribute attr = node.attribute("Modes");
		if (attr) {
			nmodes = attr.as_int();
		} else {
		        nmodes = 100;
		}
		solver->lattice->ST.resize(nmodes);

		std::string spread;
		attr = node.attribute("Spread");
		if (! attr) {
			spread = "Even";
		} else {
			spread = attr.value();
		}
		if (spread == "Even") {
			solver->lattice->ST.setSpread(EvenSpread);
		} else if (spread == "Log") {
			solver->lattice->ST.setSpread(LogSpread);
		} else if (spread == "Quantile") {
			solver->lattice->ST.setSpread(QuantileSpread);
		} else {
			ERROR("Unknown spread type \"%s\" in %s\n", spread.c_str(), node.name());
			ERROR("Avaliable: Even, Log and Quantile\n");
			return -1;
		}
	
		std::string spec;
		attr = node.attribute("Spectrum");
		if (! attr) {
			spec = "Von Karman";
		} else {
			spec = attr.value();
		}
		if (spec == "Von Karman") {
			double mainWN, diffWN, maxWN, minWN;
			if (ReadWaveNumer("Main", &mainWN)) {
				ERROR("Must provide MainWaveNumber for synthetic turbulence Von Karman spectrum\n");		
				return -1;
			}
			if (ReadWaveNumer("Diffusion", &diffWN)) {
				ERROR("Must provide DiffusionWaveNumber for synthetic turbulence Von Karman spectrum\n");
				return -1;
			}
			maxWN = 8*atan(1)/4; // 2*pi on 4 elements
			ReadWaveNumer("Shortest", &maxWN);
			minWN = mainWN / 2; // Default longest wave is twice the size of the main
			ReadWaveNumer("Longest", &minWN);
			output("Setting Von Karman spectrum with main length=%lg and diffusion length=%lg. With spread of %d modes across lengths %lg - %lg\n", 1/mainWN, 1/diffWN, nmodes, 1/maxWN, 1/minWN); 
			solver->lattice->ST.setVonKarman(mainWN, diffWN, minWN, maxWN);
		} else if (spec == "One Wave") {
			double WN;
			nmodes = 1;
			solver->lattice->ST.resize(nmodes);
			if (ReadWaveNumer("", &WN)) {
				ERROR("Must provide WaveNumber for synthetic turbulence\n");
				return -1;
			}
			output("Setting one-wave spectrum with length=%lg\n", 1/WN); 
			solver->lattice->ST.setOneWave(WN);
		} else {
			ERROR("Unknown spectrum type \"%s\" in %s\n", spec.c_str(), node.name());
			return -1;
		}
		{
			double timeWN;			
			if (ReadWaveNumer("Time", &timeWN)) {
                                ERROR("Must provide TimeWaveNumber for synthetic turbulence\n");
                                return -1;
                        }
			solver->lattice->ST.setTimeScale(timeWN);
		}
		return 0;
	}
};


class acModel: public GenericContainer {
	public:
	int Init() {
		GenericContainer::Init();
		solver->iter = 0;
		solver->lattice->Init();
		return 0;
	}
};

class acInit: public Action {
	public:
	int Init() {
		Action::Init();
		solver->lattice->Init();
		return 0;
	}
};

class acLoadBinary: public Action {
	public:
	int Init() {
		Action::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				error("No file specified in LoadBinary\n");
				return -1;
			}
		}
		pugi::xml_attribute attr2= node.attribute("comp");
		if (attr2) {
			solver->loadComp(attr.value(), attr2.value());
		} else {
		solver->lattice->loadSolution(attr.value());
            error("Missing comp parameter in LoadBinary");
		}
		return 0;
	}
};

class cbSaveBinary: public Callback {
	std::string fn;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				char filename[STRING_LEN];
				solver->outIterFile("Save", "", filename);
				fn = filename;
			} else {
                fn = attr.value();
            }
		} else {
            fn = ((std::string) solver->info.outpath) + "_" + attr.value();
        }
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		pugi::xml_attribute attr = node.attribute("comp");
		if (attr) {
			solver->saveComp(fn.c_str(), attr.value());
		} else {
			solver->lattice->saveSolution(fn.c_str());
            	//error("Missing comp attribute in SaveBinary");
		}
		return 0;
	};
};
class acLoadMemoryDump: public Action {
	public:
	int Init() {
		Action::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				error("No file specified in LoadMemoryDump\n");
				return -1;
			}
		}
		pugi::xml_attribute attr2= node.attribute("comp");
		if (attr2) {
            error("Depreceted API call. Use LoadBinary with comp parameter");
        }
//			solver->loadComp(attr.value(), attr2.value());
//		} else {
		solver->lattice->loadSolution(attr.value());
//		}
		return 0;
	}
};

class cbSaveMemoryDump: public Callback {
	std::string fn;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				char filename[STRING_LEN];
				solver->outIterFile("Save", "", filename);
				fn = filename;
			} else {
                fn = attr.value();
            }
		} else {
            fn = ((std::string) solver->info.outpath) + "_" + attr.value();
        }
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		pugi::xml_attribute attr= node.attribute("comp");
		if (attr) {
            error("Depreceted API call. Use SaveBinary with comp parameter");
        }
//			solver->saveComp(fn.c_str(), attr.value());
//		} else {
//			solver->lattice->saveSolution(fn.c_str());
//		}
		return 0;
	};
};



class cbPythonCall: public Callback {
	std::string fn;
	public:
	int Init() {
		Callback::Init();
        static bool firstTime = true;
        if (firstTime){
            firstTime = false;
            #ifdef EMBEDED_PYTHON

            char const* syspythonpath = getenv( "PYTHONPATH" );

            std::string oldpath;
            
            if ( syspythonpath == NULL ) {
            //  Big problem...
            } else {
                oldpath = std::string( syspythonpath );
            }            
            
            oldpath.resize (oldpath.size()+1,':');
            oldpath.resize (oldpath.size()+1,'.');

            setenv("PYTHONPATH",oldpath.c_str(),1);
            debug1("PYTHONPATH set to %s", oldpath.c_str() );

            Py_Initialize();
            _import_array();
            #endif
        }
		return 0;
	}
	public:
	int DoIt() {
        
        pugi::xml_attribute module = node.attribute("module");
		pugi::xml_attribute function = node.attribute("function");			
        pugi::xml_attribute comp = node.attribute("pass_component");

		Callback::DoIt();

		if (!module || !function || !comp) {
            error("Missing params in PythonCall");
        }

        std::vector<std::string> components;
        std::vector<real_t*> buffers;


        char *str = strdup(comp.value());  // We own str's memory now.
        char *token;
        int n_components = 0;
        while ((token = strsep(&str, ","))) {
            components.push_back(std::string(token));
            n_components++;
        }

        buffers.resize(n_components);

        free(str);        

        //variable menaged by selver!!
#ifdef EMBEDED_PYTHON

     //   output("buffer size: %d", size);
////BEGIN PYTHON HANDLING

    	
        

	    PyObject *pName, *pModule, *pOffsets, *pFunc;
	    PyObject *pValue, *pArgs;

	    pName = PyString_FromString(module.value());
	    /* Error checking of pName left out */
	
	    pModule = PyImport_Import(pName);
	    Py_DECREF(pName);
	
	    if (pModule != NULL) {
	        pFunc = PyObject_GetAttrString( pModule, function.value() );
	        /* pFunc is a new reference */
	
	        if (pFunc && PyCallable_Check(pFunc)) {
               
                
                pArgs = PyTuple_New(n_components+1);
                
                long int offsets[3] = {-1,-1,-1};

                for (int i =0; i<n_components; i++){
                    const char * component = components[i].c_str();
    
                    PyObject* pInputData;
                    real_t * buffer;
                    long int dims[3];

                    long int size = solver->getComponentIntoBuffer(component, buffer, dims, offsets );
    
                    if (sizeof(real_t) == sizeof(float) ) {
                        pInputData = PyArray_SimpleNewFromData(3, dims, NPY_FLOAT, buffer);
                    } else if (sizeof(real_t) == sizeof(double) ){
                        pInputData = PyArray_SimpleNewFromData(3, dims, NPY_DOUBLE, buffer);
                    }
                
                    buffers[i] = buffer;

                    //pInputData reference is stolen here
                    PyTuple_SetItem(pArgs, i+1, pInputData);
                }
                
                pOffsets = PyTuple_New(3);    
                for (int k=0; k < 3; k++){
                    PyTuple_SetItem(pOffsets, k, PyInt_FromLong(offsets[k]));
                }
    
                PyTuple_SetItem(pArgs, 0, pOffsets);
 
		        pValue = PyObject_CallObject(pFunc, pArgs);
                Py_DECREF(pArgs);
	            if (pValue != NULL) {
	                output("Result of Python call: %ld\n", PyInt_AsLong(pValue));
	                Py_DECREF(pValue);
	            }
	            else {
	                Py_DECREF(pFunc);
	                Py_DECREF(pModule);
	                PyErr_Print();
	                error("PythonCall failed\n");
	                return 1;
	            }
                
	        }
	        else {
	            if (PyErr_Occurred())
	                PyErr_Print();
	                error("PythonCall: Cannot find function \"%s\"\n", function.value());
	        }
	        Py_XDECREF(pFunc);
	        Py_DECREF(pModule);
	    }
	    else {
	        PyErr_Print();
	        error("PythonCall: Failed to load \"%s\"\n", module.value());
	        return 1;
	    }
       
        for (int i =0; i<n_components; i++){
            const char * component = components[i].c_str();
            for (int k =0; k < 10; k++){
                debug1("PythonCall after,comp %s,  buffer %d, value %d: %f\n",component,i,k, buffers[i][k]);
            }
            int status = solver->loadComponentFromBuffer(component, buffers[i]);
        }
//	    Py_Finalize();
//END PYTHON HANDLING
#else
        output("Python support disabled at compile time, nothing to do");
#endif



		return 0;
	};
};




class acGeometry: public Action {
	public:
	int Init() {
			if (solver->geometry->load(node)) {
				error("Error while loading geometry\n");
				return -1;
			}
			solver->lattice->FlagOverwrite(solver->geometry->geom,solver->geometry->region);
			solver->lattice->zSet.zone_max(solver->geometry->SettingZones.size()-1);
			return 0;
	}
};

vHandler * getHandler(pugi::xml_node node) {
	vHandler * ret = NULL;
	std::string name(node.name());
	debug1("Parsing xml element %s\n", name.c_str());
	if (name=="VTK") {
		ret = new cbVTK;
    } else if (name=="BIN") {
		ret = new cbBIN;
    } else if (name=="TXT") {
    	ret = new cbTXT;
    } else if (name=="Log") {
		ret = new cbLog;
    } else if (name=="Save") {
	//	ret = new cbSave;
        error("Depreceted API call, use SaveMemoryDump or SaveBinary");
    } else if (name=="Load") {
        error("Depreceted API call, use LoadMemoryDump or LoadBinary");
//		ret = new acLoad;
    } else if (name=="SaveMemoryDump") {
		ret = new cbSaveMemoryDump;
    } else if (name=="LoadMemoryDump") {
		ret = new acLoadMemoryDump;
    } else if (name=="SaveBinary") {
		ret = new cbSaveBinary;
    } else if (name=="LoadBinary") {
		ret = new acLoadBinary;
    } else if (name=="CallPython"){
        ret = new cbPythonCall;
    } else if (name=="Stop") {
		ret = new cbStop;
    } else if (name=="Keep") {
		ret = new cbKeep;
    } else if (name=="Failcheck") {
                ret = new cbFailcheck;
    } else if (name=="Average") {
		ret = new cbAveraging;
    } else if (name=="Sample") {
		ret = new cbSample;
    } else if (name=="Solve") {
		ret = new acSolve;
    } else if (name=="OptSolve") {
		ret = new acOptSolve;
    } else if (name=="Adjoint") {
		pugi::xml_attribute attr = node.attribute("type");
		if (attr) {
			std::string type(attr.value());
			if (type == "unsteady") {
				ret = new acUSAdjoint;
			} else if (type == "steady") {
				ret = new acSAdjoint;
			} else {
				error("Unknown type of adjoint in xml: %s", type.c_str());
			}
		} else {
			pugi::xml_attribute attr = node.attribute("Iterations");
                	if (attr) {
				ret = new acSAdjoint;
				WARNING("Makin a steady adjoint, becuase you gave me Iterations - better to state type explicitly.\n");
			} else {
				WARNING("default adjoint is unsteady - better state type explicitly next time.\n");
				ret = new acUSAdjoint;
			}
		}
    } else if (name=="Params") {
	    ret = new acParams;
    } else if (name=="Units") {
		ret = new GenericContainer;
    } else if (name=="Geometry") {
		ret = new acGeometry;
    } else if (name=="Repeat") {
		ret = new acRepeat;
    } else if (name=="Threshold") {
		ret = new acThreshold;
    } else if (name=="ThresholdNow") {
		ret = new acThresholdNow;
    } else if (name=="CLBConfig") {
		ret = new MainContainer;
    } else if (name=="Model") {
		ret = new acModel;
    } else if (name=="InternalTopology") {
		ret = new InternalTopology;
    } else if (name=="OptimalControl") {
		ret = new OptimalControl;
    } else if (name=="OptimalControlSecond") {
		ret = new OptimalControlSecond;
    } else if (name=="Fourier") {
		ret = new Fourier;
    } else if (name=="Optimize") {
#ifdef WITH_NLOPT
		ret = new acOptimize;
#else
                ERROR("No NLOpt support. configure with --with-nlopt to use Optimize element\n");
                exit(-1);
#endif
	} else if (name=="Catalyst") {
#ifdef WITH_CATALYST
		ret = new cbCatalyst;
#else
                ERROR("No Catalyst support. configure with --with-catalyst\n");
                exit(-1);
#endif
    } else if (name=="Init") {
		ret = new acInit;
    } else if (name=="Control") {
		ret = new conControl;
    } else if (name=="FieldParameter") {
		ret = new conFieldParameter;
    } else if (name=="ControlParameter") {
		ret = new conControlParameter;
	} else if (name=="SyntheticTurbulence") {
		ret = new acSyntheticTurbulence;
    } else {
		ERROR("Unknown element '%s'\n", node.name());
		return NULL;
	}
    // end else-if
    // SERIOUSLY!!!!
    // CONSIDER switch-case maybe:)
    // some observator pattern may be in hand

	if (ret != NULL) ret->node = node;
	return ret;
}


