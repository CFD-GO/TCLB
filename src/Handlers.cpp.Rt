<?R
        source("conf.R")
	c_header();
?>

#include "Consts.h"
#include "pugixml.hpp"
#include "Global.h"
#include <mpi.h>
#include "cross.h"
#include "Region.h"
#include "LatticeContainer.h"
#include "Lattice.h"
#include "vtkLattice.h"
#include "Geometry.h"
#include "def.h"
#include "utils.h"
#include "unit.h"

#include <fstream>
#include <iostream>
#include <vector>
#include <iomanip>
#include <assert.h>

#include "Solver.h"

#ifdef WITH_NLOPT
        #include  <nlopt.h>
#endif

#define ITERATION_STOP 1

int vHandler::DoIt() {
	printf("It is wrong (do it)!\n");
	exit(-1);
	return -1;
};

int vHandler::Init() {
	printf("It is wrong (init)!\n");
	exit(-1);
	return -1;
};

int vHandler::Finish() {
	printf("It is wrong (finish)!\n");
	exit(-1);
	return -1;
};

int vHandler::Type() {
	return 0;
};

class Callback : public vHandler {
public:
	int DoIt() {
	}
	int Init() {
		pugi::xml_attribute attr = node.attribute("Iterations");
		startIter = solver->iter;
		if (attr) {
			double it = solver->units.alt(attr.value());
			everyIter = it;
			if (D_MPI_RANK == 0) {
				std::cout << "[ ] Setting callback " << node.name() << " at " << it << " iterations\n";
			}
		} else {
			everyIter = 0;
//			std::cerr << "No Iterations attribute in " << node.name() << "\n";
//			return -1;
		}
		return 0;
	}
	int Finish() {
		return 0;
	}
	int Type() { return HANDLER_CALLBACK; }
};

class Action : public vHandler {
public:
	int DoIt() {
	}
	int Init() {
		pugi::xml_attribute attr = node.attribute("Iterations");
		if (attr) {
			double it = solver->units.alt(attr.value());
			startIter = solver->iter;
			everyIter = it;
			if (D_MPI_RANK == 0) {
				std::cout << "[ ] Setting action " << node.name() << " at " << it << " iterations\n";
			}
		} else {
			startIter = solver->iter;
			everyIter = 0;
		}
		if (node.attribute("output")) {
			solver->setOutput(node.attribute("output").value());
		}
		return 0;
	}
	int Finish() {
		return 0;
	}
	int Type() { return HANDLER_ACTION; }
};

class cbVTK: public Callback {
	std::string nm;
	name_set s;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		nm = "VTK";
		if (attr) nm = attr.value();
		attr = node.attribute("what");
		if (attr) {
		        s.add_from_string(attr.value(),',');
                } else {
                        s.add_from_string("all",',');
                }
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		return solver->writeVTK(nm.c_str(), &s);
	};
};

class cbBIN: public Callback {
	std::string nm;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		nm = "BIN";
		if (attr) nm = attr.value();
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		return solver->writeBIN(nm.c_str());
	};
};

class cbLog: public Callback {
	std::string filename;
	int old_iter_type;
	public:
	int Init() {
		char fn[STRING_LEN];
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("name");
		std::string nm = "Log";
		if (attr) nm = attr.value();
		solver->outIterFile(nm.c_str(), ".csv", fn);
		filename = fn;
		solver->initLog(filename.c_str());
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
		solver->writeLog(filename.c_str());
		return 0;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		Callback::Finish();
	}
};

class cbStop: public Callback {
	double stop;
	double old_obj;
	int times, score;
	int old_iter_type;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("ObjectiveChange");
		if (attr) {
			stop = attr.as_double();
		} else {
			std::cerr << "No ObjectiveChange attribute in " << node.name() << "\n";
			return -1;
		}
		attr = node.attribute("Times");
		if (attr) {
			times = attr.as_int();
			if (times < 1) {
			        std::cerr << "Minimal number for Times attribute is 1\n";
                                return -1;
                        }
		} else {
		        times = 1;
		}
		score = 0;
		old_obj = 1e20;
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
		int ret=0;
                if (solver->mpi_rank == 0) {
                        double v = solver->lattice->globals[ GLOBALS_Objective ];
                        if (fabs(old_obj - v) < stop) {
                                score++;
                        } else {
                                score=0;
                        }
                        if (D_MPI_RANK == 0) {
                                printf("[ ] Stop criterium: %4lg / %4lg (score: %d)\n", fabs(old_obj - v), stop, score);
                        }
                        if (score >= times) {
                                if (D_MPI_RANK == 0) {
                                        printf("[ ] Stop.\n");
                                }
                                ret = ITERATION_STOP;
                        }
                        old_obj = v;
                }
                MPI_Bcast(&ret, 1, MPI_INT, 0, MPI_COMM_WORLD);
		return ret;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		Callback::Finish();
	}
};

class cbKeep: public Callback {
	int old_iter_type;
	int my_type;
	int what, whatInObj;
	double thr,force;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("What");
		if (attr) {
			what = GlobalByName(attr.value());
			if (what < 0) {
        			std::cerr << "Unknown Global " << attr.value() << " in " << node.name() << "\n";
        			return -1;
                        }
			whatInObj = GlobalInObj(what);
		} else {
			std::cerr << "No What attribute in " << node.name() << "\n";
			return -1;
		}
		if (attr = node.attribute("Above")) {
			thr = attr.as_double();
                        my_type = 1;
		} else if (attr = node.attribute("Below")) {
			thr = attr.as_double();
                        my_type = -1;
		} else if (attr = node.attribute("Equal")) {
			thr = attr.as_double();
                        my_type = 0;
		} else {
			std::cerr << "" << node.name() << "should have Above, Below or Equal attribute\n";
			return -1;		        
		}
		if (attr = node.attribute("Force")) {
			force = attr.as_double();
		} else {
		        force = 1;
                }
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		return 0;
	}
	int DoIt() {
		Callback::DoIt();
                double s = 0.0;
                if (solver->mpi_rank == 0) {
                        double v = solver->lattice->globals[ what ];
                        printf("[ ] Keep: %le compared to %le\n", v, thr);
                        v = (thr - v)*force;
                        switch (my_type) {
                        case -1:
                                if (v<0) s=v;
                                break;
                        case 0:
                                s=v;
                                break;
                        case 1:
                                if (v>0) s=v;
                                break;
                        }
                }
                MPI_Bcast(&s, 1, MPI_INT, 0, MPI_COMM_WORLD);
                solver->lattice->setSetting(whatInObj, s);		
		return 0;
	}
	int Finish() {
		solver->iter_type = old_iter_type;
		Callback::Finish();
	}
};

class GenericAction: public Action {
	int stack;
	public:
	int Init() {
		stack=0;
		Action::Init();
	}
	int ExecuteInternal() {
		stack=0;
                for (pugi::xml_node par = node.first_child(); par; par = par.next_sibling()) {
			Handler hand(par, solver);
			if (hand) {
				if (hand.Type() & HANDLER_CALLBACK) {
					if (hand.hand->everyIter) {
//						printf("adding %lf\n", hand.hand->everyIter);
						solver->hands.push_back(hand);
						stack++;
					} else {
						hand.DoIt();
					}
				}
			} else return -1;
                }
		return 0;
	}
	int Unstack() {
		while(stack--) {
			solver->hands.pop_back();
		}
		return 0;
	}
	int Finish() {
		if (stack > 0) {
			std::cerr << "Warning: Generic action still stacked at finish\n";
			Unstack();
		}
	}
};

class GenericContainer: public GenericAction {
	public:
	int Init() {
		GenericAction::Init();
		return GenericAction::ExecuteInternal();
	}
	int Finish() {
		return GenericAction::Unstack();
		GenericAction::Finish();
	}
};


class acSolve: public GenericAction {
	public:
	int Init() {
		GenericAction::Init();
		if (GenericAction::ExecuteInternal()) return -1;
		int stop=0;
		do {
			int next_it = Next(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					int ret = solver->hands[i].DoIt();
					switch (ret) {
					case ITERATION_STOP:
						stop=1;
					case 0:
						break;
					default:
						return -1;
					}
				}
			}
			if (stop) break;
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		return 0;
	}
};

class acOptSolve: public GenericAction {
	public:
	int Init() {
		int old_iter_type = solver->iter_type;
		GenericAction::Init();
		if (GenericAction::ExecuteInternal()) return -1;
        	solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_OPT;
		int stop=0;
		do {
			int next_it = Next(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					int ret = solver->hands[i].DoIt();
					switch (ret) {
					case ITERATION_STOP:
						stop=1;
					case 0:
						break;
					default:
						return -1;
					}
				}
			}
			if (stop) break;
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		solver->iter_type = old_iter_type;
		GenericAction::Unstack();
		return 0;
	}
};

class acUSAdjoint: public GenericAction {
	int old_iter_type;
	public:
	int Init() {
		GenericAction::Init();
		old_iter_type = solver->iter_type;
		solver->iter_type = ITER_NORM | ITER_GLOBS;
		solver->lattice->startRecord();
		GenericAction::ExecuteInternal();
		everyIter = solver->iter - startIter;
		if (everyIter <= 0) {
			std::cerr << "No iterations done inside of Usteady Adjoint! Nothing to do\n";
			return -1;
		}
		solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_ADJOINT;
		do {
			int next_it = Prev(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Prev(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter -= solver->steps;
			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					solver->hands[i].DoIt();
				}
			}
		} while (!Now(solver->iter));
		solver->lattice->stopRecord();
		solver->iter += everyIter*2;
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		solver->iter_type = old_iter_type;
		return 0;
	}
};

class acSAdjoint: public GenericAction {
	int old_iter_type;
	public:
	int Init() {
		GenericAction::Init();
		old_iter_type = solver->iter_type;
		solver->iter_type |= ITER_LASTGLOB;
		GenericAction::ExecuteInternal();
		everyIter = std::max(everyIter,  (double) (solver->iter - startIter));
		if (everyIter <= 0) {
			std::cerr << "Warning: Zero iterations in steady adjoint. somethings is probaby wrong\n";
			return 0;
		}
		solver->iter_type = (old_iter_type & (~ITER_TYPE)) | ITER_ADJOINT;
		do {
			int next_it = Next(solver->iter);
			for (int i=0; i<solver->hands.size(); i++) {
				int it  = solver->hands[i].Next(solver->iter);
				if ((it > 0) && (it < next_it)) next_it = it;
			}
			solver->steps = next_it;
			MPI_Bcast(&solver->steps, 1, MPI_INT, 0, MPI_COMM_WORLD);
			solver->iter += solver->steps;
       			solver->lattice->Iterate(solver->steps, solver->iter_type);
			CudaThreadSynchronize();
			MPI_Barrier(MPI_COMM_WORLD);
			for (int i=0; i<solver->hands.size(); i++) {
				if (solver->hands[i].Now(solver->iter)) {
					solver->hands[i].DoIt();
				}
			}
		} while (!Now(solver->iter));
		CudaThreadSynchronize();
		MPI_Barrier(MPI_COMM_WORLD);
		GenericAction::Unstack();
		solver->iter_type = old_iter_type;
		return 0;
	}
};

#ifdef WITH_NLOPT
double FOptimize(unsigned int n, const double * x, double * grad, void * data);
double FMaterialMore(unsigned int n, const double * x, double * grad, void * data);
double FMaterialLess(unsigned int n, const double * x, double * grad, void * data);

class acOptimize: public GenericAction {
	int par;
	nlopt_opt opt;
	double material;
	std::string method;
	public:
	int Init() {
		double val;
		double * start = NULL;
		nlopt_result res;
		material=0.0;
		GenericAction::Init();
		DEBUG_M;
		par = solver->getPars();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			std::cerr << "Error: No parameters defined!\n";
        			return -1;
        		}			
			printf("[ ] Parameters: %d\n", par);
			start = new double[par];
		}
		DEBUG_M;
		solver->getPar(start);
		DEBUG_M;
		int msg=0;
		if (solver->mpi_rank == 0) {
		DEBUG_M;
		        method="MMA";
        		pugi::xml_attribute attr = node.attribute("Method");
        		if (attr) {
        		        method = attr.value();
                        }
                        if (method == "LBFGS") {
        			opt = nlopt_create(NLOPT_LD_LBFGS,par);
                        } else if (method == "MMA") {
        			opt = nlopt_create(NLOPT_LD_MMA,par);
                        } else {
       			        std::cerr << "Unknown Method in Optimize: " << method << "\n";
       			        exit(-1);
                        }
			{
				double * bound = new double[par];
				for (int i=0;i<par; i++) bound[i] = 0;
				nlopt_set_lower_bounds(opt, bound);
				for (int i=0;i<par; i++) bound[i] = 1;
				nlopt_set_upper_bounds(opt, bound);
				delete[] bound;
			}
                        res = nlopt_set_max_objective(opt, FOptimize, this);
                        if (res < 0) {
       			        std::cerr << "Error while appling objective in Optimize: nlopt_set_max_objective = " << res << "\n";
       			        exit(-1);
                        }
        		attr = node.attribute("Material");
        		if (attr) {
        		        std::string matdir(attr.value());
        		        for (int i=0;i<par; i++) material += start[i];
        		        if (matdir == "more") {
        			        res = nlopt_add_inequality_constraint(opt, FMaterialMore, this, 1e-3);
        		        } else if (matdir == "less") {
        			        res = nlopt_add_inequality_constraint(opt, FMaterialLess, this, 1e-3);
        		        } else {
        			        std::cerr << "Material attribute in Optimize should be \"more\" or \"less\"\n";
        			        exit(-1);
                                }
                                if (res < 0) {
        			        std::cerr << "Error while appling Material constraint in Optimize: nlopt_add_inequality_constraint " << res << "\n";
        			        exit(-1);
                                }
                        }
<?R
        tab=data.frame(
                attr=c("XAbsTolerance","RelTolerance","AbsTolerance","StopAtValue","MaxEvaluations"),
                nlopt=c("xtol_abs1","ftol_rel","ftol_abs","stopval","maxeval"),
                positive=c(T,T,T,F,T),
                type=c(rep("double",4),"int")
        )
        for (crit in rows(tab)) { ?>
        		attr = node.attribute("<?%s crit$attr ?>");
        		if (attr) {
                                <?%s crit$type ?> crit = attr.as_<?%s crit$type ?>(); <?R
                if (crit$positive) { ?>
                                if (crit > 0) { <?R
                } ?>
                                        std::cout << "[ ] Setting <?%s crit$attr ?> to " << crit << "\n";
                                        nlopt_set_<?%s crit$nlopt ?>(opt, crit); <?R
                if (crit$positive) { ?>
                                } else {
        			        std::cerr << "<?%s crit$attr ?> in Optimize have to be above 0\n";
        			        exit(-1);
                                } <?R
                } ?>
                        } <?R
        }
?>
		DEBUG_M;
			nlopt_result res = nlopt_optimize(opt, start, &val);
                        msg = -1;
		DEBUG_M;
                        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
			printf("[ ] NLOpt result: %d\n", res);
			switch(res) {
                                case NLOPT_SUCCESS: printf("[ ] Optimization generic success!\n"); break;
                                case NLOPT_STOPVAL_REACHED: printf("[ ] Optimization reached desired value (StopAtValue) !\n"); break;
                                case NLOPT_FTOL_REACHED: printf("[ ] Optimization stoped with change of objective below tolerance (RelTolerance/AbsTolerance) !\n"); break;
                                case NLOPT_XTOL_REACHED: printf("[ ] Optimization stoped with change of parameters below tolerance (XAbsTolerance) !\n"); break;
                                case NLOPT_MAXEVAL_REACHED: printf("[ ] Optimization stoped, because maximal number of iterations was made (MaxIterations) !\n"); break;
                                case NLOPT_FAILURE: printf("[ ] Optimization failed, I don't know why!\n"); break;
                                case NLOPT_INVALID_ARGS: printf("[ ] Optimization call failed. Some wrong arguments!\n"); break;
                                case NLOPT_OUT_OF_MEMORY: printf("[ ] Optimization call failed. Out of memory!\n"); break;
                                case NLOPT_ROUNDOFF_LIMITED: printf("[ ] Optimization failed. Changes were below numeric tolerance (good?)\n"); break;
                                case NLOPT_FORCED_STOP: printf("[ ] Optimization failed. It was stoped from within the objective function (why?)\n"); break;
                                default: printf("[ ] NLOpt result: %d\n", res); break;
                        }
			printf("[ ] Final Objective value: %lf\n",val);
			nlopt_destroy(opt);
		} else {
		DEBUG_M;
		        double f;
		        while (msg == 0) {
		DEBUG_M;
        		        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
        		        if (msg != 0) break;
        		        Execute(NULL,NULL,&f);
                        }
                        
		}
		MPI_Barrier(MPI_COMM_WORLD);
		return 0;
	}
	int Execute(const double * x, double * grad, double * f) {
		DEBUG_M;
		solver->opt_iter++;
		solver->setPar(x);
		if (GenericAction::ExecuteInternal()) return -1;
		everyIter = solver->iter - startIter;
		solver->getDPar(grad);
		*f = solver->lattice->getObjective();
		printf("[ ] Evaluated objective: %lg\n", *f);
		return 0;
	}
	friend double FOptimize(unsigned int n, const double * x, double * grad, void * data);
	friend double FMaterialMore(unsigned int n, const double * x, double * grad, void * data);
	friend double FMaterialLess(unsigned int n, const double * x, double * grad, void * data);
};

double FOptimize(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	assert(n == obj->par);
	double val;
        int msg = 0; 
        printf("[ ] ------- Optimization iteration %3d -------\n", obj->solver->opt_iter+1);
        MPI_Bcast( &msg, 1, MPI_INT, 0, MPI_COMM_WORLD );
	int ret = obj->Execute(x, grad, &val);
	if (ret) {
		std::cerr << "Error while executing calculations in optimize. exiting loop.\n";
		nlopt_force_stop(obj->opt);
	}
	return val;
}
double FMaterialMore(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	double material = 0.0;
	for (int i=0;i<n; i++) material += x[i];
	if (grad) {
        	for (int i=0;i<n; i++) grad[i] = 1;
        }
        printf("[ ] Material %le (%le at start)\n", material, obj->material);
	return material - obj->material;
}
double FMaterialLess(unsigned int n, const double * x, double * grad, void * data) {
	acOptimize * obj = (acOptimize *) data;
	double material = 0.0;
	for (int i=0;i<n; i++) material += x[i];
	if (grad) {
        	for (int i=0;i<n; i++) grad[i] = -1;
        }
        printf("[ ] Material %le (%le at start)\n", material, obj->material);
	return obj->material - material;
}
#endif

class acThreshold: public GenericAction {
	int par;
	int levels;
	public:
	int Init() {
		double val;
		double * start = NULL;
		double * slice = NULL;
		levels = 5;
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Levels");
		if (attr) {
			levels = attr.as_int();
		} else {
		        levels = 5;
			std::cout << "Warning: Using default Levels in " << node.name() << ": 5\n";
		}
		                        
		DEBUG_M;
		par = solver->getPars();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			std::cerr << "Error: No parameters defined!\n";
        			return -1;
        		}			
			printf("[ ] Parameters: %d\n", par);
			start = new double[par];
			slice = new double[par];
		}
		DEBUG_M;
		solver->getPar(start);
		DEBUG_M;
		int msg=0;
		
		for (int i=0; i < levels; i++) {
		        double th = (1.0 * i)/(levels-1);
		        solver->lattice-><?%s Settings[Settings$name=="Threshold",]$FunName ?>(th);
		        if (slice != NULL) for (int j=0;j<par;j++) slice[j]=start[j]>th ? 1.0 : 0.0;
        		solver->setPar(slice);
        		if (GenericAction::ExecuteInternal()) return -1;
                }
		return 0;
	}
};

class acThresholdNow: public GenericAction {
	int par;
	double level;
	public:
	int Init() {
		double val;
		double * start = NULL;
		double * slice = NULL;
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Level");
		if (attr) {
			level = attr.as_int();
		} else {
		        level = 0.5;
		}
		DEBUG_M;
		par = solver->getPars();
		DEBUG_M;
		if (solver->mpi_rank == 0) {
        		if (par == 0) {
        			std::cerr << "Error: No parameters defined!\n";
        			return -1;
        		}			
			printf("[ ] Parameters: %d\n", par);
			start = new double[par];
			slice = new double[par];
		}
		DEBUG_M;
		solver->getPar(start);
		DEBUG_M;
		int msg=0;
	        solver->lattice-><?%s Settings[Settings$name=="Threshold",]$FunName ?>(level);
	        if (slice != NULL) for (int j=0;j<par;j++) slice[j]=start[j]>level ? 1.0 : 0.0;
       		solver->setPar(slice);
		return 0;
	}
};


class acRepeat: public GenericAction {
	int times;
	public:
	int Init() {
		GenericAction::Init();
		pugi::xml_attribute attr = node.attribute("Times");
		if (attr) {
			times = attr.as_int();
		} else {
			std::cerr << "Error: no Times parameter in " << node.name() << "\n";
			return -1;
		}
		for (int i=0; i < times; i++) {
        		if (GenericAction::ExecuteInternal()) return -1;
                }
		return 0;
	}
};


class acParams: public Action {
	public:
	int Init() {
		Action::Init();
		pugi::xml_attribute attr;
		<?R for (v in rows(Settings)) { ?>
			attr = node.attribute("<?%s v$name?>");
			if (attr) {
				double val = solver->units.alt(attr.value());
				solver->lattice-><?%s v$FunName ?>(val);
			}
		<?R } ?>
	}
};


class acModel: public GenericContainer {
	public:
	int Init() {
		GenericContainer::Init();
		solver->iter = 0;
		solver->lattice->Init();
		return 0;
	}
};

class acInit: public Action {
	public:
	int Init() {
		Action::Init();
		solver->lattice->Init();
		return 0;
	}
};

class acLoad: public Action {
	public:
	int Init() {
		Action::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				std::cerr << "No file specified in Load\n";
				return -1;
			}
		}
		pugi::xml_attribute attr2= node.attribute("comp");
		if (attr2) {
			solver->loadComp(attr.value(), attr2.value());
		} else {
			solver->lattice->loadSolution(attr.value());
		}
		return 0;
	}
};

class cbSave: public Callback {
	std::string fn;
	public:
	int Init() {
		Callback::Init();
		pugi::xml_attribute attr = node.attribute("file");
		if (!attr) {
			attr = node.attribute("filename");
			if (!attr) {
				char filename[STRING_LEN];
				solver->outIterFile("Save", "", filename);
				fn = filename;
			} else fn = attr.value();
		} else fn = ((std::string) solver->info.outpath) + "_" + attr.value();
		return 0;
	}
	public:
	int DoIt() {
		Callback::DoIt();
		pugi::xml_attribute attr= node.attribute("comp");
		if (attr) {
			solver->saveComp(fn.c_str(), attr.value());
		} else {
			solver->lattice->saveSolution(fn.c_str());
		}
		return 0;
	};
};

class acGeometry: public Action {
	public:
	int Init() {
			if (solver->geometry->load(node)) {
				std::cerr << "Error while loading geometry\n";
				return -1;
			}
			char filename[STRING_LEN];
			solver->outIterFile("G", ".vti", filename);
			solver->geometry->writeVTI(filename);
			solver->lattice->FlagOverwrite(solver->geometry->geom,solver->geometry->region);
			return 0;
	}
};

vHandler * getHandler(pugi::xml_node node) {
	vHandler * ret;
	std::string name(node.name());
	DEBUG1(std::cout << name << "\n";)
	if (name=="VTK") {
		ret = new cbVTK;
        } else if (name=="BIN") {
		ret = new cbBIN;
        } else if (name=="Log") {
		ret = new cbLog;
        } else if (name=="Save") {
		ret = new cbSave;
        } else if (name=="Load") {
		ret = new acLoad;
        } else if (name=="Stop") {
		ret = new cbStop;
        } else if (name=="Keep") {
		ret = new cbKeep;
        } else if (name=="Solve") {
		ret = new acSolve;
        } else if (name=="OptSolve") {
		ret = new acOptSolve;
        } else if (name=="Adjoint") {
		pugi::xml_attribute attr = node.attribute("type");
		if (attr) {
			std::string type(attr.value());
			if (type == "unsteady") {
				ret = new acUSAdjoint;
			} else if (type == "steady") {
				ret = new acSAdjoint;
			} else {
				std::cerr << "Unknown type of adjoint in xml:" << type << "\n";
			}
		} else {
			pugi::xml_attribute attr = node.attribute("Iterations");
                	if (attr) {
				ret = new acSAdjoint;
				std::cerr << "Warning: Makin a steady adjoint, becuase you gave me Iterations - better to state type explicitly.\n";
			} else {
				std::cerr << "Warning: default adjoint is unsteady - better state type explicitly next time.\n";
				ret = new acUSAdjoint;
			}
		}
        } else if (name=="Params") {
		ret = new acParams;
        } else if (name=="Units") {
		ret = new GenericContainer;
        } else if (name=="Geometry") {
		ret = new acGeometry;
        } else if (name=="Repeat") {
		ret = new acRepeat;
        } else if (name=="Threshold") {
		ret = new acThreshold;
        } else if (name=="ThresholdNow") {
		ret = new acThresholdNow;
        } else if (name=="CLBConfig") {
		ret = new GenericContainer;
        } else if (name=="Model") {
		ret = new acModel;
        } else if (name=="Optimize") {
#ifdef WITH_NLOPT
		ret = new acOptimize;
#else
                std::cerr << "No NLOpt support. configure with --with-nlopt to use Optimize element\n";
                exit(-1);
#endif
        } else if (name=="Init") {
		ret = new acInit;
        } else {
		std::cerr << "Unknown element '" << node.name() << "' in xml\n";
		return NULL;
	}
	ret->node = node;
	return ret;
}
