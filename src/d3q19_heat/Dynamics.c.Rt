<?R
	source("conf.R") 
	source("boundary.R")
	c_header();

# Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	g = PV(DensityAll$name[DensityAll$group=="g"])
	rho =  PV("rho")
	u = PV(c("ux","uy"))
	T = PV("T")

# Extracting velocity set
	U = d3q19

# Calculating equlibrium density set
	source("lib/feq.R")
	feq = MRT_eq(U, rho, u*rho );
	geq = MRT_eq(U, rho*T, u*rho*T );

?>

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>;
}

CudaDeviceFunction real_t getT(){
	return (<?R C(sum(g)) ?>)/(<?R C(sum(f)) ?>);
}
    
CudaDeviceFunction vector_t getU(){
	real_t d = getRho();
	vector_t u;
<?R C(PV(c("u.x","u.y", "u.z")) == f %% U) ?>
	u.x /= d;
	u.y /= d;
	u.z /= d;
	return u;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}

CudaDeviceFunction void Collision()
{

}


CudaDeviceFunction void BounceBack()
{
	<?R FullBounceBack() ?>
}

CudaDeviceFunction void EVelocity()
{

}

CudaDeviceFunction void WPressure()
{
}

CudaDeviceFunction void eqWVelocity()
{
}


CudaDeviceFunction void WVelocity()
{

}

CudaDeviceFunction void EPressure()
{

}


CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_EVelocity:
		EVelocity();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
	case NODE_Wall:
	case NODE_Solid:
		BounceBack();
                break;
    }
    switch (NodeType & NODE_COLLISION) {
	case NODE_BGK:
		Collision();
		break;
	case NODE_MRT:
		CollisionMRT();
		break;
    }
}

CudaDeviceFunction void SetEquilibrum(real_t rho, real_t u[3], real_t T)
{
	<?R
		C(f,feq$feq);
		C(g,geq$feq);
	?>
}

CudaDeviceFunction void Init() {
	real_t u[3] = {Velocity, 0., 0.};
	real_t d = 1.0;
	SetEquilibrum( 1.0, u, Temperature );
}

<?R quit() ?>

CudaDeviceFunction void CollisionMRT()
{
	real_t J[3], rho, omT;
	real_t <?R cat(ToC(R[selR]), sep=",") ?>;

	#define S1  0.0
	#define S2  1.0//19
	#define S3  1.0//4
	#define S4  0.0
	#define S5  1.0//2
	#define S6  0.0
	#define S7  1.0//2
	#define S8  0.0
	#define S9  1.0//2
	#define S10 omega
	#define S11 1.0//4
	#define S12 omega
	#define S13 1.0//4
	#define S14 omega
	#define S15 omega
	#define S16 omega
	#define S17 1.0//98
	#define S18 1.0//98
	#define S19 1.0//98
<?R
        Sy = PV(paste("S",1:19,"",sep=""))

#C( calcRhoJ )
C( calcRfromF ,float =F);
C( calcReq[selR] , eqstring = "-=" )

# C( f == f + (R * Sy[sel]) %% (M.inv * -1)[sel,] );

C( f == (R * Sy)[selR] %% MRTMAT.inv[selR,] , eqstring = "-=");

?>

        J[0] /= rho;
        J[1] /= rho;  
        J[2] /= rho;
        rho = <?R C(sum(fT)) ?>;
	if ((NodeType & NODE_OBJECTIVE) == NODE_Obj3) {
		rho = HeaterTemperature;
	}

	omT = 1/(0.5+FluidAlpha*4);
        <?R
		omega=PV("omT");
                C(fT == omega*calcTeq - fT*(omega-1)); 
        ?>
}
