<?R
	source("conf.R");
	c_header();
?>
#include "cbRunR.h"

#ifdef WITH_R

RInside RunR::R;

//--------- R Wraps
template<> SEXP Rcpp::wrap(const PSolver &f) {
  Rcpp::XPtr< Solver > Rf(f.solver);
  Rf.attr("class") = f.myclass;
  return Rf;
}

template<> PSolver Rcpp::as(SEXP sexp) {
  Rcpp::XPtr< Solver > s = Rcpp::as< Rcpp::XPtr< Solver > >(sexp);
  return PSolver(s,s.attr("class"));
}


//--------- $.Solver
PSolver DollarSolver(PSolver P, std::string name) {
  if (name == "Settings") {  
    return PSolver(P.solver,"CLBSettings");
  } else if (name == "Parameters") {  
    return PSolver(P.solver,"CLBParameters");
  } else if (name == "Actions") {  
    return PSolver(P.solver,"CLBActions");
  } else if (name == "Geometry") {  
    return PSolver(P.solver,"CLBGeometry");
  } else {
    return PSolver(P.solver,"CLBNone");
  }
}

PSolver DollarAssignSolver(PSolver P, std::string name, PSolver C) {
  return P;
}

Rcpp::NumericVector DollarSettings(PSolver P, std::string name) {
  output("[R] Getting setting: %s\n",name.c_str());
  return 0;
}

PSolver DollarAssignSettings(PSolver P, std::string name, Rcpp::NumericVector v) {
  output("[R] Setting setting: %s to %lf\n",name.c_str(),(double)v[0]);
  <?R for (v in rows(Settings)) { ?>
          if (name == "<?%s v$name?>") {
                P.solver->lattice-><?%s v$FunName ?>(v[0]);
		return P;
          }
  <?R } ?>
  ERROR("[R] Unknown setting");
  return P;
}

Rcpp::NumericVector DollarParameters(PSolver P, std::string name) {
	output("[R] Getting parameter: %s\n",name.c_str());
	lbRegion reg = P.solver->lattice->region;
	Rcpp::NumericVector ret(reg.size());
	Rcpp::IntegerVector retdim(3);
	retdim[0] = reg.nx;
	retdim[1] = reg.ny;
	retdim[2] = reg.nz;
	ret.attr("dim") = retdim;
<?R 
    for (d in rows(DensityAll)) if (d$parameter){ 
?>
    if (name == "<?%s d$nicename ?>") {
        P.solver->lattice->Get_<?%s d$nicename ?>(&ret[0]); 
	return ret;
    }
<?R
} 
?>
	ERROR("[R] Unknown parameter");
	return Rcpp::NumericVector(0);
}

PSolver DollarAssignParameters(PSolver P, std::string name, Rcpp::NumericVector v) {
	output("[R] Setting parameter: %s (size:%ld)\n",name.c_str(),v.size());
	if (v.size() != P.solver->region.size()) {
		ERROR("Wrong size of the parameter field!");
		return P;
	}
<?R 
    for (d in rows(DensityAll)) if (d$parameter){ 
?>
    if (name == "<?%s d$nicename ?>") {
        P.solver->lattice->Set_<?%s d$nicename ?>(&v[0]); 
	return P;
    }
<?R
} 
?>
	ERROR("[R] Unknown parameter");
	return P;
}



void DollarActions(PSolver P, std::string name) {
	output("[R] Running action: %s\n",name.c_str());
	int Snap = P.solver->lattice->Snap;
	<?R for (n in names(Actions)) {
        a = Actions[[n]]
        if (n == "Iteration") {
                FunName = "Iteration"
        } else {
                FunName = paste("Action",n,sep="_")
        } ?>
	if (name == "<?%s n ?>") {
		P.solver->lattice-><?%s FunName ?>(Snap, (Snap+1) % 2, P.solver->iter_type);
		return;
	}
	<?R } ?>
	ERROR("[R] Unknown Action");
	return;
}

PSolver DollarAssignGeometry(PSolver P, std::string name, Rcpp::IntegerVector v) {
	lbRegion reg = P.solver->lattice->region;
	size_t size = reg.size();
	{
		flag_t * NodeType = new flag_t[size];
		P.solver->lattice->GetFlags(reg, NodeType);
		<?R
		i = !duplicated(NodeTypes$group)
		for (n in rows(NodeTypes[i,])) {
		?>
		if (name == "<?%s n$group ?>") {
			output("[R] Setting <?%s n$group ?>");
			for (size_t i=0;i<size;i++) {
				NodeType[i] = (NodeType[i] - (NodeType[i] & NODE_<?%s n$group ?>)) + ((v[i] - 1) << <?%d n$shift ?>);
			}
		}
		<?R } ?>
		P.solver->lattice->FlagOverwrite(NodeType, reg);
		delete[] NodeType;
	}
	return P;
}

template <typename T>
Rcpp::IntegerVector SingleInteger(T i) { Rcpp::IntegerVector v(1); v[0] = i; return v; }

Rcpp::IntegerVector DollarGeometry(PSolver P, std::string name) {
	lbRegion reg = P.solver->lattice->region;
	size_t size = reg.size();
	if (name == "dx") return SingleInteger(reg.dx);
	if (name == "dy") return SingleInteger(reg.dy);
	if (name == "dz") return SingleInteger(reg.dz);
	if (name == "size") return SingleInteger(reg.size());
	Rcpp::IntegerVector retdim(3);
	retdim[0] = reg.nx;
	retdim[1] = reg.ny;
	retdim[2] = reg.nz;
	if (name == "dim") return retdim;
	{ // Geometry components
		flag_t * NodeType = new flag_t[size];
		P.solver->lattice->GetFlags(reg, NodeType);
		Rcpp::IntegerVector small(size);
		small.attr("dim") = retdim;
		<?R
		i = !duplicated(NodeTypes$group)
		for (n in rows(NodeTypes[i,])) {
		?>
		if (name == "<?%s n$group ?>") {
			output("[R] Getting <?%s n$group ?>");
			for (size_t i=0;i<size;i++) {
				small[i] = 1 + ((NodeType[i] & NODE_<?%s n$group ?>) >> <?%d n$shift ?>);
			}
			Rcpp::CharacterVector levels;
			levels.push_back("NONE"); <?R
			for (m in rows(NodeTypes[NodeTypes$group == n$group,])) { ?>
				levels.push_back("<?%s m$name ?>"); <?R
			} ?>
			small.attr("levels") = levels;
			small.attr("class") = "factor";
			return small;
		}
		<?R } ?>
		delete[] NodeType;
	}
	ERROR("[R] Unknown component of Geometry");
	return Rcpp::IntegerVector(0);
}


Rcpp::NumericMatrix DollarQuantity(PSolver P, std::string name) {
  output("[R] Getting setting: %s\n",name.c_str());
  return 0;
}


int RunR::Init() {
    Callback::Init();
    R["Solver"] = PSolver(solver);
    R["$.CLBSolver"]       = Rcpp::InternalFunction( &DollarSolver );
    R["$<-.CLBSolver"]     = Rcpp::InternalFunction( &DollarAssignSolver );
    R["$.CLBSettings"]     = Rcpp::InternalFunction( &DollarSettings );
    R["$<-.CLBSettings"]   = Rcpp::InternalFunction( &DollarAssignSettings );
    R["$.CLBParameters"]   = Rcpp::InternalFunction( &DollarParameters );
    R["$<-.CLBParameters"] = Rcpp::InternalFunction( &DollarAssignParameters );
    R["$.CLBGeometry"]     = Rcpp::InternalFunction( &DollarGeometry );
    R["$<-.CLBGeometry"]   = Rcpp::InternalFunction( &DollarAssignGeometry );
    R["CLBActionsFun"]     = Rcpp::InternalFunction( &DollarActions );
    R.parseEval("'$.CLBActions' <- function(obj, name) { function() CLBActionsFun(obj, name); }");
    return 0;
}


int RunR::DoIt() {
	try {
		R.parseEval(node.child_value());
	} catch (...) {
		return -1;
	}
	return 0;
}


#endif // WITH_R

// Function created only to check to create Handler for specific conditions
vHandler * Ask_For_RunR(const pugi::xml_node& node) {
  std::string name = node.name();
  if (name == "RunR") {
#ifdef WITH_R
    return new RunR;
#else
    ERROR("No R support. configure with --enable-rinside\n");
    exit(-1);  
#endif
  }
  return NULL;
}

// Register this function in the Handler Factory
template class HandlerFactory::Register< Ask_For_RunR >;


