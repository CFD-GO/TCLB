<?R
	source("conf.R")
        c_header()
?>
/** \file LatticeAccess.cu
*/

#include "Consts.h"
#include "Global.h"
#include "Lattice.h"
#include "mpi.h"

/// Push only parameters
template <class N> CudaDeviceFunction void LatticeContainer::push_param(N & node) 
{
<?R #	InOut("push", "out", Density, sel=Density$parameter); ?>
}

/// Push everything exept parameters
template <class N> CudaDeviceFunction void LatticeContainer::push_noparam(N & node) 
{
<?R #	InOut("push", "out", Density, sel=(! Density$parameter)); ?>
}

/// Get only type of node
template <class N> CudaDeviceFunction void LatticeContainer::getType(N & node) 
{
  node.NodeType = NodeType[(node.x + nx*node.y + nx*ny*node.z)];
        
<?R #	InOut("type", "in", Density); ?>
}

#ifdef ADJOINT
/// Push all adjoint densities
template <class N> CudaDeviceFunction void LatticeContainer::push_adj(N & node) 
{
<?R #	InOut("push", "adjout", DensityAD); ?>
}

/// Opposite of push_adj
template <class N> CudaDeviceFunction void LatticeContainer::pull_adj(N & node) 
{
<?R #	InOut("pull", "adjout", DensityAD); ?>
}

/// Get adjoint densities
template <class N> CudaDeviceFunction void LatticeContainer::pop_adj(N & node) 
{
<?R #	InOut("pop", "adjin", DensityAD); ?>
}
#endif

/// Push all densities

<?R
  MarginPocket = ""
  MarginPocketMove = FALSE
  
  set.buf = function(buf, pocket=FALSE) {
    if (missing(buf)) stop("No Buffor provided");
    if (pocket) {
      MarginPocket <<- "pocket" ?>
      FTabs <?%s MarginPocket ?> = <?%s buf ?>; <?R
      MarginPocketMove <<- TRUE
    } else {
      MarginPocket <<- buf
      MarginPocketMove <<- FALSE
    }
    clear.pocket()
  }
  
  clear.pocket = function() {
    for ( i in 1:length(Margin) ) Margin[[i]]$POffset <<- PV(0)
  }
  
  move.pocket = function(i,offset) {
      off = Margin[[i]]$POffset
      v = ToC(offset - off,float=F);
      if (v != "   0") { ?>
        <?%s MarginPocket?>.<?%s Margin[[i]]$name ?> += <?%s v ?>; <?R
      }
      Margin[[i]]$POffset <<- offset;
  }  
  
  if.apply = function(table, conditions, selection, fun) {
    n = length(conditions)
    if (ncol(table) != n) stop("number of columns in table should be equal to the number of conditions in if.apply")
    ord = do.call(order,data.frame(table))
    ord = ord[selection[ord]]
    req = function(j,l) {
#      cat("// j:",paste(j,collapse=","),l,"\n");
      if (l > n) {
        sapply(j,fun)
      } else {
        v = table[j,l]
#        cat("// v:",paste(v,collapse=","),"\n");
        sel1 = v == 1
        sel2 = v == -1
        sel3 = v == 0
        if (any(sel1)) { ?>
                 if (<?R C(conditions[l],float=F) ?> < 0) { <?R
          req(j[sel1],l+1);
          if (any(sel2)) {?>
                 } else { <?R
            req(j[sel2],l+1);
          } ?>
                 } <?R
        } else if (any(sel2)) { ?>
                 if (<?R C(conditions[l],float=F) ?> >= 0) { <?R
          req(j[sel2],l+1); ?>
                 } <?R
        }
        if (any(sel3)) {
          req(j[sel3],l+1);
        }
      }
    }
    req(ord,1)
  }

#  No x move:
  no.x.move = FALSE
     
  load.field = function(d,f,p,dp) {
    ret = f$get_offsets(p,dp)
    if (MarginPocketMove) for (m in 1:27) if (ret$Selection[m]) {
      if (no.x.move) {
        move.pocket(m, subst(ret$Offset[m],p[1]==-dp[1]))
      } else {
        move.pocket(m, ret$Offset[m])
      }
    }
    if.apply(ret$Table,ret$Conditions,ret$Selection,function(m) {
      ?>
     <?%s d ?> = <?%s MarginPocket ?>.<?%s Margin[[m]]$name ?>[<?R C(ret$Offset[m] - Margin[[m]]$POffset,float=F) ?>]; <?R
    })
  }

  save.field = function(d,f,p) {
    ret = f$put_offsets(p)
    if (MarginPocketMove) for (m in 1:27) if (ret$Selection[m]) {
      if (no.x.move) {
        move.pocket(m, subst(ret$Offset[m],p[1]==0))
      } else {
        move.pocket(m, ret$Offset[m])
      }
    }
    if.apply(ret$Table,ret$Conditions,ret$Selection,function(m) {
      ?>
     <?%s MarginPocket ?>.<?%s Margin[[m]]$name ?>[<?R C(ret$Offset[m] - Margin[[m]]$POffset,float=F) ?>] = <?%s d ?>; <?R
    })
  }

?>

<?R for (s in c(rows(Stages),list(NULL))) {
  if (is.null(s)) {
    s$load.densities = rep(TRUE, nrow(DensityAll))
    s$save.fields = rep(TRUE, length(Fields))
    s$suffix=""
  } else {
    s$load.densities = DensityAll[,s$tag];
    s$save.fields = Fields[,s$tag];
    s$suffix = paste("_",s$name,sep="")
  } 
  ?>
template <class N> CudaDeviceFunction void LatticeContainer::pop<?%s s$suffix ?>(N & node) 
{
<?R
  set.buf("in",pocket=TRUE);
  for (d in rows(Density)[s$load.densities]) { ?>
//--------------------------- <?%s d$name ?> ----------------------<?R
    f = Fields[name == d$field][[1]]
    p = PV(c("node.x","node.y","node.z"));
    dp = c(-d$dx, -d$dy, -d$dz)
    load.field(paste("node",d$name,sep="."), f, p, dp)
  }?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pull<?%s s$suffix ?>(N & node) 
{
<?R
  set.buf("in",pocket=TRUE);
  for (d in rows(Density)[s$load.densities]) { ?>
//--------------------------- <?%s d$name ?> ----------------------<?R
    f = Fields[name == d$field][[1]]
    p = PV(c("node.x","node.y","node.z"));
    dp = c(-d$dx, -d$dy, -d$dz)
    load.field(paste("node",d$name,sep="."), f, p, dp)
  }?>
}

template <class N> CudaDeviceFunction void LatticeContainer::push<?%s s$suffix ?>(N & node) 
{
<?R
  set.buf("out",pocket=TRUE);
  for (f in Fields[s$save.fields]) { ?>
//--------------------------- <?%s f$name ?> ----------------------<?R
    p = PV(c("node.x","node.y","node.z"));
    save.field(paste("node",f$name,sep="."), f, p)
  }?>
}

<?R } ?>


<?R
  for (f in Fields) { 
    for (dx in f$minx:f$maxx) for (dy in f$miny:f$maxy) for (dz in f$minz:f$maxz) { ?>
template <> CudaDeviceFunction real_t& LatticeContainer::load_<?%s f$nicename ?> < <?%d dx ?>, <?%d dy ?>, <?%d dz ?> > (const int & x, const int & y, const int & z) 
{
  real_t ret; <?R
  set.buf("in");
  p = PV(c("x","y","z"));
  dp = c(dx, dy, dz)
  load.field("ret", f, p, dp) ?>
  return ret;
}
<?R }} ?>


