<?R
	source("conf.R") 
#	load("SUMMARY.Rdata")
	c_header();
	f = PV(Density$name)
	U = as.matrix(Density[,c("dx","dy")])

	u = PV("u[",1:2-1,"]")
	uf = PV("uf")
	d = PV("d")
	usq = PV("usq")
	omega = PV("omega")
        uf1 = uf;
        uf2 = uf;
        uf3 = uf;
	t1 = 4/9
	t2 = 1/9
	t3 = 1/36
	c_squ = 1/3
	wi = c(t1,t2,t2,t2,t2,t3,t3,t3,t3)
	tn = diag(wi)
	bounce = c(0,3,4,1,2,7,8,5,6)

	c_sq = 1/3
	
	Feq = function( d = PV("d"), u = PV("u[",1:2-1,"]") ) {
          wi*((u %*% t(U))*( 1/ c_sq) + ((u %*% t(U)) * (u %*% t(U)))*(1/(c_sq*c_sq*2)) - sum(u*u)*(1/(c_sq*2)) + 1)*d
        }
?>

#define S2 1.3333
#define S3 1.0
#define S5 1.0
#define S7 1.0
#define S8 omega
#define S9 omega


CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?> ;
}
    
CudaDeviceFunction vector_t getU(){
	real_t d = <?R C(sum(f)) ?>;
	vector_t u;
<?R C(PV(c("u.x","u.y")), f %*% U) ?>
	u.x /= d;
	u.y /= d;
	u.z = 0.0;
	return u;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}

CudaDeviceFunction void SetEquilibrum(real_t d, real_t u[2])
{
<?R
	u = PV("u[",1:2-1,"]")
	d = PV("d")
	c_sq = 1/3
        C( f, wi*((u %*% t(U))*( 1/ c_sq) + ((u %*% t(U)) * (u %*% t(U)))*(1/(c_sq*c_sq*2)) - sum(u*u)*(1/(c_sq*2)) + 1)*d)
?>
}

CudaDeviceFunction void Init() {
	real_t u[2] = {Velocity,0.};
	real_t d = Density;
	SetEquilibrum(d,u);
}

CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Solid:
	case NODE_Wall:
		BounceBack();
		break;
	case NODE_EVelocity:
		EVelocity();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
    }
    if (NodeType & NODE_MRT)
    {
		CollisionMRT();
    }
}

CudaDeviceFunction void BounceBack()
{
     real_t uf;
<?R
  V = cbind(1:9, bounce+1)
  sel = V[,1] > V[,2]
  V = V[sel,]
  for (i in 1:nrow(V))
  {
	C(uf, f[V[i,1]])
        C(f[V[i,1]], f[V[i,2]])
        C(f[V[i,2]], uf)
	
   }
?>
}

CudaDeviceFunction void EVelocity()
{
        real_t rho, ru;
	real_t ux0 = Velocity;
	rho = ( f[0] + f[2] + f[4] + 2.*(f[1] + f[5] + f[8]) ) / (1. + ux0);
	ru = rho * ux0;
	f[3] = f[1] - (2./3.) * ru;
	f[7] = f[5] - (1./6.) * ru + (1./2.)*(f[2] - f[4]);
	f[6] = f[8] - (1./6.) * ru + (1./2.)*(f[4] - f[2]);
}

CudaDeviceFunction void WPressure()
{
        real_t ru, ux0;
	real_t rho = Density;
	ux0 = -1. + ( f[0] + f[2] + f[4] + 2.*(f[3] + f[7] + f[6]) ) / rho;
	ru = rho * ux0;

	f[1] = f[3] - (2./3.) * ru;
	f[5] = f[7] - (1./6.) * ru + (1./2.)*(f[4] - f[2]);
	f[8] = f[6] - (1./6.) * ru + (1./2.)*(f[2] - f[4]);
}

CudaDeviceFunction void WVelocity()
{
        real_t rho, ru;
	real_t u[2] = {Velocity,0.};
	rho = ( f[0] + f[2] + f[4] + 2.*(f[3] + f[7] + f[6]) ) / (1. - u[0]);
	ru = rho * u[0];
	f[1] = f[3] + (2./3.) * ru;
	f[5] = f[7] + (1./6.) * ru + (1./2.)*(f[4] - f[2]);
	f[8] = f[6] + (1./6.) * ru + (1./2.)*(f[2] - f[4]);
}

CudaDeviceFunction void EPressure()
{
        real_t ru, ux0;
	real_t rho = Density;
	ux0 = -1. + ( f[0] + f[2] + f[4] + 2.*(f[1] + f[5] + f[8]) ) / rho;
	ru = rho * ux0;

	f[3] = f[1] - (2./3.) * ru;
	f[7] = f[5] - (1./6.) * ru + (1./2.)*(f[2] - f[4]);
	f[6] = f[8] - (1./6.) * ru + (1./2.)*(f[4] - f[2]);
}

CudaDeviceFunction void CollisionMRT()
{
	real_t u[2], usq, d, R[6];
<?R
        R = PV(c(
		"d",
		paste("u[",1:2-1,"]",sep=""),
		paste("R[",1:6-1,"]",sep="")
	))
        Sy = c(
		PV(c(0,0,0)),
		PV("S",c(2,3,5,7,8,9))
	)

M = matrix(c(
      1,  1,  1,  1,  1,  1,  1,  1,  1,
      0,  1,  0, -1,  0,  1, -1, -1,  1,
      0,  0,  1,  0, -1,  1,  1, -1, -1,
     -4, -1, -1, -1, -1,  2,  2,  2,  2,
      4, -2, -2, -2, -2,  1,  1,  1,  1,
      0, -2,  0,  2,  0,  1, -1, -1,  1,
      0,  0, -2,  0,  2,  1,  1, -1, -1,
      0,  1, -1,  1, -1,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  1, -1,  1, -1), 9,9);

	norms = diag(t(M) %*% M)
	C( R, f %*% M, float=F);
	C(usq, sum(u*u));
	
?>
switch (NodeType & NODE_OBJECTIVE) {
case NODE_Outlet:
	AddToOutletFlux(u[0]/d);
	AddToPressureLoss(-u[0]/d*((d-1.)/3. + usq/d/2.));
	break;
case NODE_Inlet:
	AddToInletFlux(u[0]/d);
	AddToPressureLoss(u[0]/d*((d-1.)/3. + usq/d/2.));
	break;
}
R[0] = R[0]*(1-S2)  +  S2*(-2. * d + 3. * usq);
R[1] = R[1]*(1-S3)  +  S3*(d - 3.*usq);
R[2] = R[2]*(1-S5)  +  S5*(-u[0]);
R[3] = R[3]*(1-S7)  +  S7*(-u[1]);
R[4] = R[4]*(1-S8)  +  S8*(u[0]*u[0] - u[1]*u[1]);
R[5] = R[5]*(1-S9)  +  S9*(u[0]*u[1]);
<?R
	for (i in 1:length(R)) { ?>
<?R C(R[i]) ?> /= <?%d norms[i] ?>; <?R
	} ?>
<?R
	C( f, R %*% t(M), float=F);
?>
}
