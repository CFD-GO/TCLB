<?R
        source("conf.R")
	c_header();
?>

#ifndef ARBLATTICE_H
#include "../LatticeBase.h"
#include "ModelConsts.h"

/// Class for computations
/**
  Class for all the memory allocation, storage, calculation
  recording for unsteady adjoint etc.
*/
class ArbitraryLattice : public LatticeBase {
private:
  ArbitraryLatticeContainer * container; ///< Main Container object
  real_t *mpiin[27], *mpiout[27]; ///< MPI Buffers
  real_t *gpuin[27], *gpuout[27], *gpubuf[27], *gpubuf2[27]; ///< GPU Buffers
  size_t bufsize[27]; ///< Sizes of the Buffers
  int nodein[27], nodeout[27]; ///< MPI Ranks of sources and destinations for Buffers
  int bufnumber; ///< Number of non-NULL Buffers
  int nSnaps; ///< Number of Snapshots
  AFTabs * Snaps; ///< Snapshots
  int * iSnaps; ///< Snapshot number (Now)
#ifdef ADJOINT
  AFTabs * aSnaps; ///< Adjoint Snapshots
#endif
  CudaStream_t kernelStream; ///< CUDA Stream for kernel runs
  CudaStream_t inStream; ///< CUDA Stream for CPU->GPU momory copy
  CudaStream_t outStream; ///< CUDA Stream for GPU->CPU momory copy
  //int reverse_save; ///< Flag stating if recording (Now) << moved to base class
    
public:
    Model_m current_model;
  std::vector < std::pair < int, std::pair <int, std::pair<real_t, real_t> > > > settings_record; ///< List of settings changes during the recording
  unsigned int settings_i; ///< Index in settings_record that is on the CUDA const
  void push_setting(int,real_t,real_t); ///< Set the setting (and push to settings_record if recording)
  void pop_settings(); ///< Pop the setting from settings_record
  //int Record_Iter; ///< Recorded iteration number (Now) << moved to base class
  real_t settings_val[SETTINGS];  ///< Table of Settings (Now)
  typedef BallTree< rfi_t > balltree_t;
  balltree_t BT;
  size_t particle_data_size_max;
  size_t balltree_data_size_max;
  ArbitraryLattice (lbRegion region, MPIInfo, int, size_t);
  ~ArbitraryLattice ();
  void MPIInit (MPIInfo);
  void Color(uchar4 *);
  int Offset(int,int,int);
  void LoadLattice(size_t* connectivity_, vector_t* coords, big_flag_t* nodeTypes, int* directionOffsets, size_t latticeSize, int Q, int ndx, int ndy, int ndz, int mindx, int mindy, int mindz);
  void FlagOverwrite(big_flag_t *, lbRegion);
  void CutsOverwrite(cut_t * Q, lbRegion over);
  void Init();
  void listTabs(AFTabs&, int*n, size_t ** size, void *** ptr, size_t * maxsize);
  int save(AFTabs&, const char * filename);
  int load(AFTabs&, const char * filename);
  void saveSolution(const char * filename);
  void loadSolution(const char * filename);
  size_t sizeOfTab();
  void saveToTab(real_t * tab, int snap);
  inline void saveToTab(real_t * tab) { saveToTab(tab,Snap); };
  void loadFromTab(real_t * tab, int snap);
  inline void loadFromTab(real_t * tab) { loadFromTab(tab,Snap); };
  void startRecord();
  //void rewindRecord(); << moved to base class
  //void stopRecord(); << moved to base class
  void clearAdjoint();
  void clearDPar();
  void        MPIStream_A();
  void        MPIStream_B(int );
  inline void MPIStream_B() { MPIStream_B(0); };
  
  void        Iterate(int, int);
  void        IterateTill(int,int);
  void	RunAction(int, int);
<?R for (n in names(Actions)) {
        a = Actions[[n]]
        if (n == "Iteration") {
                FunName = "Iteration"
        } else {
                FunName = paste("Action",n,sep="_")
        } ?>
        void <?%s FunName ?>_Adj(int, int, int, int, int); 
        void <?%s FunName ?>_Opt(int, int, int, int, int); 
        void <?%s FunName ?>(int, int, int); <?R
    } ?>
  void GetFlags(lbRegion, big_flag_t *);
  void GetCoords(real_t*);
  void Get_Field(int, real_t * tab);
  void Set_Field(int, real_t * tab);
  void Get_Field_Adj(int, real_t * tab);
        void IterateAction(int action, int iter, int iter_type);
        inline void RunAction(int action, int a, int b, int iter_type) {
		switch (action) { <?R
for (n in names(Actions)) {
        a = Actions[[n]]
        if (n == "Iteration") {
                FunName = "Iteration"
        } else {
                FunName = paste("Action",n,sep="_")
        } ?>
		case ACTION_<?%s n ?>: return <?%s FunName ?>(a, b, iter_type); <?R
} ?>
		}
	}
<?R for (d in rows(Fields)) if (d$parameter) { ?>
  void Get_<?%s d$nicename ?>(real_t * tab);
  void Clear_<?%s d$nicename ?>();
  void Set_<?%s d$nicename ?>(real_t * tab);
  void Get_<?%s d$nicename ?>_Adj(real_t * tab);
  void Clear_<?%s d$nicename ?>_Adj();
  void Set_<?%s d$nicename ?>_Adj(real_t * tab);
<?R } ?>
void GetQuantity(int quant, lbRegion over, real_t * tab, real_t scale);
<?R for (q in rows(Quantities)) { ifdef(q$adjoint); ?>
  void Get<?%s q$name ?>(lbRegion over, <?%s q$type ?> * tab, real_t scale);
  void GetSample<?%s q$name ?>(lbRegion over, real_t scale,real_t* tab);
  inline void Get<?%s q$name ?>(lbRegion over, <?%s q$type ?> * tab) { Get<?%s q$name ?>(over, tab, 1.0); };
  <?R tp = "double" ?>
  void Get<?%s q$name ?>_<?%s tp ?>(lbRegion over, <?%s tp ?> * tab, int row);
<?R }; ifdef() ?>
  void updateAllSamples();
  void getGlobals(real_t * tab); 
  void calcGlobals();
  void clearGlobals();
  void clearGlobals_Adj();
  double getObjective();
  void resetAverage();
  void setSetting(int i, real_t tmp);
  void SetSetting(int i, real_t val);
  real_t GetSetting(int i) ;
  void GenerateST();

	int saveComp(const char*, const char*);
	int loadComp(const char*, const char*);
    int getComponentIntoBuffer(const char*, real_t *&, long int* , long int* );
    int loadComponentFromBuffer(const char*, real_t*);
    int getQuantityIntoBuffer(const char*, real_t*&, long int*, long int*);
    /// Gets a Global index by name
    /**
    Gets the index of a Global by it's name
    \param str Name of the Global
    \return Index of the Global requested
    */
    inline int GlobalByName(const char * str) { <?R
        for (v in rows(Globals)) { ?>
        if (strcmp("<?%s v$name?>",str) == 0) return <?%s v$Index ?>; <?R
        } ?>
        return -1;
    }

    /// Gets the index of the Setting related to a weight of a Global in the objective
    /**
    Gets the index of the Setting for the weight of some Global in the objective
    \param i Index of the Global
    \return Index of the Setting related to the Global
    */
    inline int GlobalInObj(int i) { <?R 
        i = which(Settings$name == paste(Globals$name[1],"InObj",sep=""));
        if (length(i) != 1) { ?>
    // Probably no adjoint
        return -1; <?R
        } else { ?>
        return i + <?%s Settings$Index[i] ?>; <?R
        } ?>
    }
};

#define ARBLATTICE_H 1
#endif
