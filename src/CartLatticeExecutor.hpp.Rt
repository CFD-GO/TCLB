<?R
        source("conf.R")
c_header();
?>
/** \file CartLatticeExecutor.hpp
*/

#include "CartLatticeExecutor.h"
#include "CartLatticeAccess.hpp"
#include "Node.hpp"
#include "GetThreads.h"

using CartLatticeAccessAll      = AccessComposite< CartLatticeAccess< range_int<0,0,-1,1>, range_int<0,0,-1,1>, range_int<0,0,-1,1> > >;
using CartLatticeAccessInterior = AccessComposite< CartLatticeAccess<
  range_int< <?%d BorderMargin$max[1] ?>,0,<?%d BorderMargin$min[1]-1 ?>,1>,
  range_int< <?%d BorderMargin$max[2] ?>,0,<?%d BorderMargin$min[2]-1 ?>,1>,
  range_int< <?%d BorderMargin$max[3] ?>,0,<?%d BorderMargin$min[3]-1 ?>,1> > >;

// Quantity getters
<?R
        for (q in rows(Quantities))
        {
                ifdef(q$adjoint); ?>
/// Calculate quantity [<?%s q$comment ?>] kernel
/**
  Kernel to calculate quantity <?%s q$name ?> (<?%s q$comment ?>) over a region
  \param r Lattice region to calculate the quantity
  \param tab buffor to put the calculated result
  \param scale Scale to rescale the result (for units)
*/
inline CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale)
{
  using LA = CartLatticeAccessAll;
  int x = CudaBlock.x+r.dx;
  int y = CudaBlock.y+r.dy;
  int z = CudaBlock.z+r.dz;
  LA acc(x,y,z); <?R
    if (q$adjoint) { ?>
      Node< LA, Adjoint, NoGlobals, Get > now(acc); <?R
    } else { ?>
      Node< LA, Primal, NoGlobals, Get > now(acc); <?R
    }?>
    <?%s q$type ?> w;
//  if (now.NodeType) {
      acc.pop(now); <?R
      if (q$adjoint) { ?>
        acc.pop_adj(now); <?R
      } ?>
      w = now.get<?%s q$name ?>(); <?R
      if (q$type == "vector_t") {
        for (coef in c("x","y","z")) { ?>
          w.<?%s coef ?> *= scale; <?R
        }
      } else { ?>
        w *= scale; <?R
      } ?>
//  } else { <?R
      if (q$type == "vector_t") {
        for (coef in c("x","y","z")) { ?>
//        w.<?%s coef ?> = nan(""); <?R
        }
      } else { ?>
//      w = nan(""); <?R
      } ?>
//  }
  tab[r.offset(x,y,z)] = w;
}

template<class T>
static void CopyObjToConst(const T& host_obj, const T& const_symbol) {
  CudaCopyToConstant("copy to GPU constant memory", const_symbol, &host_obj, sizeof(T));
}

void CartLatticeExecutor::CopyToConst() const {
  CopyObjToConst(m_container, constContainer);
  CopyObjToConst(m_data, constData);
}

/// Main Kernel
/**
  iterates over all elements and runs them with RunElement function.
  constContainer.dx/dy is to calculate only internal nodes
*/
template < eOperationType I, eCalculateGlobals G, eStage S >
struct InteriorExecutor {
  CudaDeviceFunction void Execute() const {
    using LA = CartLatticeAccessInterior;
    using N  = Node<LA, I, G, S>;
    int x_ = CudaThread.x + CudaBlock.z*CudaNumberOfThreads.x + <?%d BorderMargin$max[1] ?>;
    int y_ = CudaThread.y + CudaBlock.x*CudaNumberOfThreads.y + <?%d BorderMargin$max[2] ?>;
    int z_ = CudaBlock.y                                      + <?%d BorderMargin$max[3] ?>;
    if (y_ < constContainer.ny - <?%d -BorderMargin$min[2] ?>) {
#ifndef GRID3D
      for (; x_ < constContainer.nx; x_ += CudaNumberOfThreads.x)
#endif
      {
        LA acc(x_,y_,z_);
        N now(acc);
        now.RunElement();
      }
    }
  }
};

/// Border Kernel
/**
  iterates over border elements and runs them with RunElement function
*/
template < eOperationType I, eCalculateGlobals G, eStage S >
struct BorderExecutor {
  CudaDeviceFunction void Execute() const {
    using LA = CartLatticeAccessAll;
    using N  = Node<LA, I, G, S>;
    int x_ = CudaThread.x + CudaBlock.z*CudaNumberOfThreads.x + <?%d BorderMargin$max[1] ?>;
    int a_ = CudaThread.y + CudaBlock.x*CudaNumberOfThreads.y;
    int y_,z_;
    switch (CudaBlock.y) { <?R
    i = 0
    if (BorderMargin$max[2] > BorderMargin$min[2]) for (y in BorderMargin$min[2]:BorderMargin$max[2]) if (y != 0) { ?>
    case <?%d i ?>:
      z_ = a_; <?R
      if (y > 0) { ?>
        y_ = <?%d y - 1 ?>; <?R
      } else if (y < 0) { ?>
        y_ = constContainer.ny - <?%d -y ?>; <?R
      } ?>
      if (z_ >= constContainer.nz) return;
      break; <?R
      i = i + 1;
      }
      if (BorderMargin$max[3] > BorderMargin$min[3]) for (z in BorderMargin$min[3]:BorderMargin$max[3]) if (z != 0) { ?>
    case <?%d i ?>:
      y_ = a_ + <?%d BorderMargin$max[2] ?>; <?R
      if (z > 0) { ?>
        z_ = <?%d z - 1 ?>; <?R
      } else if (z < 0) { ?>
      z_ = constContainer.nz - <?%d -z ?>; <?R
      } ?>
      if (y_ >= constContainer.ny - <?%d -BorderMargin$min[2] ?>) return;
      break; <?R
      i = i + 1;
      } ?>
    default:
      assert(CudaThread.y < <?%d i ?>);
      y_ = 0;z_ = 0;
      break;
    }

#ifndef GRID3D
    for (; x_ < constContainer.nx; x_ += CudaNumberOfThreads.x)
#endif
    {
      LA acc(x_,y_,z_);
      N now(acc);
      now.RunElement();
    }
  }
};

template <class E>
CudaGlobalFunction void Kernel() {
  E e;
  e.Execute();
}

/// Run the interior kernel
/**
  Dispatch the kernel running RunElement on all interior elements of the lattice
  \param stream CUDA Stream to which add the kernel run
*/
template <class EX>
void RunInteriorImpl(const CartLatticeContainer& container, CudaStream_t stream) {
  const int nx = container.nx;
  const int ny = container.ny;
  const int nz = container.nz;
  dim3 thr = ThreadNumber< EX >::threads();
  dim3 blx;
#ifdef GRID3D
  blx.z = nx/thr.x;
#else
  blx.z = 1;
#endif
  int totx = ny - <?%d BorderMargin$max[2]-BorderMargin$min[2] ?>;
  blx.x = ceiling_div(totx, thr.y);
  int toty = nz - <?%d BorderMargin$max[3]-BorderMargin$min[3] ?>;
  blx.y = toty;
  CudaKernelRunNoWait(Kernel< EX >, blx, thr, stream);
};

/// Run the border kernel
/**
  Dispatch the kernel running RunElement on all border elements of the Lattice
  \param stream CUDA Stream to which add the kernel run
*/
template <class EX>
void RunBorderImpl(const CartLatticeContainer& container, CudaStream_t stream) {
  const int nx = container.nx;
  const int ny = container.ny;
  const int nz = container.nz;
<?R
  thy = BorderMargin$max[2] - BorderMargin$min[2] + BorderMargin$max[3] - BorderMargin$min[3]
  blx = "nz"
  if (BorderMargin$max[3] != 0 || BorderMargin$min[3] != 0) blx = "max(ny,nz)"
  if (thy > 0) {
?>
  dim3 thr = ThreadNumber< EX >::threads();
  dim3 blx;
#ifdef GRID3D
  blx.z = nx/thr.x;
#else
  blx.z = 1;
#endif
  int totx = <?%s blx ?>;
  blx.x = ceiling_div(totx, thr.y);
  blx.y = <?%d thy ?>;
  CudaKernelRunNoWait(Kernel< EX >, blx, thr, stream);
<?R } ?>
};

template < eOperationType I, eCalculateGlobals G, eStage S >
void CartLatticeExecutor::RunInterior(CudaStream_t stream) const {
  RunInteriorImpl< InteriorExecutor< I, G, S > >(m_container, stream);
}

template < eOperationType I, eCalculateGlobals G, eStage S >
void CartLatticeExecutor::RunBorder(CudaStream_t stream) const {
  RunBorderImpl< BorderExecutor< I, G, S > >(m_container, stream);
}

/// Old function for graphics output
/**
  calculates the color for one node
*/
template < eOperationType I, eCalculateGlobals G, eStage S >
CudaDeviceFunction void CartLatticeExecutor::NodeToColor(int x, int y, int z, uchar4 *optr) {
  using LA = CartLatticeAccessAll;
  using N  = Node<LA, I, G, S>;

  int offset = x + y * constContainer.nx;
  float l = 0.0; float w = 0.0;
  int r = 0,g = 0,b = 0;
  if (x < 0 || y < 0 || z < 0) return;
  if (x >= constContainer.nx || y >= constContainer.ny || z >= constContainer.nz) return;

  {
    LA acc(x,y,z);
    N now(acc);
    acc.pop(now);
    float2 v = now.Color();
    l = v.x;
    w = v.y;
  }

  if (ISFINITE(l)) {
    l = l * 111;
    if (               (l <-111)) {r = 255; g = 255; b = 255; }
    if ((l >= -111) && (l < -11)) {r = 255*(-l-11)/100; g = 255; b = 255; }
    if ((l >=  -11) && (l <  -1)) {r = 0; g = (255*(-l-1))/10; b = 255; }
    if ((l >=   -1) && (l <   0)) {r = 0; g = 0; b = 255*(-l); }
    if ((l >=    0) && (l <   1)) {r = 255*l; g = 0; b = 0; }
    if ((l >=    1) && (l <  11)) {r = 255; g = 255*(l-1)/10; b = 0; }
    if ((l >=   11) && (l < 111)) {r = 255; g = 255; b = 255*(l-11)/100; }
    if ((l >=  111)             ) {r = 255; g = 255; b = 255; }
    r=r*w;
    g=g*w + (1-w)*255;
    b=b*w;
  } else {
    r = 255;
    g = 0;
    b = 255;
  }
  optr[offset].x = r;
  optr[offset].y = g;
  optr[offset].z = b;
  optr[offset].w = 255;
}

/// Kernel for graphics output
CudaGlobalFunction void ColorKernel(uchar4 *optr, int z)
{
  CartLatticeExecutor::NodeToColor< Primal, NoGlobals, Get >(
    CudaThread.x+CudaBlock.x*CudaNumberOfThreads.x,
    CudaBlock.y,
    z,
    optr);
}

/// Runs kernel for rendering graphics
/**
  Runs the kernel for rendering graphics
  \param optr 4-component graphics buffer
*/
void CartLatticeExecutor::Color(uchar4 *optr) {
  CopyToConst();
  CudaKernelRun(ColorKernel, dim3(floor(m_container.nx / X_BLOCK), m_container.ny, 1), dim3(X_BLOCK), optr, m_container.nz / 2);
}

<?R
  }
  ifdef();
?>

<?R   for (tp in rows(AllKernels)[order(AllKernels$adjoint)]) {
      st = Stages[tp$Stage,,drop=FALSE]
      ifdef(tp$adjoint)
      ?>
template void CartLatticeExecutor::RunBorder   < <?%s tp$TemplateArgs ?> > (CudaStream_t stream) const;
template void CartLatticeExecutor::RunInterior < <?%s tp$TemplateArgs ?> > (CudaStream_t stream) const; <?R
    };
  ifdef();
?>
