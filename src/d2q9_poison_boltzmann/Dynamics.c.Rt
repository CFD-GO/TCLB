<?R
	source("conf.R")
	c_header();

    U = as.matrix(Density[Density$group=="g",c("dx","dy")])

# Creating variables for symbolic computations
	#f = PV(DensityAll$name[DensityAll$group=="f"])
	g = PV(DensityAll$name[DensityAll$group=="g"])
	#h = PV(DensityAll$name[DensityAll$group=="h"])
	psi =  PV("psi")
	RD = PV("RD")
	tau_psi = PV("tau_psi")
	dt = PV("dt")
	rho_e = PV("rho_e")
	epsilon=PV("epsilon")

	#u = PV(c("ux","uy"))
	#rhoT = PV("rhoT")
	#C = PV("C")
	#tmp = PV("tmp")

# Extracting velocity set
#	U = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy")])

# Calculating equlibrium density set
#source("MRT/feq.R")
#	feq = MRT_feq(U, rho, u*rho );
   # RD = 2. * (0.5 -tau_psi) * dt / 3. * ( - rho_e(i_,j_) / epsilon );

    RD = -2./3. * (0.5 - tau_psi) * dt  * ( rho_e *(epsilon^-1) ) ;


	#geq = MRT_feq(U, rhoT, u*rhoT );
#	heq = MRT_feq(U, C, u*C );


    wp = c(1./9. - 1., 1./9., 1./9.,1./9.,1./9.,1./9.,1./9.,1./9.,1./9.)
    wp0 = 1./9.
    wps = c(0., 1./8., 1./8., 1./8., 1./8., 1./8., 1./8., 1./8., 1./8.)




#calculating weights
#	wi = subst(feq, rho=1, ux=0, uy=0)
#	wi = sapply(wi@vec,"[[",".M") # dirty way to extract numeric value - to be fixed
#	wi = c(16,4,4,4,4,1,1,1,1)/36
#	over_c2 = 1/sum(wi*U[,1]**2) # one over square of speed of sound

?>

CudaDeviceFunction real_t getPsi(){
    const real_t wp0 = <?R C(wp0) ?>;
	return ( <?R C( sum( g[2:9] ))  ?> ) / (1. - wp0);
}


CudaDeviceFunction real_t getSubiter(){
	return subiter;
}


CudaDeviceFunction real_t getrho_e(){
    const real_t psi = getPsi();
	return -2. * n_inf * z * el * sinh( z * el / kb/ T * psi);
}

CudaDeviceFunction void BounceBack()
{
    const real_t wp0 = <?R C(wp0) ?>;

     /*
     real_t tmp;
psi(i_,j_) = psi_down;
for (int k_ = 0; k_ < 9; k_++) {
    const int di = ix(k_,i_,j_);
    const int dj = iy(k_,i_,j_);

    const double shifted = psi_in(di,dj,k_);
    const double shifted_eq =  wp(k_) * psi(di,dj);

    psi_out(i_,j_,k_) =  wp(k_) * psi_down -  (1. - wp2) * (shifted - shifted_eq );
}
     */
<?R

    wp0=PV("wp0")
    psi_shifted = PV(paste("psi(",-U[,1],",",-U[,2],")"))
    psi_bc=PV("psi_bc")

    C(g, wp*psi_bc - (1. - wp0) * g - wp*psi_shifted)
#    C(g, wp*psi_bc)
    ?>
}

CudaDeviceFunction float2 Color() {
    float2 ret;
	ret.x = 0;
	ret.y = 0;
    return ret;
}

CudaDeviceFunction void CalcPsi() {
//    psi = getPsi();
}

CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Solid:
	case NODE_Wall:
		BounceBack();
		break;
    }
    if ((NodeType & NODE_COLLISION))
    {
        CollisionBGK();
    }
}

CudaDeviceFunction void Init() {
	real_t psi0;
	psi0 = 1.0;
<?R
    psi0=PV("psi0");
	C( g, wp*psi0 );
?>
}


CudaDeviceFunction void CollisionBGK()
{
	real_t M[9];
	real_t psi, rho_e;

	rho_e = getrho_e();
    psi = getPsi();
<?R
    C(g, g - tau_psi^-1 * (g - wp*psi) + dt * wps * RD  )
#    C(g, wp*psi)
    #C(RD )
#psi_out(i_,j_,k_) =  psi_in(i_,j_,k_) - 1. / tau_psi * ( psi_in(i_,j_,k_) - wp(k_) * psi(i_,j_)  ) + wps(k_) * RD;

?>



}
CudaDeviceFunction void CalcSubiter()
{
    subiter = subiter + 1;
}

