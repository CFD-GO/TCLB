<?R
	source("conf.R")
        c_header()
?>
#include "Global.h"
#include "Node.h"
#include "Lattice.h"

#define ALLOCPRINT1 printf("[%d] Allocating: %ld b ", D_MPI_RANK, size)
#define ALLOCPRINT2 printf("(%p - %p) \n", tmp, tmp+size)

int _xsdim = 0;
int _ysdim = 1;

CudaDeviceFunction inline int mymod(int x, int k){
        if (x >= k) return x-k;   
        if (x < 0) return x+k;
        return x;
}

CudaGlobalFunction void clearmem(real_t* ptr) {
	ptr[CudaBlock.x] = 0.0;
}

template <class N> dim3 GetThreads() {
	dim3 ret;
	cudaFuncAttributes * attr = new cudaFuncAttributes;
	HANDLE_ERROR( cudaFuncGetAttributes(attr, RunKernel<N>) );
	DEBUG1( printf( "[%d] Constant mem:%ld\n", D_MPI_RANK, attr->constSizeBytes) );
	DEBUG1( printf( "[%d] Local    mem:%ld\n", D_MPI_RANK, attr->localSizeBytes) );
	DEBUG2( printf( "[%d] Max  threads:%d\n", D_MPI_RANK, attr->maxThreadsPerBlock) );
	DEBUG1( printf( "[%d] Reg   Number:%d\n", D_MPI_RANK, attr->numRegs) );
	DEBUG1( printf( "[%d] Shared   mem:%ld\n", D_MPI_RANK, attr->sharedSizeBytes) );
	ret.x = 32;
	ret.y = attr->maxThreadsPerBlock/32;
	if (ret.y > 16) ret.y=16;
	ret.z = 1;
	return ret;
}

template < class N > inline int getKY() { return 0; }
template < class N > inline int getSY() { return 0; }

<?R for(tp in rows(Dispatch)) { ifdef(tp$adjoint)
?>int kydim<?%s tp$suffix ?>, sydim<?%s tp$suffix ?>;
template < > inline int getKY< Node<?%s tp$suffix ?> >() { return kydim<?%s tp$suffix ?>; }
template < > inline int getSY< Node<?%s tp$suffix ?> >() { return sydim<?%s tp$suffix ?>; }
<?R }; ifdef();?>

int InitDim(int ny) {
	dim3 th; int ky;
<?R for(tp in rows(Dispatch)) { ifdef(tp$adjoint)
?>	th = GetThreads< Node<?%s tp$suffix ?> >();
	sydim<?%s tp$suffix ?> = th.y;
	ky = ny/th.y;
	if (ky*th.y < ny) ky++;
	kydim<?%s tp$suffix ?> = ky;
<?R }; ifdef();
?>}



void * BAlloc(size_t size) {
  char * tmp;
    ALLOCPRINT1;
    #ifdef DIRECT_MEM
      CudaMallocHost( (void**)&tmp, size );
    #else
      CudaMalloc( (void**)&tmp, size );
    #endif
    ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
	return (void *) tmp;
}

void BPreAlloc(void ** ptr, size_t size) {
    CudaMalloc( ptr, size );
}

void FTabs::Alloc(int nx,int ny,int nz) {
  size_t size;
  char * tmp;
  <?R for (m in NonEmptyMargin) { ?>
    size = (size_t) <?R C(m$Size,float=F) ?>*sizeof(real_t);
    ALLOCPRINT1;
    #ifdef DIRECT_MEM
      CudaMallocHost( (void**)&tmp, size );
    #else
      CudaMalloc( (void**)&tmp, size );
    #endif
    ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
    <?%s m$name ?>=  (real_t*)tmp;
  <?R } ?>
}

void FTabs::PreAlloc(int nx,int ny,int nz) {
  size_t size;
  <?R for (m in NonEmptyMargin) { ?>
    size = (size_t) <?R C(m$Size,float=F) ?>*sizeof(real_t);
    CudaPreAlloc( (void**)&<?%s m$name ?>, size );
  <?R } ?>
}

void FTabs::Clear(int nx,int ny,int nz) {
  size_t size;
  <?R for (m in NonEmptyMargin) { ?>
    size = (size_t) <?R C(m$Size,float=F) ?>*sizeof(real_t);
    CudaMemset( <?%s m$name ?>, 0, size );
  <?R } ?>
}

void FTabs::Free() {
    <?R for (m in NonEmptyMargin) { ?>
	if ( <?%s m$name ?> != NULL) {
	#ifdef DIRECT_MEM
	    	CudaFreeHost( <?%s m$name ?> );
	#else
	    	CudaFree( <?%s m$name ?> );
	#endif
	}
    <?R } ?>
}

void LatticeContainer::Alloc(int nx_, int ny_, int nz_)
{
    iter = 0;
    nx = nx_;
    ny = ny_;
    nz = nz_;
    kx = nx/XSDIM;
    ky = ny/YSDIM;
    if (ky*YSDIM < ny) ky ++;

    InitDim(ny);

    char * tmp;
    size_t size;

    size = (size_t) nx*ny*nz*sizeof(flag_t);
	ALLOCPRINT1;
    CudaMalloc( (void**)&tmp, size );
	ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
    NodeType = (flag_t*)tmp;

    <?R for (inout in c("in","out")) for (m in NonEmptyMargin) { ?>
//        <?%s inout ?>.<?%s m$name ?> =  (real_t*)tmp;
    <?R } ?>


    <?R for (inout in c("in","out")) { ?>
//	<?%s inout ?>.Alloc(nx,ny,nz);
    <?R } ?>

    size = (size_t) GLOBALS * sizeof(real_t);
	ALLOCPRINT1;
    CudaMalloc( (void**)&tmp, size );
	ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
    Globals = (real_t*)tmp;

}

void LatticeContainer::Free()
{
    CudaFree( NodeType );
}


<?R
	push0 = function(a,pull=FALSE) {
		if (pull) { ?>
				node.<?%s gdens ?> = <?%s a ?>[ 0]; <?R
		} else { ?>
				<?%s a ?>[ 0] = node.<?%s gdens ?>; <?R
		}
	}

	pushX = function(a,b,dx,...) {
		if (dx < 0) { ?>
			if (node.x !=   0) {<?R
		} 
		if (dx > 0) { ?>
			if (node.x != nx-1) {<?R
		} 
		push0(a,...);
		if (dx != 0) { ?>
			} else { <?R
			push0(b,...); ?>
			} <?R
		}
	}

	pushY = function(a, b, c, d, dx,dy,...) {
		if (dy < 0) { ?>
		if (node.y !=   0) {<?R
		} 
		if (dy > 0) { ?>
		if (node.y != ny-1) {<?R
		}
		pushX(a, b, dx,...);
		if (dy != 0) {?>
		} else {<?R
			pushX(c, d, dx,...);	?>
		}<?R
		}
	}

	pushZ = function(a, b, c, d, e, f, g, h, dx, dy, dz,...) {
		if (dz < 0) { ?>
	if (node.z !=   0) {<?R
		} 
		if (dz > 0) { ?>
	if (node.z != nz-1) {<?R
		}
		pushY(a, b, c, d, dx, dy,...);
		if (dz != 0) {?>
	} else {<?R
			pushY(e, f, g, h, dx, dy,...); ?>
	}<?R
		}
	} 

	push = function(dens,dx,dy,dz,...) { ?>
//----------------------------- STREAMING <?%s dens ?> DIRECTION: (<?%2d dx ?>,<?%2d dy ?>,<?%2d dz ?>) ----------------------------------------------//
<?R
		gdens <<- dens;

		w = GetMargins(dx,dy,dz);
		nx = PV("nx")
		ny = PV("ny")
		nz = PV("nz")
		X = PV("node.x")
		Y = PV("node.y")
		Z = PV("node.z")

		H = PV(rep(0,8))
		H[1] = X + dx + nx * (Y + dy) + nx * ny * (Z + dz)
		H[2] = ny * (Z + dz) + (Y + dy)
		H[3] = nx * (Z + dz) + X+dx
		H[4] = Z + dz
		H[5] = nx * (Y + dy) + X+dx
		H[6] = Y + dy
		H[7] = X + dx
		H[8] = PV(0)

		for (i in 1:length(w)) if (w[i] > 0) {
			off = Margin[[w[i]]]$POffset
			noff = Margin[[w[i]]]$PSize + H[i]
			Margin[[w[i]]]$PSize <<- Margin[[w[i]]]$PSize + SideSize[i]
			v = ToC(noff - off,float=F);
			if (v != "   0") { ?>
	pocket.<?%s Margin[[w[i]]]$name ?> += <?%s v ?>; <?R
			}
			Margin[[w[i]]]$POffset <<- noff;
		}
		p = rep("ItCannotHappen",length(w))
		p[w > 0] = paste("pocket.", sapply(Margin[w],function(x) x$name), "", sep="")
		pushZ(
			p[1],
			p[2],
			p[3],
			p[4],
			p[5],
			p[6],
			p[7],
			p[8],
			dx, dy, dz,...);
	} 

	popX = function(dens,a,b,dx) {
		if (dx > 0) { ?>
			if (node.x >= nx - <?%d dx ?>) {
				node.<?%s dens ?> = <?%s b ?>;
			} else {
				node.<?%s dens ?> = <?%s a ?>;
			} <?R
		} else if (dx < 0) { ?>
			if (node.x < <?%d -dx ?>) {
				node.<?%s dens ?> = <?%s b ?>;
			} else {
				node.<?%s dens ?> = <?%s a ?>;
			} <?R
		} else { ?>
			node.<?%s dens ?> = <?%s a ?>; <?R
		}
	}

	popY = function(dens,a,b,c,d,dx,dy) {
		if (dy > 0) { ?>
		if (node.y  >= ny - <?%d dy ?>) { <?R
		}
		if (dy < 0) { ?>
		if (node.y  < <?%d -dy ?>) { <?R
		}
		if (dy != 0) {
			popX(dens, c, d, dx) ?>
		} else { <?R
		} 
		popX(dens, a, b, dx)
		if (dy != 0) { ?>
		} <?R
		}
	} 

	popZ = function(dens,a,b,c,d,e,f,g,h,dx,dy,dz) {
		if (dz > 0) { ?>
	if (node.z  >= nz - <?%d dz ?>) { <?R
		}
		if (dz < 0) { ?>
	if (node.z  < <?%d -dz ?>) { <?R
		}
		if (dz != 0) {
			popY(dens, e, f, g, h, dx, dy) ?>
	} else { <?R
		} 
		popY(dens, a, b, c, d, dx, dy)
		if (dz != 0) { ?>
	} <?R
		}
	}

	pop = function(dens,dx,dy,dz) { ?>
//----------------------------- GETTING <?%s dens ?> FROM DIRECTION: (<?%2d dx ?>,<?%2d dy ?>,<?%2d dz ?>) ----------------------------------------------//
//	CudaSyncThreads(); <?R
		w = GetMargins(dx,dy,dz);
		dx = -dx
		dy = -dy
		dz = -dz
		p = rep("ItCannotHappen",length(w))
		p[w > 0] = paste("pocket.", sapply(Margin[w],function(x) x$name), "[0]", sep="")
		popZ(	dens,
			p[1],
			p[2],
			p[3],
			p[4],
			p[5],
			p[6],
			p[7],
			p[8],
			dx,dy,dz)
		cat("\n")
		for (j in 1:length(w)) {
			i = w[j];
			if (i != 0) {
				?>	pocket.<?%s Margin[[i]]$name?> += <?R C(SideSize[j],float=F) ?>;
<?R			}
		}
	} 

	InOut = function(type, pocket, density) { ?>
	FTabs pocket = <?%s pocket ?>; <?R
		pull=F
		if ((type == "push") || (type == "pull")) {
			if (type == "pull") pull=T
			for ( i in 1:length(Margin) ) Margin[[i]]$POffset <<- PV(0)
			for ( i in 1:length(Margin) ) Margin[[i]]$PSize <<- PV(0)
			gdens = ""
			for (d in rows(density)) {
				push(d$name, d$dx, d$dy, d$dz, pull=pull)
			}
		} else if (type == "pop") { ?>
	node.NodeType = NodeType[(node.x + nx*node.y + nx*ny*node.z)]; <?R
			for (m in NonEmptyMargin) {
				v = ToC(m$Offset,float=F);
				if (v != "") { ?>
	pocket.<?%s m$name ?> += <?%s v ?>; <?R
				}
			}
			for (d in rows(density)) {
				pop(d$name, d$dx, d$dy, d$dz)
			}
		} else if (type == "type") { ?>
	node.NodeType = NodeType[(node.x + nx*node.y + nx*ny*node.z)]; <?R
		} else {
			stop("Unknown type in InOut");
		}
	}
?>


template <class N> CudaDeviceFunction void LatticeContainer::push(N & node) 
{
<?R	InOut("push", "out", Density); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pull(N & node) 
{
<?R	InOut("pull", "out", Density); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pop(N & node) 
{
<?R	InOut("pop", "in", Density); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::getType(N & node) 
{
<?R	InOut("type", "in", Density); ?>
}

#ifdef ADJOINT
template <class N> CudaDeviceFunction void LatticeContainer::push_adj(N & node) 
{
<?R	InOut("push", "adjout", DensityAD); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pull_adj(N & node) 
{
<?R	InOut("pull", "adjout", DensityAD); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pop_adj(N & node) 
{
<?R	InOut("pop", "adjin", DensityAD); ?>
}
#endif

/*
CudaDeviceFunction void inline LatticeContainer::Glob(Node now) {}

CudaDeviceFunction void inline LatticeContainer::Glob(Node_Globs now) {
<?R for (v in rows(Globals)) { ?>
        atomicSum(&Globals[<?%s v$Index ?>], now.<?%s v$name ?>);
<?R } ?>
}
*/

template <class N> inline CudaDeviceFunction void RunElement(N& now)
{
        constContainer.pop(now);
	#ifdef ADJOINT
	        constContainer.pop_adj(now);
		now.RunAdj();
		real_t back[DENSITY]; <?R
			for (d in rows(Density))
			{ ?>
		back[<?%s d$Index ?>] = now.<?%s d$name ?>; <?R
			} ?>
		now.Run_b(); <?R
			for (d in rows(Density))
			{ ?>
		now.<?%s d$name ?> = back[<?%s d$Index ?>]; <?R
			} ?>
	#endif
	now.Run();
        constContainer.push(now);
}

template <class N> CudaGlobalFunction void RunKernel()
{
	N now;
	now.x = CudaThread.x+CudaBlock.z*CudaNumberOfThreads.x+constContainer.dx;
	now.y = CudaThread.y+CudaBlock.x*CudaNumberOfThreads.y+constContainer.dy;
	now.z = CudaBlock.y+constContainer.dz;
	#ifndef GRID_3D
		for (; now.x < constContainer.nx; now.x += CudaNumberOfThreads.x) {
	#endif
		now.Pre();
		if (now.y < constContainer.fy) {
			now.RunElement();
		}
		//now.Glob();
		now.Glob();
	#ifndef GRID_3D
		}
	#endif
}


<?R if (any(DensityAll$dz != 0)) {?>
#define BORDER_Z // The model is 3D
<?R } else { ?>
// The model is 2D (no BORDER_Z)
<?R } ?>


template <class N> CudaGlobalFunction void RunBorderKernel()
{
	N now;
	now.x = CudaThread.x + CudaBlock.y*DXSDIM;
	now.z = CudaBlock.x;
	now.Pre();
#ifdef BORDER_Z
	if (now.z < constContainer.nz) {
#endif
		now.y = 0;
		now.RunElement();
#ifdef BORDER_Z
	}
#endif
	now.Glob();
	now.Pre();
#ifdef BORDER_Z
	if (now.z < constContainer.nz) {
#endif
		now.y = constContainer.ny - 1;
		now.RunElement();
#ifdef BORDER_Z
	}
#endif
	now.Glob();
	now.Pre();
#ifdef BORDER_Z
	now.y = CudaBlock.x;
	if ((now.y < constContainer.ny-1) && (now.y > 0)) {
		now.z = 0;
                now.RunElement();
	}
	now.Glob();
	now.Pre();
	if ((now.y < constContainer.ny-1) && (now.y > 0)) {
                now.z = constContainer.nz - 1;
                now.RunElement();
	}
	now.Glob();
#endif
}

void LatticeContainer::CopyToConst() {
    fx=nx;
    fy=ny-1;
    dx = 0; dy = 1; 
    #ifdef BORDER_Z
	dz = 1;
	fz = nz - 1;
    #else
	dz = 0;
	fz = nz;
    #endif
    CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));
}

template <class N> inline void LatticeContainer::RunBorderT(CudaStream_t borderStream) {
    #ifdef BORDER_Z
	    CudaKernelRunNoWait( RunBorderKernel<N> , dim3(max(ny,nz),kx,1) , dim3(XSDIM),(),borderStream);
    #else
	    CudaKernelRunNoWait( RunBorderKernel<N> , dim3(nz,kx,1) , dim3(XSDIM),(),borderStream);
    #endif
};

//void LatticeContainer::RunBorderG(CudaStream_t borderStream) { clearGlobals(); RunBorderT<Node_Globs>(borderStream); };
//void LatticeContainer::RunBorder (CudaStream_t borderStream) {                 RunBorderT<Node      >(borderStream); };

template <class N> inline void LatticeContainer::RunInteriorT(CudaStream_t interiorStream) {
    int nnz;
    ky = getKY<N>();
    #ifdef BORDER_Z
	nnz = nz - 2;
    #else
	nnz = nz;
    #endif
    #ifdef GRID_3D
        CudaKernelRunNoWait( RunKernel<N> , dim3(ky, nnz, kx) , dim3(XSDIM,getSY<N>()),(),interiorStream);
    #else
        CudaKernelRunNoWait( RunKernel<N> , dim3(ky, nnz, 1) , dim3(XSDIM,getSY<N>()),(),interiorStream);
    #endif
};

//void LatticeContainer::RunInteriorG(CudaStream_t interiorStream) { RunInteriorT<Node_Globs>(interiorStream); };
//void LatticeContainer::RunInterior (CudaStream_t interiorStream) { RunInteriorT<Node      >(interiorStream); };
<?R for(tp in rows(Dispatch)) {
ifdef(tp$adjoint) ?>
void LatticeContainer::RunBorder<?%s tp$suffix ?>(CudaStream_t stream) { RunBorderT< Node<?%s tp$suffix ?> >(stream); };
void LatticeContainer::RunInterior<?%s tp$suffix ?>(CudaStream_t stream) { RunInteriorT< Node<?%s tp$suffix ?> >(stream); };
<?R }
ifdef(); ?>
 
CudaDeviceFunction void node_to_color( int x, int y, uchar4 *optr )
{
    int offset = x+y*constContainer.nx;//constContainer.Offset(_z_);
    float l=0.0; float w=0.0;
    int r=0,g=0,b=0;
    Node now;
    now.x = x;
    now.y = y;
    now.z = 0;
    constContainer.pull(now);
    {
     float2 v = now.Color();
     l = v.x;
     w = v.y;
    }

    l = l * 111;
    if (               (l <-111)) {r = 255; g = 255; b = 255; }
    if ((l >= -111) && (l < -11)) {r = 255*(-l-11)/100; g = 255; b = 255; }
    if ((l >=  -11) && (l <  -1)) {r = 0; g = (255*(-l-1))/10; b = 255; }
    if ((l >=   -1) && (l <   0)) {r = 0; g = 0; b = 255*(-l); }
    if ((l >=    0) && (l <   1)) {r = 255*l; g = 0; b = 0; }
    if ((l >=    1) && (l <  11)) {r = 255; g = 255*(l-1)/10; b = 0; }
    if ((l >=   11) && (l < 111)) {r = 255; g = 255; b = 255*(l-11)/100; }
    if ((l >=  111)             ) {r = 255; g = 255; b = 255; }
    r=r*w;
    g=g*w + (1-w)*255;
    b=b*w;
  
    optr[offset].x = r;  
    optr[offset].y = g;  
    optr[offset].z = b;  
    optr[offset].w = 255;
}

CudaGlobalFunction void nodes_to_color( uchar4 *optr )
{
  node_to_color(
    CudaThread.x+CudaBlock.x*CudaNumberOfThreads.x,
    CudaBlock.y,
    optr
  );
}

CudaGlobalFunction void nodes_fill( int width, int height) {
	Node now;
	now.x = CudaThread.x+CudaBlock.z*CudaNumberOfThreads.x+constContainer.dx;
	now.y = CudaThread.y+CudaBlock.x*CudaNumberOfThreads.y+constContainer.dy;
	now.z = CudaBlock.y+constContainer.dz;
	if (now.y < constContainer.fy) {
		for (; now.x < constContainer.nx; now.x += CudaNumberOfThreads.x) {
			constContainer.pop(now);
		        now.Init();
			constContainer.push(now);
		}
	}
}

void LatticeContainer::Init() {
   printf("[%d] Initializing Lattice %d(%d)x%dx%d...\n", D_MPI_RANK,nx,kx,ny,nz); 
	dx=dy=dz=0;
	fx=nx;fy=ny;fz=nz;
   CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));	
   CudaKernelRun( nodes_fill , dim3(ny,nz,1), dim3(XSDIM) ,(nx,ny));
//   CudaKernelRun( nodes_fill_o , dim3(ny,nz,1), dim3(XSDIM) ,(nx,ny));
};

void LatticeContainer::Color( uchar4 *optr ) {
   dx=dy=dz=0;
   fx=nx;fy=ny;fz=nz;
   CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));	
   CudaKernelRun( nodes_to_color , dim3(kx,ny,1), dim3(XSDIM) ,(optr));
};

<?R
for (q in rows(Quantities))
{
	ifdef(q$adjoint); ?>

CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale)
{
	int x = CudaBlock.x+r.dx;
	int y = CudaBlock.y+r.dy;
	<?R if (q$adjoint) { ?>
		Node_Adj now;
	<?R } else { ?>
		Node now;
	<?R } ?>
	int z;
	for (z = r.dz; z < r.dz + r.nz; z ++) {
		now.x = x;
		now.y = y;
		now.z = z;
		constContainer.pull(now);
		<?R if (q$adjoint) { ?>
			constContainer.pull_adj(now);
		<?R } ?>
		<?%s q$type ?> w = now.get<?%s q$name ?>(); <?R
		if (q$type == "vector_t")
		{
		  for (coef in c("x","y","z")) { ?>
			w.<?%s coef ?> *= scale; <?R
		  }
		} else { ?>
			w *= scale;
		<?R } ?>
		tab[r.offset(x,y,z)] = w;
	}
} <?R
}
ifdef();?>

