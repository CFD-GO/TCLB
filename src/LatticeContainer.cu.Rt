<?R
	source("conf.R")
        c_header()
?>
/*  File defining LatticeContainer and some additional CUDA fun*/
/*     LatticeContainer is the container class which           */
/*       owns all the data needed by the kernels on device     */
/*       like pointers to the global gpu memory etc.           */
/*       It defines push/pull/pop functions allowing access    */
/*       to node data stored in memory.                        */
/*-------------------------------------------------------------*/

#include "Consts.h"
#include "Global.h"
#include "Lattice.h"
#include "mpi.h"

#define ALLOCPRINT1 printf("[%d] Allocating: %ld b ", D_MPI_RANK, size)
#define ALLOCPRINT2 printf("(%p - %p) \n", tmp, tmp+size)

int _xsdim = 0;
int _ysdim = 1;

// Fast modulo for one k
CudaDeviceFunction inline int mymod(int x, int k){
        if (x >= k) return x-k;   
        if (x < 0) return x+k;
        return x;
}

// clear mem (unused)
CudaGlobalFunction void clearmem(real_t* ptr) {
	ptr[CudaBlock.x] = 0.0;
}

// Init settings in const memory
void initSettings() {
	real_t val = 0;
<?R for (v in rows(Settings)) {
	if (is.na(v$derived)) { ?>
			CudaCopyToConstant("<?%s v$name ?>", <?%s v$name ?>, &val, sizeof(real_t)); <?R
	}} ?>
}

// Set setting in const memory
void setConstSetting(int i, real_t tmp) {
	switch (i) {
<?R
        for (v in rows(Settings)) if (is.na(v$derived)) { ?>
	case <?%s v$Index ?>:
	        CudaCopyToConstant("<?%s v$name ?>", <?%s v$name ?>, &tmp, sizeof(real_t));
		break; <?R
        } ?>
	}
}

// Get maximal number of threads for all the kernels on runtime
template <class N> dim3 GetThreads() {
	dim3 ret;
	cudaFuncAttributes * attr = new cudaFuncAttributes;
	HANDLE_ERROR( cudaFuncGetAttributes(attr, RunKernel<N>) );
	DEBUG1( printf( "[%d] Constant mem:%ld\n", D_MPI_RANK, attr->constSizeBytes) );
	DEBUG1( printf( "[%d] Local    mem:%ld\n", D_MPI_RANK, attr->localSizeBytes) );
	DEBUG1( printf( "[%d] Max  threads:%d\n", D_MPI_RANK, attr->maxThreadsPerBlock) );
	DEBUG1( printf( "[%d] Reg   Number:%d\n", D_MPI_RANK, attr->numRegs) );
	DEBUG1( printf( "[%d] Shared   mem:%ld\n", D_MPI_RANK, attr->sharedSizeBytes) );
	if (attr->maxThreadsPerBlock > MAX_THREADS) attr->maxThreadsPerBlock = MAX_THREADS;
	ret.x = X_BLOCK;
	ret.y = attr->maxThreadsPerBlock/ret.x;
	ret.z = 1;
	return ret;
}

// SY - number of threads in Y direction
// KY - number of blocks needed in Y direction to fill y
template < class N > inline int getKY() { return 0; }
template < class N > inline int getSY() { return 0; }

<?R for(tp in rows(Dispatch)) { ifdef(tp$adjoint_ver)
?>int kydim<?%s tp$suffix ?>, sydim<?%s tp$suffix ?>;
template < > inline int getKY< Node<?%s tp$suffix ?> >() { return kydim<?%s tp$suffix ?>; }
template < > inline int getSY< Node<?%s tp$suffix ?> >() { return sydim<?%s tp$suffix ?>; }
<?R }; ifdef();?>

// Initialize LatticeContainer
int InitDim(int ny) {
	dim3 th; int ky;
	MPI_Barrier(MPI_COMM_WORLD);
	if (D_MPI_RANK == 0) {
          DEBUG2( printf( "[ ] |  Threads  |      Action  |\n") );
        }
	MPI_Barrier(MPI_COMM_WORLD);
<?R for(tp in rows(Dispatch)) { ifdef(tp$adjoint_ver)
?>	th = GetThreads< Node<?%s tp$suffix ?> >();
	DEBUG2( printf( "[%d] |  %3dx%-3d  |  %10s  |\n", D_MPI_RANK, th.x, th.y, "<?%s tp$suffix ?>") );
	MPI_Barrier(MPI_COMM_WORLD);
	sydim<?%s tp$suffix ?> = th.y;
	ky = ny/th.y;
	if (ky*th.y < ny) ky++;
	kydim<?%s tp$suffix ?> = ky;
<?R }; ifdef();
?>}

// Allocation of a buffer
void * BAlloc(size_t size) {
  char * tmp;
    ALLOCPRINT1;
    #ifdef DIRECT_MEM
      CudaMallocHost( (void**)&tmp, size );
    #else
      CudaMalloc( (void**)&tmp, size );
    #endif
    ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); 
	return (void *) tmp;
}

// Preallocation of a buffer (combines allocation into one big allocation)
void BPreAlloc(void ** ptr, size_t size) {
    CudaMalloc( ptr, size );
}

// Allocation of a FTabs (table with pointers to buffers)
void FTabs::Alloc(int nx,int ny,int nz) {
  size_t size;
  char * tmp;
  <?R for (m in NonEmptyMargin) { ?>
    size = (size_t) <?R C(m$Size,float=F) ?>*sizeof(real_t);
    ALLOCPRINT1;
    #ifdef DIRECT_MEM
      CudaMallocHost( (void**)&tmp, size );
    #else
      CudaMalloc( (void**)&tmp, size );
    #endif
    ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); 
    <?%s m$name ?>=  (real_t*)tmp;
  <?R } ?>
}

// Preallocation of a FTabs (table with pointers to buffers)
void FTabs::PreAlloc(int nx,int ny,int nz) {
  size_t size;
  <?R for (m in NonEmptyMargin) { ?>
    size = (size_t) <?R C(m$Size,float=F) ?>*sizeof(real_t);
    CudaPreAlloc( (void**)&<?%s m$name ?>, size );
  <?R } ?>
}

// Clearing of a FTags
void FTabs::Clear(int nx,int ny,int nz) {
  size_t size;
  <?R for (m in NonEmptyMargin) { ?>
    size = (size_t) <?R C(m$Size,float=F) ?>*sizeof(real_t);
    CudaMemset( <?%s m$name ?>, 0, size );
  <?R } ?>
}

// Safe free
inline void MyFree(void * ptr) {
    if (ptr != NULL) {
        #ifdef DIRECT_MEM
	    CudaFreeHost( ptr );
	#else
	    CudaFree( ptr );
	#endif
    }
}

// Free FTabs
void FTabs::Free() { <?R
    for (m in NonEmptyMargin) { ?>
    MyFree(<?%s m$name ?>); <?R
    } ?>
}

// Allocation of Container
void LatticeContainer::Alloc(int nx_, int ny_, int nz_)
{
    iter = 0;
    nx = nx_;
    ny = ny_;
    nz = nz_;
    kx = nx/X_BLOCK;
    ky = ny;

    InitDim(ny);

    char * tmp;
    size_t size;

    size = (size_t) nx*ny*nz*sizeof(flag_t);
	ALLOCPRINT1;
    CudaMalloc( (void**)&tmp, size );
	ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); 
    NodeType = (flag_t*)tmp;

    size = (size_t) GLOBALS * sizeof(real_t);
	ALLOCPRINT1;
    CudaMalloc( (void**)&tmp, size );
	ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
    Globals = (real_t*)tmp;
}

// Destroy Container (cannot do a constructor and destructor - because this class lives on GPU)
void LatticeContainer::Free()
{
    CudaFree( NodeType );
}

<?R
# Here is the R code for push/pull/pop functions
#   It simply puts the values from right places in the memory into right variables in the Node class
#   Happy reading ...

# Push/pull is constructed as a 3 level call
#   in which every level dispatches every dimension in order: Z Y X
#   in each dimension we check if we're goint out of our region
#   and write to the border buffer in such case

	push0 = function(a,pull=FALSE) {
		if (pull) { ?>
				node.<?%s gdens ?> = <?%s a ?>[ 0]; <?R
		} else { ?>
				<?%s a ?>[ 0] = node.<?%s gdens ?>; <?R
		}
	}

	pushX = function(a,b,dx,...) {
		if (dx < 0) { ?>
			if (node.x !=   0) {<?R
		} 
		if (dx > 0) { ?>
			if (node.x != nx-1) {<?R
		} 
		push0(a,...);
		if (dx != 0) { ?>
			} else { <?R
			push0(b,...); ?>
			} <?R
		}
	}

	pushY = function(a, b, c, d, dx,dy,...) {
		if (dy < 0) { ?>
		if (node.y !=   0) {<?R
		} 
		if (dy > 0) { ?>
		if (node.y != ny-1) {<?R
		}
		pushX(a, b, dx,...);
		if (dy != 0) {?>
		} else {<?R
			pushX(c, d, dx,...);	?>
		}<?R
		}
	}

	pushZ = function(a, b, c, d, e, f, g, h, dx, dy, dz,...) {
		if (dz < 0) { ?>
	if (node.z !=   0) {<?R
		} 
		if (dz > 0) { ?>
	if (node.z != nz-1) {<?R
		}
		pushY(a, b, c, d, dx, dy,...);
		if (dz != 0) {?>
	} else {<?R
			pushY(e, f, g, h, dx, dy,...); ?>
	}<?R
		}
	} 

# Main push/pull function for a specific density

	push = function(dens,dx,dy,dz,sel=TRUE,...) { 
	        if (sel) { ?>
//----------------------------- STREAMING <?%s dens ?> DIRECTION: (<?%2d dx ?>,<?%2d dy ?>,<?%2d dz ?>) ----------------------------------------------// <?R
                }
		gdens <<- dens;

		w = GetMargins(dx,dy,dz);
		nx = PV("nx")
		ny = PV("ny")
		nz = PV("nz")
		X = PV("node.x")
		Y = PV("node.y")
		Z = PV("node.z")

		H = PV(rep(0,8))
		H[1] = X + dx + nx * (Y + dy) + nx * ny * (Z + dz)
		H[2] = ny * (Z + dz) + (Y + dy)
		H[3] = nx * (Z + dz) + X+dx
		H[4] = Z + dz
		H[5] = nx * (Y + dy) + X+dx
		H[6] = Y + dy
		H[7] = X + dx
		H[8] = PV(0)

		
		if (sel) {
                    for (i in 1:length(w)) if (w[i] > 0) {
                            off = Margin[[w[i]]]$POffset
                            noff = Margin[[w[i]]]$PSize + H[i]
                            v = ToC(noff - off,float=F);
                            if (v != "   0") { ?>
        pocket.<?%s Margin[[w[i]]]$name ?> += <?%s v ?>; <?R
                            }
			    Margin[[w[i]]]$POffset <<- noff;
                    }
		    p = rep("ItCannotHappen",length(w))
                    p[w > 0] = paste("pocket.", sapply(Margin[w],function(x) x$name), "", sep="")
                    pushZ(
                            p[1],
                            p[2],
                            p[3],
                            p[4],
                            p[5],
                            p[6],
                            p[7],
                            p[8],
                            dx, dy, dz,...);
                }
		for (i in 1:length(w)) if (w[i] > 0) {
			Margin[[w[i]]]$PSize <<- Margin[[w[i]]]$PSize + SideSize[i]
		}
	} 

# Pop is constructed as a 3 level call
#   in which every level dispatches every dimension in order: Z Y X
#   in each dimension we check if we're goint out of our region
#   and read from a border buffer in such case

	popX = function(dens,a,b,dx) {
		if (dx > 0) { ?>
			if (node.x >= nx - <?%d dx ?>) {
				node.<?%s dens ?> = <?%s b ?>;
			} else {
				node.<?%s dens ?> = <?%s a ?>;
			} <?R
		} else if (dx < 0) { ?>
			if (node.x < <?%d -dx ?>) {
				node.<?%s dens ?> = <?%s b ?>;
			} else {
				node.<?%s dens ?> = <?%s a ?>;
			} <?R
		} else { ?>
			node.<?%s dens ?> = <?%s a ?>; <?R
		}
	}

	popY = function(dens,a,b,c,d,dx,dy) {
		if (dy > 0) { ?>
		if (node.y  >= ny - <?%d dy ?>) { <?R
		}
		if (dy < 0) { ?>
		if (node.y  < <?%d -dy ?>) { <?R
		}
		if (dy != 0) {
			popX(dens, c, d, dx) ?>
		} else { <?R
		} 
		popX(dens, a, b, dx)
		if (dy != 0) { ?>
		} <?R
		}
	} 

	popZ = function(dens,a,b,c,d,e,f,g,h,dx,dy,dz) {
		if (dz > 0) { ?>
	if (node.z  >= nz - <?%d dz ?>) { <?R
		}
		if (dz < 0) { ?>
	if (node.z  < <?%d -dz ?>) { <?R
		}
		if (dz != 0) {
			popY(dens, e, f, g, h, dx, dy) ?>
	} else { <?R
		} 
		popY(dens, a, b, c, d, dx, dy)
		if (dz != 0) { ?>
	} <?R
		}
	}

# Main pop function for a specific density

	pop = function(dens,dx,dy,dz) { ?>
//----------------------------- GETTING <?%s dens ?> FROM DIRECTION: (<?%2d dx ?>,<?%2d dy ?>,<?%2d dz ?>) ----------------------------------------------//
//	CudaSyncThreads(); <?R
		w = GetMargins(dx,dy,dz);
		dx = -dx
		dy = -dy
		dz = -dz
		p = rep("ItCannotHappen",length(w))
		p[w > 0] = paste("pocket.", sapply(Margin[w],function(x) x$name), "[0]", sep="")
		popZ(	dens,
			p[1],
			p[2],
			p[3],
			p[4],
			p[5],
			p[6],
			p[7],
			p[8],
			dx,dy,dz)
		cat("\n")
		for (j in 1:length(w)) {
			i = w[j];
			if (i != 0) {
				?>	pocket.<?%s Margin[[i]]$name?> += <?R C(SideSize[j],float=F) ?>;
<?R			}
		}
	} 


# InOut function outputs the code for a push/pull/pop for a set of densities
#   pop - Gets densities for the point where we are.
#   push - Puts densities in the neighbours according to streaming direction
#   pull - Direct opposite of push
#   type - Gets only the NodeType from the memory

	InOut = function(type, pocket, density, sel) {
                if (missing(sel)) sel = rep(TRUE, nrow(density));
                density$selected = sel; ?>
	FTabs pocket = <?%s pocket ?>; <?R
		pull=F
		if ((type == "push") || (type == "pull")) {
			if (type == "pull") pull=T
			for ( i in 1:length(Margin) ) Margin[[i]]$POffset <<- PV(0)
			for ( i in 1:length(Margin) ) Margin[[i]]$PSize <<- PV(0)
			gdens = ""
			for (d in rows(density)) {
				push(d$name, d$dx, d$dy, d$dz, pull=pull, sel=d$selected)
			}
		} else if (type == "pop") { ?>
	node.NodeType = NodeType[(node.x + nx*node.y + nx*ny*node.z)]; <?R
			for (m in NonEmptyMargin) {
				v = ToC(m$Offset,float=F);
				if (v != "") { ?>
	pocket.<?%s m$name ?> += <?%s v ?>; <?R
				}
			}
			for (d in rows(density)) {
				pop(d$name, d$dx, d$dy, d$dz)
			}
		} else if (type == "type") { ?>
	node.NodeType = NodeType[(node.x + nx*node.y + nx*ny*node.z)]; <?R
		} else {
			stop("Unknown type in InOut");
		}
	}
?>

// Push all densities
template <class N> CudaDeviceFunction void LatticeContainer::push(N & node) 
{
<?R	InOut("push", "out", Density); ?>
}

// Push only parameters
template <class N> CudaDeviceFunction void LatticeContainer::push_param(N & node) 
{
<?R	InOut("push", "out", Density, sel=Density$parameter); ?>
}

// Push everything exept parameters
template <class N> CudaDeviceFunction void LatticeContainer::push_noparam(N & node) 
{
<?R	InOut("push", "out", Density, sel=(! Density$parameter)); ?>
}

// Opposite of push
template <class N> CudaDeviceFunction void LatticeContainer::pull(N & node) 
{
<?R	InOut("pull", "out", Density); ?>
}

// Get densities
template <class N> CudaDeviceFunction void LatticeContainer::pop(N & node) 
{
<?R	InOut("pop", "in", Density); ?>
}

// Get only type of node
template <class N> CudaDeviceFunction void LatticeContainer::getType(N & node) 
{
<?R	InOut("type", "in", Density); ?>
}

#ifdef ADJOINT
// Push all adjoint densities
template <class N> CudaDeviceFunction void LatticeContainer::push_adj(N & node) 
{
<?R	InOut("push", "adjout", DensityAD); ?>
}

// Opposite of push_adj
template <class N> CudaDeviceFunction void LatticeContainer::pull_adj(N & node) 
{
<?R	InOut("pull", "adjout", DensityAD); ?>
}

// Get adjoint densities
template <class N> CudaDeviceFunction void LatticeContainer::pop_adj(N & node) 
{
<?R	InOut("pop", "adjin", DensityAD); ?>
}
#endif


// Main Kernel
//   iterates over all elements and runs them with RunElement function
//   constContainer.dx/dy is to calculate only internal nodes
template <class N> CudaGlobalFunction void RunKernel()
{
	N now;
	now.x = CudaThread.x+CudaBlock.z*CudaNumberOfThreads.x+constContainer.dx;
	now.y = CudaThread.y+CudaBlock.x*CudaNumberOfThreads.y+constContainer.dy;
	now.z = CudaBlock.y+constContainer.dz;
	#ifndef GRID_3D
		for (; now.x < constContainer.nx; now.x += CudaNumberOfThreads.x) {
	#endif
		now.Pre();
		if (now.y < constContainer.fy) {
			now.RunElement();
		}
		now.Glob();
	#ifndef GRID_3D
		}
	#endif
}

// BORDER_Z defines if we need to take Z direction in consiredation border/interior
//   if a model is 2D everything in the Z direction is interior
<?R if (any(DensityAll$dz != 0)) {?>
#define BORDER_Z // The model is 3D
<?R } else { ?>
// The model is 2D (no BORDER_Z)
<?R } ?>

// Border Kernel
//   iterates over border elements and runs them with RunElement function
template <class N> CudaGlobalFunction void RunBorderKernel()
{
	N now;
	now.x = CudaThread.x + CudaBlock.y*X_BLOCK;
	now.z = CudaBlock.x;
	now.Pre();
#ifdef BORDER_Z
	if (now.z < constContainer.nz) {
#endif
		now.y = 0;
		now.RunElement();
#ifdef BORDER_Z
	}
#endif
	now.Glob();
	now.Pre();
#ifdef BORDER_Z
	if (now.z < constContainer.nz) {
#endif
		now.y = constContainer.ny - 1;
		now.RunElement();
#ifdef BORDER_Z
	}
#endif
	now.Glob();
	now.Pre();
#ifdef BORDER_Z
	now.y = CudaBlock.x;
	if ((now.y < constContainer.ny-1) && (now.y > 0)) {
		now.z = 0;
                now.RunElement();
	}
	now.Glob();
	now.Pre();
	if ((now.y < constContainer.ny-1) && (now.y > 0)) {
                now.z = constContainer.nz - 1;
                now.RunElement();
	}
	now.Glob();
#endif
}

// Copies me(LatticeContainer) to the const gpu memory
void LatticeContainer::CopyToConst() {
    fx=nx;
    fy=ny-1;
    dx = 0; dy = 1; 
    #ifdef BORDER_Z
	dz = 1;
	fz = nz - 1;
    #else
	dz = 0;
	fz = nz;
    #endif
    CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));
}

// Run the border kernel
template <class N> inline void LatticeContainer::RunBorderT(CudaStream_t borderStream) {
    #ifdef BORDER_Z
	    CudaKernelRunNoWait( RunBorderKernel<N> , dim3(max(ny,nz),kx,1) , dim3(X_BLOCK),(),borderStream);
    #else
	    CudaKernelRunNoWait( RunBorderKernel<N> , dim3(nz,kx,1) , dim3(X_BLOCK),(),borderStream);
    #endif
};

// Run the interior kernel
template <class N> inline void LatticeContainer::RunInteriorT(CudaStream_t interiorStream) {
    int nnz;
    ky = getKY<N>();
    #ifdef BORDER_Z
	nnz = nz - 2;
    #else
	nnz = nz;
    #endif
    #ifdef GRID_3D
        CudaKernelRunNoWait( RunKernel<N> , dim3(ky, nnz, kx) , dim3(X_BLOCK,getSY<N>()),(),interiorStream);
    #else
        CudaKernelRunNoWait( RunKernel<N> , dim3(ky, nnz, 1) , dim3(X_BLOCK,getSY<N>()),(),interiorStream);
    #endif
};

// Type specific runs
<?R for(tp in rows(Dispatch)) {
ifdef(tp$adjoint_ver) ?>
void LatticeContainer::RunBorder<?%s tp$suffix ?>(CudaStream_t stream) { RunBorderT< Node<?%s tp$suffix ?> >(stream); };
void LatticeContainer::RunInterior<?%s tp$suffix ?>(CudaStream_t stream) { RunInteriorT< Node<?%s tp$suffix ?> >(stream); };
<?R }
ifdef(); ?>
 
// Old function for graphics output
//   calculates the color for one node
CudaDeviceFunction void NodeToColor( int x, int y, uchar4 *optr )
{
    int offset = x+y*constContainer.nx;
    float l=0.0; float w=0.0;
    int r=0,g=0,b=0;
    Node now;
    now.x = x;
    now.y = y;
    now.z = 0;
    constContainer.pull(now);
    {
     float2 v = now.Color();
     l = v.x;
     w = v.y;
    }

    l = l * 111;
    if (               (l <-111)) {r = 255; g = 255; b = 255; }
    if ((l >= -111) && (l < -11)) {r = 255*(-l-11)/100; g = 255; b = 255; }
    if ((l >=  -11) && (l <  -1)) {r = 0; g = (255*(-l-1))/10; b = 255; }
    if ((l >=   -1) && (l <   0)) {r = 0; g = 0; b = 255*(-l); }
    if ((l >=    0) && (l <   1)) {r = 255*l; g = 0; b = 0; }
    if ((l >=    1) && (l <  11)) {r = 255; g = 255*(l-1)/10; b = 0; }
    if ((l >=   11) && (l < 111)) {r = 255; g = 255; b = 255*(l-11)/100; }
    if ((l >=  111)             ) {r = 255; g = 255; b = 255; }
    r=r*w;
    g=g*w + (1-w)*255;
    b=b*w;
  
    optr[offset].x = r;  
    optr[offset].y = g;  
    optr[offset].z = b;  
    optr[offset].w = 255;
}

// kernel for graphics output
CudaGlobalFunction void ColorKernel( uchar4 *optr )
{
  NodeToColor(
    CudaThread.x+CudaBlock.x*CudaNumberOfThreads.x,
    CudaBlock.y,
    optr
  );
}

// Runs graphics kernel
void LatticeContainer::Color( uchar4 *optr ) {
   CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));	
   CudaKernelRun( ColorKernel , dim3(kx,ny,1), dim3(X_BLOCK) ,(optr));
};

// Functions for getting quantities
<?R
        for (q in rows(Quantities))
        {
                ifdef(q$adjoint); ?>
// Kernel to calculate quantity <?%s q$name ?> over a region
CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale)
{
	int x = CudaBlock.x+r.dx;
	int y = CudaBlock.y+r.dy; <?R
	if (q$adjoint) { ?>
	Node_Adj now; <?R
        } else { ?>
	Node now; <?R
        } ?>
	int z;
	for (z = r.dz; z < r.dz + r.nz; z ++) {
		now.x = x;
		now.y = y;
		now.z = z;
		constContainer.pull(now); <?R
		if (q$adjoint) { ?>
		constContainer.pull_adj(now); <?R
                } ?>
		<?%s q$type ?> w = now.get<?%s q$name ?>(); <?R
		if (q$type == "vector_t")
		{
                  for (coef in c("x","y","z")) { ?>
		w.<?%s coef ?> *= scale; <?R
		  }
		} else { ?>
		w *= scale; <?R
                } ?>
		tab[r.offset(x,y,z)] = w;
	}
}
<?R
        }
        ifdef();
?>

