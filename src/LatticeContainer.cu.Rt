<?R
	source("conf.R")
        c_header()
?>
#include "Global.h"
#include "Node.h"
#include "Lattice.h"

#define ALLOCPRINT1 printf("[%d] Allocating: %ld b ", D_MPI_RANK, size)
#define ALLOCPRINT2 printf("(%p - %p) \n", tmp, tmp+size)

int _xsdim = 0;
int _ysdim = 1;


CudaDeviceFunction inline int mymod(int x, int k){
        if (x >= k) return x-k;   
        if (x < 0) return x+k;
        return x;
}

CudaGlobalFunction void clearmem(real_t* ptr) {
	ptr[CudaBlock.x] = 0.0;
}

void * BAlloc(size_t size) {
  char * tmp;
    ALLOCPRINT1;
    #ifdef DIRECT_MEM
      CudaMallocHost( (void**)&tmp, size );
    #else
      CudaMalloc( (void**)&tmp, size );
    #endif
    ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
	return (void *) tmp;
}

void FTabs::Alloc(int nx,int ny,int nz) {
  size_t size;
  char * tmp;
  <?R for (m in NonEmptyMargin) { ?>
    size = (size_t) <?R C(m$Size,float=F) ?>*sizeof(real_t);
    ALLOCPRINT1;
    #ifdef DIRECT_MEM
      CudaMallocHost( (void**)&tmp, size );
    #else
      CudaMalloc( (void**)&tmp, size );
    #endif
    ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
    <?%s m$name ?>=  (real_t*)tmp;
  <?R } ?>
}


void FTabs::Free() {
    <?R for (m in NonEmptyMargin) { ?>
	if ( <?%s m$name ?> != NULL) {
	#ifdef DIRECT_MEM
	    	CudaFreeHost( <?%s m$name ?> );
	#else
	    	CudaFree( <?%s m$name ?> );
	#endif
	}
    <?R } ?>
}

void LatticeContainer::Alloc(int nx_, int ny_, int nz_)
{
	iter = 0;
    nx = nx_;
    ny = ny_;
    nz = nz_;
    kx = nx/XSDIM;
    ky = ny/YSDIM;
	if (ky*YSDIM < ny) ky ++;

    char * tmp;
    size_t size;

    size = (size_t) nx*ny*nz*sizeof(flag_t);
	ALLOCPRINT1;
    CudaMalloc( (void**)&tmp, size );
	ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
    NodeType = (flag_t*)tmp;

    <?R for (inout in c("in","out")) for (m in NonEmptyMargin) { ?>
//        <?%s inout ?>.<?%s m$name ?> =  (real_t*)tmp;
    <?R } ?>


    <?R for (inout in c("in","out")) { ?>
//	<?%s inout ?>.Alloc(nx,ny,nz);
    <?R } ?>

    size = (size_t) <?%d nrow(Globals) ?>*sizeof(real_t);
	ALLOCPRINT1;
    CudaMalloc( (void**)&tmp, size );
	ALLOCPRINT2;
    CudaMemset( tmp, 0, size ); // CudaKernelRun(clearmem,dim3(size/sizeof(real_t)),dim3(1),((real_t*)tmp));
    Globals = (real_t*)tmp;

}

void LatticeContainer::Free()
{
    CudaFree( NodeType );
}


<?R
	push0 = function(a,pull=FALSE) {
		if (pull) { ?>
				node.<?%s gdens ?> = <?%s a ?>[ 0]; <?R
		} else { ?>
				<?%s a ?>[ 0] = node.<?%s gdens ?>; <?R
		}
	}

	pushX = function(a,b,dx,...) {
		if (dx < 0) { ?>
			if (node.x !=   0) {<?R
		} 
		if (dx > 0) { ?>
			if (node.x != nx-1) {<?R
		} 
		push0(a,...);
		if (dx != 0) { ?>
			} else { <?R
			push0(b,...); ?>
			} <?R
		}
	}

	pushY = function(a, b, c, d, dx,dy,...) {
		if (dy < 0) { ?>
		if (node.y !=   0) {<?R
		} 
		if (dy > 0) { ?>
		if (node.y != ny-1) {<?R
		}
		pushX(a, b, dx,...);
		if (dy != 0) {?>
		} else {<?R
			pushX(c, d, dx,...);	?>
		}<?R
		}
	}

	pushZ = function(a, b, c, d, e, f, g, h, dx, dy, dz,...) {
		if (dz < 0) { ?>
	if (node.z !=   0) {<?R
		} 
		if (dz > 0) { ?>
	if (node.z != nz-1) {<?R
		}
		pushY(a, b, c, d, dx, dy,...);
		if (dz != 0) {?>
	} else {<?R
			pushY(e, f, g, h, dx, dy,...); ?>
	}<?R
		}
	} 

	push = function(dens,dx,dy,dz,...) { ?>
//----------------------------- STREAMING <?%s dens ?> DIRECTION: (<?%2d dx ?>,<?%2d dy ?>,<?%2d dz ?>) ----------------------------------------------//
<?R
		gdens <<- dens;

		w = GetMargins(dx,dy,dz);
		nx = PV("nx")
		ny = PV("ny")
		nz = PV("nz")
		X = PV("node.x")
		Y = PV("node.y")
		Z = PV("node.z")

		H = PV(rep(0,8))
		H[1] = X + dx + nx * (Y + dy) + nx * ny * (Z + dz)
		H[2] = ny * (Z + dz) + (Y + dy)
		H[3] = nx * (Z + dz) + X+dx
		H[4] = Z + dz
		H[5] = nx * (Y + dy) + X+dx
		H[6] = Y + dy
		H[7] = X + dx
		H[8] = PV(0)

		for (i in 1:length(w)) if (w[i] > 0) {
			off = Margin[[w[i]]]$POffset
			noff = Margin[[w[i]]]$PSize + H[i]
			Margin[[w[i]]]$PSize <<- Margin[[w[i]]]$PSize + SideSize[i]
			v = ToC(noff - off,float=F);
			if (v != "   0") { ?>
	pocket.<?%s Margin[[w[i]]]$name ?> += <?%s v ?>; <?R
			}
			Margin[[w[i]]]$POffset <<- noff;
		}
		p = rep("ItCannotHappen",length(w))
		p[w > 0] = paste("pocket.", sapply(Margin[w],function(x) x$name), "", sep="")
		pushZ(
			p[1],
			p[2],
			p[3],
			p[4],
			p[5],
			p[6],
			p[7],
			p[8],
			dx, dy, dz,...);
	} 

	popX = function(dens,a,b,dx) {
		if (dx > 0) { ?>
			if (node.x >= nx - <?%d dx ?>) {
				node.<?%s dens ?> = <?%s b ?>;
			} else {
				node.<?%s dens ?> = <?%s a ?>;
			} <?R
		} else if (dx < 0) { ?>
			if (node.x < <?%d -dx ?>) {
				node.<?%s dens ?> = <?%s b ?>;
			} else {
				node.<?%s dens ?> = <?%s a ?>;
			} <?R
		} else { ?>
			node.<?%s dens ?> = <?%s a ?>; <?R
		}
	}

	popY = function(dens,a,b,c,d,dx,dy) {
		if (dy > 0) { ?>
		if (node.y  >= ny - <?%d dy ?>) { <?R
		}
		if (dy < 0) { ?>
		if (node.y  < <?%d -dy ?>) { <?R
		}
		if (dy != 0) {
			popX(dens, c, d, dx) ?>
		} else { <?R
		} 
		popX(dens, a, b, dx)
		if (dy != 0) { ?>
		} <?R
		}
	} 

	popZ = function(dens,a,b,c,d,e,f,g,h,dx,dy,dz) {
		if (dz > 0) { ?>
	if (node.z  >= nz - <?%d dz ?>) { <?R
		}
		if (dz < 0) { ?>
	if (node.z  < <?%d -dz ?>) { <?R
		}
		if (dz != 0) {
			popY(dens, e, f, g, h, dx, dy) ?>
	} else { <?R
		} 
		popY(dens, a, b, c, d, dx, dy)
		if (dz != 0) { ?>
	} <?R
		}
	}

	pop = function(dens,dx,dy,dz) { ?>
//----------------------------- GETTING <?%s dens ?> FROM DIRECTION: (<?%2d dx ?>,<?%2d dy ?>,<?%2d dz ?>) ----------------------------------------------//
//	CudaSyncThreads(); <?R
		w = GetMargins(dx,dy,dz);
		dx = -dx
		dy = -dy
		dz = -dz
		p = rep("ItCannotHappen",length(w))
		p[w > 0] = paste("pocket.", sapply(Margin[w],function(x) x$name), "[0]", sep="")
		popZ(	dens,
			p[1],
			p[2],
			p[3],
			p[4],
			p[5],
			p[6],
			p[7],
			p[8],
			dx,dy,dz)
		cat("\n")
		for (j in 1:length(w)) {
			i = w[j];
			if (i != 0) {
				?>	pocket.<?%s Margin[[i]]$name?> += <?R C(SideSize[j],float=F) ?>;
<?R			}
		}
	} 

	InOut = function(type, pocket, density) { ?>
	FTabs pocket = <?%s pocket ?>; <?R
		pull=F
		if ((type == "push") || (type == "pull")) {
			if (type == "pull") pull=T
			for ( i in 1:length(Margin) ) Margin[[i]]$POffset <<- PV(0)
			for ( i in 1:length(Margin) ) Margin[[i]]$PSize <<- PV(0)
			gdens = ""
			for (d in rows(density)) {
				push(d$name, d$dx, d$dy, d$dz, pull=pull)
			}
		} else if (type == "pop") { ?>
	node.NodeType = NodeType[(node.x + nx*node.y + nx*ny*node.z)]; <?R
			for (m in NonEmptyMargin) {
				v = ToC(m$Offset,float=F);
				if (v != "") { ?>
	pocket.<?%s m$name ?> += <?%s v ?>; <?R
				}
			}
			for (d in rows(density)) {
				pop(d$name, d$dx, d$dy, d$dz)
			}
		} else {
			stop("Unknown type in InOut");
		}
	}
?>


template <class N> CudaDeviceFunction void LatticeContainer::push(N & node) 
{
<?R	InOut("push", "out", Density); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pull(N & node) 
{
<?R	InOut("pull", "out", Density); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pop(N & node) 
{
<?R	InOut("pop", "in", Density); ?>
}

#ifdef ADJOINT
template <class N> CudaDeviceFunction void LatticeContainer::push_adj(N & node) 
{
<?R	InOut("push", "adjout", DensityAD); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pull_adj(N & node) 
{
<?R	InOut("pull", "adjout", DensityAD); ?>
}

template <class N> CudaDeviceFunction void LatticeContainer::pop_adj(N & node) 
{
<?R	InOut("pop", "in", DensityAD); ?>
}
#endif

CudaDeviceFunction void inline LatticeContainer::Glob(Node now) {}

CudaDeviceFunction void inline LatticeContainer::Glob(Node_Globs now) {
<?R for (i in 1:nrow(Globals)) { v=Globals$name[i]  ?>
        atomicSum(&Globals[<?%d i-1 ?>], now.<?%s v ?>);
//        atomicSum(&Globals[<?%d i-1 ?>], <?%d i ?>.0);
<?R } ?>
}



CudaDeviceFunction CudaConstantMemory LatticeContainer constContainer;

template <class N> inline CudaDeviceFunction void RunElement(N& now)
{
        constContainer.pop(now);
	#ifdef ADJOINT
	        constContainer.pop_adj(now);
		now.RunAdj();
		real_t back[<?%d nrow(Density) ?>]; <?R
			for (i in 1:nrow(Density))
			{ ?>
		back[<?%d i-1 ?>] = now.<?%s Density$name[i] ?>; <?R
			} ?>
		now.Run_b(); <?R
			for (i in 1:nrow(Density))
			{ ?>
		now.<?%s Density$name[i] ?> = back[<?%d i-1 ?>]; <?R
			} ?>
	#endif
	now.Run();
        constContainer.push(now);
}

template <class N> CudaGlobalFunction void RunKernel()
{
	N now;
	now.x = CudaThread.x+CudaBlock.z*CudaNumberOfThreads.x+constContainer.dx;
	now.y = CudaThread.y+CudaBlock.x*CudaNumberOfThreads.y+constContainer.dy;
	now.z = CudaBlock.y+constContainer.dz;
	#ifndef GRID_3D
		for (; now.x < constContainer.nx; now.x += CudaNumberOfThreads.x) {
	#endif
		now.Pre();
		if (now.y < constContainer.fy) {
			RunElement(now);
		}
		constContainer.Glob(now);		
	#ifndef GRID_3D
		}
	#endif
}


<?R if (any(DensityAll$dz != 0)) {?>
#define BORDER_Z // The model is 3D
<?R } else { ?>
// The model is 2D (no BORDER_Z)
<?R } ?>


template <class N> CudaGlobalFunction void RunBorderKernel()
{
	N now;
	now.x = CudaThread.x + CudaBlock.y*DXSDIM;
	now.z = CudaBlock.x;
	now.Pre();
#ifdef BORDER_Z
	if (now.z < constContainer.nz) {
#endif
		now.y = 0;
		RunElement(now);
#ifdef BORDER_Z
	}
#endif
	constContainer.Glob(now);
	now.Pre();
#ifdef BORDER_Z
	if (now.z < constContainer.nz) {
#endif
		now.y = constContainer.ny - 1;
		RunElement(now);
#ifdef BORDER_Z
	}
#endif
	constContainer.Glob(now);
	now.Pre();
#ifdef BORDER_Z
	now.y = CudaBlock.x;
	if ((now.y < constContainer.ny-1) && (now.y > 0)) {
		now.z = 0;
                RunElement(now);
	}
	constContainer.Glob(now);
	now.Pre();
	if ((now.y < constContainer.ny-1) && (now.y > 0)) {
                now.z = constContainer.nz - 1;
                RunElement(now);
	}
	constContainer.Glob(now);
#endif
}

void LatticeContainer::CopyToConst() {
    fx=nx;
    fy=ny-1;
    dx = 0; dy = 1; 
    #ifdef BORDER_Z
	dz = 1;
	fz = nz - 1;
    #else
	dz = 0;
	fz = nz;
    #endif
    CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));
}

template <class N> inline void LatticeContainer::RunBorderT(CudaStream_t borderStream) {
    #ifdef BORDER_Z
	    CudaKernelRunNoWait( RunBorderKernel<N> , dim3(max(ny,nz),kx,1) , dim3(XSDIM),(),borderStream);
    #else
	    CudaKernelRunNoWait( RunBorderKernel<N> , dim3(nz,kx,1) , dim3(XSDIM),(),borderStream);
    #endif
};

void LatticeContainer::RunBorderG(CudaStream_t borderStream) { clearGlobals(); RunBorderT<Node_Globs>(borderStream); };
void LatticeContainer::RunBorder (CudaStream_t borderStream) {                 RunBorderT<Node      >(borderStream); };

template <class N> inline void LatticeContainer::RunInteriorT(CudaStream_t interiorStream) {
    int nnz;
    #ifdef BORDER_Z
	nnz = nz - 2;
    #else
	nnz = nz;
    #endif
    #ifdef GRID_3D
        CudaKernelRunNoWait( RunKernel<N> , dim3(ky, nnz, kx) , dim3(XSDIM,YSDIM),(),interiorStream);
    #else
        CudaKernelRunNoWait( RunKernel<N> , dim3(ky, nnz, 1) , dim3(XSDIM,YSDIM),(),interiorStream);
    #endif
};

void LatticeContainer::RunInteriorG(CudaStream_t interiorStream) { RunInteriorT<Node_Globs>(interiorStream); };
void LatticeContainer::RunInterior (CudaStream_t interiorStream) { RunInteriorT<Node      >(interiorStream); };

CudaDeviceFunction void node_to_color( int x, int y, uchar4 *optr )
{
    int offset = x+y*constContainer.nx;//constContainer.Offset(_z_);
    float l=0.0; float w=0.0;
    int r=0,g=0,b=0;
    Node now;
    now.x = x;
    now.y = y;
    now.z = 0;
    constContainer.pull(now);
    {
     float2 v = now.Color();
     l = v.x;
     w = v.y;
    }

    l = l * 111;
    if (               (l <-111)) {r = 255; g = 255; b = 255; }
    if ((l >= -111) && (l < -11)) {r = 255*(-l-11)/100; g = 255; b = 255; }
    if ((l >=  -11) && (l <  -1)) {r = 0; g = (255*(-l-1))/10; b = 255; }
    if ((l >=   -1) && (l <   0)) {r = 0; g = 0; b = 255*(-l); }
    if ((l >=    0) && (l <   1)) {r = 255*l; g = 0; b = 0; }
    if ((l >=    1) && (l <  11)) {r = 255; g = 255*(l-1)/10; b = 0; }
    if ((l >=   11) && (l < 111)) {r = 255; g = 255; b = 255*(l-11)/100; }
    if ((l >=  111)             ) {r = 255; g = 255; b = 255; }
    r=r*w;
    g=g*w + (1-w)*255;
    b=b*w;
  
    optr[offset].x = r;  
    optr[offset].y = g;  
    optr[offset].z = b;  
    optr[offset].w = 255;
}

CudaGlobalFunction void nodes_to_color( uchar4 *optr )
{
  node_to_color(
    CudaThread.x+CudaBlock.x*CudaNumberOfThreads.x,
    CudaBlock.y,
    optr
  );
}

CudaGlobalFunction void nodes_fill( int width, int height) {
	Node now;
	now.x = CudaThread.x+CudaBlock.z*CudaNumberOfThreads.x+constContainer.dx;
	now.y = CudaThread.y+CudaBlock.x*CudaNumberOfThreads.y+constContainer.dy;
	now.z = CudaBlock.y+constContainer.dz;
	if (now.y < constContainer.fy) {
		#ifndef GRID_3D
			for (; now.x < constContainer.nx; now.x += CudaNumberOfThreads.x) {
		#endif
		constContainer.pop(now);
	        now.Init();
		constContainer.push(now);
		#ifndef GRID_3D
			}
		#endif
	}
}

void LatticeContainer::Init() {
   printf("[%d] Initializing Lattice %d(%d)x%dx%d...\n", D_MPI_RANK,nx,kx,ny,nz); 
	dx=dy=dz=0;
	fx=nx;fy=ny;fz=nz;
   CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));	
   CudaKernelRun( nodes_fill , dim3(ny,nz,1), dim3(XSDIM) ,(nx,ny));
//   CudaKernelRun( nodes_fill_o , dim3(ny,nz,1), dim3(XSDIM) ,(nx,ny));
};

void LatticeContainer::Color( uchar4 *optr ) {
   dx=dy=dz=0;
   fx=nx;fy=ny;fz=nz;
   CudaCopyToConstant("constContainer", constContainer, this, sizeof(LatticeContainer));	
   CudaKernelRun( nodes_to_color , dim3(kx,ny,1), dim3(XSDIM) ,(optr));
};

inline CudaDeviceFunction void LatticeContainer::popXYZ(Node & node,int x_, int y_, int z_) 
{
	node.x=x_;
	node.y=y_;
	node.z=z_;
	pop(node);
}
<?R #popfunction() ?>

<?R
for (i in 1:nrow(Quantities))
{
	q = Quantities[i,,drop=F];
	ifdef(q$adjoint); ?>

CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale)
{
	int x = CudaBlock.x+r.dx;
	int y = CudaBlock.y+r.dy;
	Node now; int z;
	for (z = r.dz; z < r.dz + r.nz; z ++) {
		now.x = x;
		now.y = y;
		now.z = z;
		constContainer.pull(now);
		<?%s q$type ?> w = now.get<?%s q$name ?>(); <?R
		if (q$type == "vector_t")
		{
		  for (coef in c("x","y","z")) { ?>
			w.<?%s coef ?> *= scale; <?R
		  }
		} else { ?>
			w *= scale;
		<?R } ?>
		tab[r.offset(x,y,z)] = w;
	}
} <?R
	for (tp in c("float","double"))
	{ ?>

CudaGlobalFunction void get<?%s q$name ?>_<?%s tp ?>(lbRegion r, <?%s tp ?> * tab, int row)
{
	int x = CudaBlock.x+r.dx;
	int y = CudaBlock.y+r.dy;
	Node now; int z;
	for (z = r.dz; z < r.dz + r.nz; z ++) {
		now.x = x;
                now.y = y;
                now.z = z;
		constContainer.pull(now);
		<?%s q$type ?> w = now.get<?%s q$name ?>(); <?R
		if (q$type == "vector_t")
		{ ?>
		if (row == 0) { <?R
			for (j in 1:3)
			{
				coef = c("x","y","z")[j] ?>
			tab[3*r.offset(x,y,z) + <?%d j-1 ?>] = w.<?%s coef ?>; <?R
			} ?>
		} else { <?R
			for (j in 1:3)
			{
				coef = c("x","y","z")[j] ?>
			tab[r.offset(x,y,z) + r.size()*<?%d j-1 ?>] = w.<?%s coef ?>; <?R
			} ?>
		} <?R
		} else { ?>
		tab[r.offset(x,y,z)] = w; <?R
		} ?>
	}
}
<?R
	}
}
 ifdef();?>

