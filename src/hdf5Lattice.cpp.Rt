<?R
	source("conf.R")
	c_header();
?>
#include <stdio.h>
#include <assert.h>
#include <mpi.h>
#include "cross.h"
#include "hdf5Lattice.h"
#include "Global.h"
#include "glue.hpp"

#ifdef WITH_HDF5
	#include <hdf5.h>
#endif

/*
char xdmf_string[STRING_LEN*10];

void xdmf_str_val(char* str, double val) { sprintf(str, "%lf", val); }
void xdmf_str_val(char* str, float val) { sprintf(str, "%f", val); }
void xdmf_str_val(char* str, int val) { sprintf(str, "%d", val); }
void xdmf_str_val(char* str, long int val) { sprintf(str, "%ld", val); }
void xdmf_str_val(char* str, long long int val) { sprintf(str, "%lld", val); }
void xdmf_str_val(char* str, unsigned long long int val) { sprintf(str, "%llu", val); }
void xdmf_str_val(char* str, char* val) { sprintf(str, "%s", val); }

template <typename T>
void xdmf_str_val(char* str, int len, T* tab, char sep) {
	for (int i=0; i<len; i++) {
		xdmf_str_val(str, tab[i]);
		if (i == len - 1) break;
		str += strlen(str);
		str[0] = sep;
		str++;
	}
}

template <typename T>
char* xdmf_val(int len, T* tab, char sep) {
	xdmf_str_val<T>(xdmf_string, len, tab, sep);
	return xdmf_string;
}

template <typename T>
char* xdmf_val(int len, T* tab) {
	return xdmf_val<T>(len, tab, ' ');
}
*/


std::string NameXPath(const pugi::xml_node& node) {
	std::string path;
	if (node.parent()) {
		path = NameXPath(node.parent());
		path = path + "/" + node.name();
		pugi::xml_attribute attr = node.attribute("Name");
		if (attr) {
			path = path + "[@Name='" + attr.value() + "']";
		}
	}
	return path;
}

int hdf5WriteLattice(const char * nm, Solver * solver, name_set * what, bool write_xdmf)
{
#ifdef WITH_HDF5
	Glue glue;
	Lattice * lattice = solver->lattice;
	UnitEnv * units = &solver->units;
	double unit;

	solver->print("writing hdf5");
	char filename[2*STRING_LEN];
	char * basename;
	solver->outIterCollectiveFile(nm, ".h5", filename);

	basename = filename;
	for (char * n = filename; n[0] != '\0'; n++) {
		if (n[0] == '/') basename = n+1;
	}		

	pugi::xml_document xdmf_doc;
	pugi::xml_node xdmf_main = xdmf_doc.append_child("Xdmf");
	xdmf_main.append_attribute("xmlns:xi") = "http://www.w3.org/2001/XInclude";
	xdmf_main.append_attribute("Version") = "3.0";
	pugi::xml_node xdmf_domain = xdmf_main.append_child("Domain");
	pugi::xml_node xdmf_grid = xdmf_domain.append_child("Grid");
	xdmf_grid.append_attribute("Name") = "Lattice";
	pugi::xml_node xdmf_time = xdmf_grid.append_child("Time");
	unit = units->alt("1s");
	xdmf_time.append_attribute("Value") = solver->iter / unit;
	pugi::xml_node xdmf_geometry = xdmf_grid.append_child("Geometry");
	xdmf_geometry.append_attribute("Origin") = "";
	xdmf_geometry.append_attribute("Type") = "ORIGIN_DXDYDZ";
	pugi::xml_node xdmf_dataitem;
	xdmf_dataitem = xdmf_geometry.append_child("DataItem");
	xdmf_dataitem.append_attribute("DataType") = "Float";
	xdmf_dataitem.append_attribute("Dimensions") = "3";
	xdmf_dataitem.append_attribute("Format") = "XML";
	xdmf_dataitem.append_attribute("Precision") = 8;
	xdmf_dataitem.append_child(pugi::node_pcdata).set_value(glue(" ") << 0 << 0 << 0);
	xdmf_dataitem = xdmf_geometry.append_child("DataItem");
	xdmf_dataitem.append_attribute("DataType") = "Float";
	xdmf_dataitem.append_attribute("Dimensions") = "3";
	xdmf_dataitem.append_attribute("Format") = "XML";
	xdmf_dataitem.append_attribute("Precision") = 8;
	unit = units->alt("1m");
	xdmf_dataitem.append_child(pugi::node_pcdata).set_value(glue(" ") << 1/unit << 1/unit << 1/unit);
	
	size_t size;
	lbRegion reg = lattice->region;
	lbRegion totalreg = lattice->mpi.totalregion;
	size = reg.size();

    hid_t       file_id, dset_id;         /* file and dataset identifiers */
    hsize_t     totaldim[4];                 /* dataset dimensions */
    hsize_t     dim[4];            /* chunk dimensions */
    hsize_t     totalpointdim[4];            /* point dimensions */
    hsize_t	offset[4];
    int         *data;                    /* pointer to data buffer to write */
    hsize_t	ones[4];	         
    int         i;
    herr_t	status;
    hid_t plist_id;

	ones[0] = 1;
	ones[1] = 1;
	ones[2] = 1;
	ones[3] = 1;

    totaldim[0] = totalreg.nz;
    totaldim[1] = totalreg.ny;
    totaldim[2] = totalreg.nx;
    totaldim[3] = 3;
    dim[0] = reg.nz;   
    dim[1] = reg.ny;   
    dim[2] = reg.nx;
    dim[3] = 3;
    offset[0] = reg.dz;
    offset[1] = reg.dy;
    offset[2] = reg.dx;
    offset[3] = 0;

    totalpointdim[0] = totalreg.nz+1;
    totalpointdim[1] = totalreg.ny+1;
    totalpointdim[2] = totalreg.nx+1;


	pugi::xml_node xdmf_topology = xdmf_grid.append_child("Topology");
	xdmf_topology.append_attribute("Dimensions") = glue(" ") << std::make_pair(totalpointdim,3);
	xdmf_topology.append_attribute("Type") = "3DCoRectMesh";

	pugi::xml_node xdmf_attribute;

	debug1("[%2d] %s dim: %lldx%lldx%lld (%lldx%lldx%lld+%lld,%lld,%lld)\n", lattice->mpi.rank,
		filename,
		totaldim[0], totaldim[1], totaldim[2],
		dim[0], dim[1], dim[2],
		offset[0], offset[1], offset[2]);

    MPI_Comm comm  = MPMD.local;
    MPI_Info info  = MPI_INFO_NULL;

	plist_id = H5Pcreate(H5P_FILE_ACCESS);
		H5Pset_fapl_mpio(plist_id, comm, info);
	    	file_id = H5Fcreate(filename, H5F_ACC_TRUNC, H5P_DEFAULT, plist_id);
    	H5Pclose(plist_id);

	<?R for (q in rows(Quantities)) { ifdef(q$adjoint); ?>
	{
		if (what->in("<?%s q$name ?>")) {
			hid_t       filespace, memspace;
			char * fieldname = "<?%s q$name ?>";
			bool vector = <?%s ifelse(q$vector, "true", "false") ?>;
#ifndef CALC_DOUBLE_PRECISION
			hid_t type = H5T_NATIVE_FLOAT;
#else
			hid_t type = H5T_NATIVE_DOUBLE;
#endif
			int rank = 3;
			if (vector) rank = 4;
			filespace = H5Screate_simple(rank, totaldim, NULL); 
			memspace  = H5Screate_simple(rank, dim, NULL); 
			plist_id = H5Pcreate(H5P_DATASET_CREATE);
	                    	dset_id = H5Dcreate(file_id, fieldname, H5T_NATIVE_DOUBLE, filespace, H5P_DEFAULT, plist_id, H5P_DEFAULT);
			H5Pclose(plist_id);

                    	status = H5Sselect_hyperslab(filespace, H5S_SELECT_SET, offset, ones, ones, dim);
                    	if (status < 0) return H5Eprint1(stderr);

			unit = units->alt("<?%s q$unit ?>");
	                <?%s q$type ?>* tmp = new <?%s q$type ?>[size];
                        lattice->Get<?%s q$name ?>(reg, tmp, 1/unit);

			debug0("filespace: %lld memsize: %lld\n", H5Sget_select_npoints(filespace), H5Sget_select_npoints(memspace));
			plist_id = H5Pcreate(H5P_DATASET_XFER);
				H5Pset_dxpl_mpio(plist_id, H5FD_MPIO_COLLECTIVE);
				status = H5Dwrite(dset_id, H5T_NATIVE_DOUBLE, memspace, filespace, plist_id, tmp);
			
			H5Pclose(plist_id);
			H5Sclose(filespace);
			H5Sclose(memspace);
			H5Dclose(dset_id);

			delete[] tmp;
			xdmf_attribute = xdmf_grid.append_child("Attribute");
			xdmf_attribute.append_attribute("Center") = "Cell";
			if (vector) xdmf_attribute.append_attribute("AttributeType") = "Vector";
			xdmf_attribute.append_attribute("Name") = fieldname;
			xdmf_dataitem = xdmf_attribute.append_child("DataItem");
			xdmf_dataitem.append_attribute("DataType") = "Float";
			xdmf_dataitem.append_attribute("Dimensions") = glue(" ") << std::make_pair(totaldim, rank);
			xdmf_dataitem.append_attribute("Format") = "HDF";
			xdmf_dataitem.append_attribute("Precision") = 8;
			xdmf_dataitem.append_child(pugi::node_pcdata).set_value(glue(":") << basename << fieldname);
			std::string xdmf_dataitem_path = NameXPath(xdmf_dataitem);
			xdmf_attribute = xdmf_grid.append_child("Attribute");
			xdmf_attribute.append_attribute("Center") = "Cell";
			if (vector) xdmf_attribute.append_attribute("AttributeType") = "Vector";
			xdmf_attribute.append_attribute("Name") = glue("_") << fieldname << "LB";
			xdmf_dataitem = xdmf_attribute.append_child("DataItem");
			xdmf_dataitem.append_attribute("ItemType") = "Function";
			xdmf_dataitem.append_attribute("Function") = glue(" ") << unit << "*" << "$0";
			xdmf_dataitem.append_attribute("Dimensions") = glue(" ") << std::make_pair(totaldim, rank);
			xdmf_dataitem = xdmf_dataitem.append_child("DataItem");
			xdmf_dataitem.append_attribute("Reference") = xdmf_dataitem_path.c_str();
		}
	}
	<?R }; ifdef(); ?>

	H5Fclose(file_id);


	if (write_xdmf) {
		if (lattice->mpi.rank == 0) {
		    solver->outIterCollectiveFile(nm, ".xmf", filename);
		    xdmf_doc.save_file(filename);
		}
	}

	return 0;
#else
	return -1;
#endif
}