/*-------------------------------------------------------------*/
/*  CLB - Cudne LB - Stencil Version                           */
/*     CUDA based Adjoint Lattice Boltzmann Solver             */
/*     Author: Lukasz Laniewski-Wollk                          */
/*     Developed at: Warsaw University of Technology - 2012    */
/*-------------------------------------------------------------*/
<?R source("conf.R") ?>

#define pi 3.141592653589793116

CudaDeviceFunction real_t getRho(){
	return f[8] + f[7] + f[6] + f[5] + f[4] + f[3] + f[2] + f[1] + f[0] ;
}
    
CudaDeviceFunction real_t getT()
{
	<?R
		g = PV("g[",0:4,"]")
	?>
	return <?R C(sum(g)) ?> ;	//return  g[4] + g[3] + g[2] + g[1] + g[0] ;
}

CudaDeviceFunction vector_t getU(){
	real_t d = f[8] + f[7] + f[6] + f[5] + f[4] + f[3] + f[2] + f[1] + f[0];
	vector_t u;
	u.x = f[8] - f[7] - f[6] + f[5] - f[3] + f[1];
	u.y = -f[8] - f[7] + f[6] + f[5] - f[4] + f[2];

	u.x /= d;
	u.y /= d;
	u.z = 0.0;
	return u;
}



CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}

CudaDeviceFunction void SetEquilibrum(real_t rho, real_t Jx, real_t Jy)
{
f[0] = ( rho*2. + ( -Jy*Jy - Jx*Jx )/rho*3. )*2./9.;
f[1] = ( rho*2. + ( -Jy*Jy/rho + ( 1 + Jx/rho )*Jx*2. )*3. )/18.;
f[2] = ( rho*2. + ( -Jx*Jx/rho + ( 1 + Jy/rho )*Jy*2. )*3. )/18.;
f[3] = ( rho*2. + ( -Jy*Jy/rho + ( -1 + Jx/rho )*Jx*2. )*3. )/18.;
f[4] = ( rho*2. + ( -Jx*Jx/rho + ( -1 + Jy/rho )*Jy*2. )*3. )/18.;
f[5] = ( rho + ( Jy + Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.;
f[6] = ( rho + ( Jy - Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.;
f[7] = ( rho + ( -Jy - Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.;
f[8] = ( rho + ( -Jy + Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.;

}

CudaDeviceFunction void Init() {
	real_t rho, ux, uy;
	rho = (1+Pressure*3);

	ux=0;
	uy=0;
	
	ux = Velocity+ux;

	for (unsigned i = 0; i < 5; ++i)
	{
		g[i] = wt[i] * Temperature;	
	}
	
	SetEquilibrum(
		rho,
		ux*rho,
		uy*rho
	);
}


CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Solid:
	case NODE_Wall:
		BounceBack();
		break;
	case NODE_SWall:
		//BounceBack();
		BounceBack_and_CalcSWallShearForce();	
		break;
	case NODE_NMovingWall:
		NMovingWall();
		break;
		
    }
    if (NodeType & NODE_MRT)
    {
		CollisionMRT();
    }
}

CudaDeviceFunction void BounceBack_and_CalcSWallShearForce()
{
	//real_t SWallShearForce = (f[5]*d2q9_ex[5] + f[6]*d2q9_ex[6]) - (f[7]*d2q9_ex[7] + f[8]*d2q9_ex[8]) ; // wall -> bounce back

	real_t SWallShearForce = - (f[7]*d2q9_ex[7] + f[8]*d2q9_ex[8]) ; //in

	real_t tmp;
	tmp = f[2];
	f[2] = f[4];
	f[4] = tmp;
	tmp = f[1];
	f[1] = f[3];
	f[3] = tmp;
	tmp = f[6];
	f[6] = f[8];
	f[8] = tmp;
	tmp = f[5];
	f[5] = f[7];
	f[7] = tmp;

	tmp = g[2];
	g[2] = g[4];
	g[4] = tmp;
	tmp = g[1];
	g[1] = g[3];
	g[3] = tmp;

	SWallShearForce +=  (f[5]*d2q9_ex[5] + f[6]*d2q9_ex[6]); //out

	AddToSWallForce(SWallShearForce); 
}
CudaDeviceFunction void NMovingWall()
{
	const real_t u[2] = {MovingWallVelocity,0.0};
	real_t rho;

	rho = 1. / (1 + u[1]);
	rho *= (f[0] + f[1] + f[3]) + 2 * (f[2] + f[5] + f[6]);


	f[4] = f[2] - (2. / 3.) * rho*u[1];
	f[7] = f[5] + 0.5*(f[1] - f[3]) - 0.5 * rho*u[0] - (1. / 6.) * rho*u[1];
	f[8] = f[6] + 0.5*(f[3] - f[1]) + 0.5 * rho*u[0] - (1. / 6.) * rho*u[1];


	//TIn[4] = TIn[2];
	g[4] = g[2];


	//real_t NWallShearForce =  (f[7]*d2q9_ex[7] + f[8]*d2q9_ex[8]) - (f[5]*d2q9_ex[5] + f[6]*d2q9_ex[6]); //moving wall
	real_t NWallShearForce = - (f[5]*d2q9_ex[5] + f[6]*d2q9_ex[6]); // in - przed kolizja 
	AddToNMovingWallForce(NWallShearForce);	
}


CudaDeviceFunction void BounceBack()
{
	real_t tmp;
	tmp = f[2];
	f[2] = f[4];
	f[4] = tmp;
	tmp = f[1];
	f[1] = f[3];
	f[3] = tmp;
	tmp = f[6];
	f[6] = f[8];
	f[8] = tmp;
	tmp = f[5];
	f[5] = f[7];
	f[7] = tmp;

	tmp = g[2];
	g[2] = g[4];
	g[4] = tmp;
	tmp = g[1];
	g[1] = g[3];
	g[3] = tmp;
}



CudaDeviceFunction void CollisionMRT()
{
	real_t geq[5];
	real_t feq[9];

	real_t eu;
	real_t rho = getRho();
	vector_t u = getU();

	//double u2 = u.dot(u);
	real_t u2 = u.x*u.x+u.y*u.y;
	for (unsigned i = 0; i < 9; ++i)
	{
		eu = u.x*d2q9_ex[i] + u.y*d2q9_ey[i];

		feq[i] = 1 + 3 * eu;
		feq[i] += 4.5 * eu*eu;
		feq[i] -= 1.5 * u2;
		feq[i] *= rho * wf[i];
	}


	real_t T = getT();
	for (unsigned i = 0; i < 5; ++i)
	{
		eu = u.x*d2q5_ex[i] + u.y*d2q5_ey[i];

		geq[i] = 1 + 3 * eu;
		geq[i] *= T * wt[i];
	}


	for (unsigned i = 0; i < 9; ++i)
	{	
		f[i] = (1. - omega)* f[i] + omega* feq[i]; 
	}

	for (unsigned i = 0; i < 5; ++i)
	{
		g[i] = (1. - omegaT)* g[i] + omegaT* geq[i];
	}

	
	AddToTotalTempSqr(T*T);

    if ((NodeType & NODE_BOUNDARY) == NODE_NMovingWall)
    {
		AddToNMovingWallForce(f[7]*d2q9_ex[7] + f[8]*d2q9_ex[8]);	// out - po kolozji
    }

	//AddToNMovingWallForce(1.0);
	//AddToTotalTempSqr(1.0);
}

