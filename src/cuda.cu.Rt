<?R
        source("conf.R")
	c_header()
?>
/** \file cuda.cu
        Main CUDA C file
        Here is nearly all of the CUDA C code. It includes:
          LatticeContainer.h
          LatticeContainer.c
          Dynamics.c
          Dynamics.h
          Dynamics_b.c (adjoint)
          Dynamics_adj.c (adjoint)
          ADTools.c (adjoint)
*/

<?R

if (exists('Extra_Dynamics_C_Header')) {
	cat(Extra_Dynamics_C_Header)
}
?>

#include "Consts.h"
#include "cross.h"
#include "cross.hpp"
#include "Global.h"


class Node;
class Node_Globs;

#include "LatticeContainer.h"
CudaDeviceFunction CudaConstantMemory LatticeContainer constContainer;

#ifdef ADJOINT
	#include "ADTools.cu"
#endif

<?R
	for (v in rows(Settings)) { ?>
/// GPU Constant memory variable for [<?%s v$comment?>]
CudaDeviceFunction CudaConstantMemory real_t <?%s v$name ?> = 0.0f; <?R
        }
?>

#include "LatticeAccess.inc.cpp"


#include "Particle.hpp"

<?R	for (n in rows(NodeTypes)) {	?>
#define Iam<?%s n$name ?> ((NodeType & NODE_<?%s n$group?>) == NODE_<?%s n$name ?>)
<?R	}	?>
<?R	for (n in names(Node_Group)) {	?>
#define Iam<?%s n ?> (NodeType & NODE_<?%s n ?>)
<?R	}	?>

template <eCalculateGlobals G>
struct CalculateGlobals {};

template <>
struct CalculateGlobals<NoGlobals> {
	template <int I>
	CudaDeviceFunction inline void AddToGlobal(const real_t& x, const flag_t& NodeType) {}
	template <int I>
	CudaDeviceFunction inline void MaxToGlobal(const real_t& x, const flag_t& NodeType) {}
	CudaDeviceFunction void inline Glob() {}
};

template <>
struct CalculateGlobals<IntegrateGlobals> {
	real_t globals[GLOBALS];
	CudaDeviceFunction CalculateGlobals() {
		for (int i=0; i<GLOBALS; i++) {
            globals[i] = 0.0;
		}
	}
	template <int I>
	CudaDeviceFunction inline void AddToGlobal(const real_t& x, const flag_t& NodeType) {
		globals[I] = globals[I] + x;
		if (I < SUM_GLOBALS) {
			globals[GLOBALS_Objective] = globals[GLOBALS_Objective] + constContainer.ZoneSetting(I + IN_OBJ_OFFSET, NodeType >> ZONE_SHIFT);
		}
	}
	template <int I>
	CudaDeviceFunction inline void MaxToGlobal(const real_t& x, const flag_t& NodeType) {
		globals[I] = max(globals[I], x);
	}
	CudaDeviceFunction void inline Glob() {
		for (int i=0; i<GLOBALS; i++) {
			if (i < SUM_GLOBALS) {
            	CudaAtomicAddReduceWarp(&constContainer.Globals[i], globals[i]);
			} else {
				CudaAtomicMaxReduceWarp(&constContainer.Globals[i], globals[i]);
			}
		}
	}
};

template <>
struct CalculateGlobals<OnlyObjective> {
	real_t obj;
	CudaDeviceFunction CalculateGlobals() {
		obj = 0.0;
	}
	template <int I>
	CudaDeviceFunction inline void AddToGlobal(const real_t& x, const flag_t& NodeType) {
		if (I < SUM_GLOBALS) {
			obj = obj + constContainer.ZoneSetting(I + IN_OBJ_OFFSET, NodeType >> ZONE_SHIFT);
		}
	}
	template <int I>
	CudaDeviceFunction inline void MaxToGlobal(const real_t& x, const flag_t& NodeType) {}
	CudaDeviceFunction void inline Glob() {
        CudaAtomicAddReduceWarp(&constContainer.Globals[GLOBALS_Objective], obj);		
	}
};

struct CalculateGlobalsAdjoint {
	real_t duals[ZONESETTINGS];
	real_t duals_dt[ZONESETTINGS];
	CudaDeviceFunction CalculateGlobalsAdjoint() {
		for (int i=0; i<ZONESETTINGS; i++) {
            duals[i] = 0.0;
			duals_dt[i] = 0.0;
		}
	}
	template <int I>
	CudaDeviceFunction inline real_t& BRef() { return duals[I]; }
	template <int I>
	CudaDeviceFunction inline real_t& DTBRef() { return duals_dt[I]; }
	CudaDeviceFunction void inline Glob(const flag_t& NodeType) {
        int z = NodeType >> ZONE_SHIFT;
		for (int nz = 0; nz < constContainer.MaxZones; nz++) if (CudaSyncWarpOr(nz == z)) { 
			for (int i=0; i<ZONESETTINGS; i++) {
				real_t val;
				val = (nz == z) ? duals[i] : 0.0f;
    	        CudaAtomicAddReduceWarp(constContainer.ZoneSettingGrad( i , nz), val); 
				val = (nz == z) ? duals_dt[i] : 0.0f;
	            CudaAtomicAddReduceWarp(constContainer.ZoneSettingGrad( i + DT_OFFSET, nz), val); 
			}
		}
	}
};


#define NODE_H


#define GET_MACRO(_1,_2,_3,NAME,...) NAME <?R
        for (f in rows(Fields)) { ?>
#define <?%s f$nicename ?>(...) acc.template load_<?%s f$nicename ?>< __VA_ARGS__ >()
#define <?%s f$nicename ?>_dyn(...) acc.load_<?%s f$nicename ?>(__VA_ARGS__) <?R
        }
?>

#define X (acc.X())
#define Y (acc.Y())
#define Z (acc.Z())
#define NodeType (acc.NodeType())
#define Time (constContainer.iter)
#define SyntheticTurbulence(x__,y__,z__) constContainer.getST(x__,y__,z__)
#define average_iter (constContainer.iter - constContainer.reset_iter)  //Look nicer in Dynamics
<?R
	P = expand.grid(x=0:2,y=0:2,z=0:2)
	Q = paste("Q",P$x,P$y,P$z,sep="")
	for (i in 2:length(Q)) { ?>
#define <?%s Q[i] ?> (acc.getQ(<?%d i-2 ?>)) <?R
	}
	for(s in rows(ZoneSettings)) { ?>
//#define <?%s s$name ?> constContainer.ZoneSettings[<?%s s$Index ?> + ZONESETTINGS * (NodeType >> ZONE_SHIFT)][constContainer.ZoneIndex]
<?R 	if (! s$preload) { ?>
#define <?%s s$name ?> constContainer.ZoneSetting(<?%s s$Index ?>, NodeType >> ZONE_SHIFT)
<?R     } ?>
#define <?%s s$name ?>_DT constContainer.ZoneSetting_DT(<?%s s$Index ?>, NodeType >> ZONE_SHIFT)
<?R
    }

	for (g in rows(Globals)) {
		if (g$op == "SUM") { ?>
#define AddTo<?%s g$name ?>(x__) glob.AddToGlobal< <?%s g$Index ?> >(x__, NodeType) <?R
		} else { ?>
#define AddTo<?%s g$name ?>(x__) glob.MaxToGlobal< <?%s g$Index ?> >(x__, NodeType) <?R
		}
	}
?>


template < class LA, eOperationType I, eCalculateGlobals G, eStage S> struct Node_Run {
        CudaDeviceFunction inline void RunElement(){};
		CudaDeviceFunction inline Node_Run(const LA& acc_) {};
};

<?R
for (tp in rows(Dispatch)) {
	s = Stages[Stages$name == tp$stage_name, ];
#	GlobalsD = Globals[-nrow(Globals),];
	GlobalsD = Globals[,];
	GlobalsD$zonal = FALSE;
	ik = nrow(ZoneSettings);
	if (ik > 0) {
		GlobalsD = do.call(rbind, c(list(GlobalsD),rep(NA,ik)));
		k = nrow(GlobalsD) - ik:1 + 1;
		GlobalsD$name[k] = paste0(ZoneSettings$name,"B");
		GlobalsD$adjoint[k] = TRUE;
		GlobalsD$zonal[k] = TRUE;
		GlobalsD$op[k] = "SUM";
		GlobalsD$var[k] = paste0(ZoneSettings$name,"b");
		GlobalsD$Index[k] = ZoneSettings$Index;

		GlobalsD = do.call(rbind, c(list(GlobalsD),rep(NA,ik)));
		k = nrow(GlobalsD) - ik:1 + 1;
		GlobalsD$name[k] = paste0(ZoneSettings$name,"_DTB");
		GlobalsD$adjoint[k] = TRUE;
		GlobalsD$zonal[k] = TRUE;
		GlobalsD$op[k] = "SUM";
		GlobalsD$var[k] = paste0(ZoneSettings$name,"_DTb");
		GlobalsD$Index[k] = paste0(ZoneSettings$Index,"+DT_OFFSET");
	}
	cat("\n")
	ifdef(tp$adjoint_ver)
	suff=tp$suffix
	       if (tp$Stream == "Adj") {
	        GlobalsD$sel = GlobalsD$adjoint
	} else if (tp$Stream == "Opt") {
	        GlobalsD$sel = TRUE
	} else if (tp$Stream == "Init") {
	        GlobalsD$sel = FALSE
	} else if (tp$Stream == "No") {
	        GlobalsD$sel = ! GlobalsD$adjoint
	} else {
	        stop(paste("Unknown Action:",tp$Stream,"in Dispatch (conf.R)"));
	} ?>
//-------------------[ <?%20s paste("Node",tp$suffix,sep="") ?> --- Action:<?%5s tp$Stream ?>, Globals:<?%5s tp$Globals ?> ]-------------------- <?R
        if (tp$Globals == "Globs") {
                Globs = GlobalsD[GlobalsD$sel,]
        } else if (tp$Globals == "Obj") {
                Globs = Globals[nrow(Globals),]
		Globs$zonal = FALSE
        } else {
                Globs = NULL
        } 	
        T1 = switch(tp$Action, No="Primal", Adj="Adjoint", Opt="Optimize", SAdj="SteadyAdjoint")
        T2 = switch(tp$Globals, No="NoGlobals", Globs="IntegrateGlobals", Obj="OnlyObjective")
        T3 = tp$stage_name
?>
template < class LA > struct Node_Run < LA, <?%s T1 ?>, <?%s T2 ?>, <?%s T3 ?> > {
	const LA& acc;
	CalculateGlobals< <?%s T2 ?> > glob;
<?R
		for(setting in rows(ZoneSettings)) if (setting$preload) { ?>
	real_t <?%s setting$name ?>; <?R
		}
?>
	//CudaDeviceFunction inline Node_Run(int x__,int y__,int z__):x_(x__),y_(y__),z_(z__),NodeType(constContainer.getType(x_,y_,z_)),acc(x_,y_,z_,NodeType) {
	CudaDeviceFunction inline Node_Run(const LA& acc_):acc(acc_) {
		int z = NodeType >> ZONE_SHIFT; <?R
		for(setting in rows(ZoneSettings)) if (setting$preload) { ?>
		<?%s setting$name ?> =  constContainer.ZoneSetting(<?%s setting$Index ?>, z); <?R
		} ?>
	};
	CudaDeviceFunction void inline Glob() {
		glob.Glob();
	}
	<?R
		if (! tp$adjoint) { ?>
	#include "Dynamics.h" <?R
		} else { ?>
	#undef DYNAMICS_B_LOADED <?R
		} ?>
//	#include "Dynamics.h"
#ifdef CALC_DOUBLE_PRECISION
	#include "Dynamics.c"
#else
	#include "Dynamics_sp.c"
#endif <?R
		if (tp$adjoint) {
		        if (tp$Globals == "Globs") { ?>
        #include "DynamicsS_b.c" <?R
                        } else { ?>
        #include "Dynamics_b.c" <?R
                        } ?>
	#include "Dynamics_adj.c" <?R
		}
	if (tp$stage) { ################################################################
		if (tp$Stream == "Opt") { ?>
	CudaDeviceFunction inline void Opt() { <?R
		if ("DesignSpace" %in% NodeTypes$name) { ?>
	        if ((NodeType & NODE_DESIGNSPACE) == NODE_DesignSpace) { <?R
		        for (d in rows(Density)) {
                                if (d$parameter) { ?>
                <?%s d$name ?> += <?%s d$adjoint_name ?>*Descent;
                if (<?%s d$name ?> > 1.0f) <?%s d$name ?> = 1.0f;
                if (<?%s d$name ?> < 0.0f) <?%s d$name ?> = 0.0f; <?R
                                }
                        }?>
                } <?R
		} ?>
        } <?R
	        } ?>


	<?R
	if (tp$Stream == "Adj") {
	        for (d in rows(Density)) if (d$parameter) {
       		        if (tp$Globals == "Globs") { ?>
        real_t old_<?%s d$adjoint_name ?>; <?R
			}
		}
	} ?>

	CudaDeviceFunction inline void LoadElement() {
		<?R
		if (tp$Stream == "Adj") { ?>
		acc.pop_<?%s s$name ?>(*this);
		acc.pop_<?%s s$name ?>_adj(*this);<?R
		        for (d in rows(Density)) if (d$parameter) {
        		        if (tp$Globals == "Globs") { ?>
                old_<?%s d$adjoint_name ?> = <?%s d$adjoint_name ?>; <?R
                                }
	                        if (tp$zeropar) { ?>
                <?%s d$adjoint_name ?> = 0.0f; <?R
                                }
                        }
		} else if (tp$Stream == "Opt") { ?>
		acc.pop_param(*this);
		acc.pop_param_adj(*this); <?R
		} else if (tp$Stream == "Init") {
		} else if (tp$Stream == "No") { ?>
	        acc.pop_<?%s s$name ?>(*this); <?R
		} else {
		        stop(paste("Unknown Action:",tp$Stream,"in Dispatch (cuda.cu / conf.R)"));
		} ?>
	}
	CudaDeviceFunction inline void SaveElement() {
		<?R
		if (tp$Stream == "Adj") {
		        if (tp$Globals == "Globs") for (d in rows(Density)) if (d$parameter) { ?>
                old_<?%s d$adjoint_name ?> -= <?%s d$adjoint_name ?>;
                AddToAdjointRes(old_<?%s d$adjoint_name ?>*old_<?%s d$adjoint_name ?>); <?R
                        } ?>
		acc.push_<?%s s$name ?>_adj(*this); <?R
		} else if (tp$Stream == "Opt") { ?>
		acc.push_param(*this); <?R
		} else if (tp$Stream == "Init") { ?>
		acc.push_<?%s s$name ?>(*this); <?R
		} else if (tp$Stream == "No") { ?>
		acc.push_<?%s s$name ?>(*this); <?R
		} else {
		        stop(paste("Unknown Action:",tp$Stream,"in Dispatch (cuda.cu / conf.R)"));
		} ?>
	}
	CudaDeviceFunction inline void ExecElement() {
		<?R
		if (tp$Stream == "Adj") { ?>
		Run_b(); <?R
		} else if (tp$Stream == "Opt") { ?>
		Opt(); <?R
		} else if (tp$Stream == "Init") { ?>
		Init();<?R
		} else if (tp$Stream == "No") { ?>
		<?%s s$main ?>(); <?R
		} else {
		        stop(paste("Unknown Action:",tp$Stream,"in Dispatch (cuda.cu / conf.R)"));
		} ?>
	}
	CudaDeviceFunction inline void RunElement() {
		LoadElement();
		ExecElement();
		SaveElement();
		Glob();
	} <?R
        } ########################################################################################### ?>
}; <?R
} 
cat("\n")
ifdef()
?>


#undef X
#undef Y
#undef Z
#undef NodeType
#undef Time
#undef average_iter


#include "LatticeContainer.inc.cpp"
