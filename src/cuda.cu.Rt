<?R
        source("conf.R")
	c_header()
?>
/** \file cuda.cu
        Main CUDA C file
        Here is nearly all of the CUDA C code. It includes:
          LatticeContainer.h
          LatticeContainer.c
          Dynamics.c
          Dynamics.h
          Dynamics_b.c (adjoint)
          Dynamics_adj.c (adjoint)
          ADTools.c (adjoint)
*/

#include "Consts.h"
#include "cross.h"
#include "Global.h"

class Node;
class Node_Globs;

#include "LatticeContainer.h"
CudaDeviceFunction CudaConstantMemory LatticeContainer constContainer;

#ifdef ADJOINT
	#include "ADTools.cu"
#endif



<?R
        for (f in Fields) { ?>
#define <?%s f$nicename ?>(x__,y__,z__) constContainer.load_<?%s f$nicename ?> < x__, y__, z__ > (x,y,z)
#define <?%s f$nicename ?>(x__,y__) constContainer.load_<?%s f$nicename ?> < x__, y__, 0 > (x,y,z) <?R
        }
?>

<?R for (v in rows(Settings)) { ?>
/// GPU Constant memory variable for [<?%s v$comment?>]
CudaDeviceFunction CudaConstantMemory real_t <?%s v$name ?> = 0.0f; <?R
    } ?>
//CudaConstantMemory real_t c_sq = 1.0/3.;


<?R
	for (tp in rows(Dispatch)) { ?>
//struct Node<?%s tp$suffix ?>; <?R
        } ?>

#include "LatticeAccess.cu"


#define NODE_H

<?R
	for (tp in rows(Dispatch)) {
	s = Stages[Stages$name == tp$stage_name, ]
	cat("\n")
	ifdef(tp$adjoint_ver)
	suff=tp$suffix
	if (tp$Action == "Adj") {
	        GlobalsD$sel = GlobalsD$adjoint
	} else if (tp$Action == "Opt") {
	        GlobalsD$sel = TRUE
	} else if (tp$Action == "Init") {
	        GlobalsD$sel = FALSE
	} else if (tp$Action == "No") {
	        GlobalsD$sel = ! GlobalsD$adjoint
	} else {
	        stop(paste("Unknown Action:",tp$Action,"in Dispatch (conf.R)"));
	} ?>
//-------------------[ <?%20s paste("Node",tp$suffix,sep="") ?> --- Action:<?%5s tp$Action ?>, Globals:<?%5s tp$Globals ?> ]-------------------- <?R
	for (g in rows(GlobalsD)) if (g$sel) {
		if (tp$Globals == "Globs") { ?>
#define AddTo<?%s g$name ?>(x) <?%s g$var ?> = <?%s g$var ?> + (x) <?R
		} else if (tp$Globals == "Obj") { ?>
#define AddTo<?%s g$name ?>(x) Objective = Objective + (x) * <?%s g$name ?>InObj <?R
		} else { ?>
#define AddTo<?%s g$name ?>(x) <?R
		}
	} else { ?>
#define AddTo<?%s g$name ?>(x) <?R
	}
        if (tp$Globals == "Globs") {
                Globs = GlobalsD[GlobalsD$sel,]
        } else if (tp$Globals == "Obj") {
                Globs = Globals[nrow(Globals),]
        } else {
                Globs = NULL
        } 	
?>

/// Node class for dispatch:  Node<?%s suff ?>
/**
        Action:<?%5s tp$Action ?>
        Globals:<?%5s tp$Globals ?>
*/
struct Node<?%s suff ?> {
	int x,y,z; <?R
	for (g in rows(Globs)) { ?>
	real_t <?%s g$var ?>; ///< <?%s g$comment ?><?R
        } ?>
	CudaDeviceFunction void inline Pre() { <?R
	for (g in rows(Globs)) { ?>
		<?%s g$var ?> = 0.0f; <?R
        } ?>
	}
	CudaDeviceFunction void inline Glob() { <?R
        for (g in rows(Globs)) { ?>
		atomicSum(&constContainer.Globals[<?%s g$Index ?>], <?%s g$var ?>); <?R
        } ?>
	} <?R
		if (! tp$adjoint) { ?>
	#include "Dynamics.h" <?R
		} ?>
#ifdef CALC_DOUBLE_PRECISION
	#include "Dynamics.c"
#else
	#include "Dynamics_sp.c"
#endif <?R
		if (tp$adjoint) {
		        if (tp$Globals == "Globs") { ?>
        #include "DynamicsS_b.c" <?R
                        } else { ?>
        #include "Dynamics_b.c" <?R
                        } ?>
	#include "Dynamics_adj.c" <?R
		}
	if (tp$stage) { ################################################################
		if (tp$Action == "Opt") { ?>
	CudaDeviceFunction inline void Opt() {
	        if ((NodeType & NODE_DESIGNSPACE) == NODE_DesignSpace) { <?R
		        for (i in 1:nrow(Density)) {
		                d=Density[i,];
                                da=DensityAD[i,];
                                if (d$parameter) { ?>
                <?%s d$name ?> += <?%s da$name ?>*Descent;
                if (<?%s d$name ?> > 1.0f) <?%s d$name ?> = 1.0f;
                if (<?%s d$name ?> < 0.0f) <?%s d$name ?> = 0.0f; <?R
                                }
                        }?>
                }
        } <?R
	        } ?>
	CudaDeviceFunction inline void RunElement() {
	        constContainer.getType(*this); <?R
		if (tp$Action == "Adj") { ?>
		constContainer.pop_<?%s s$name ?>(*this);
		constContainer.pop_adj_<?%s s$name ?>(*this);<?R
		        for (d in rows(DensityAD)) if (d$parameter) {
        		        if (tp$Globals == "Globs") { ?>
                real_t old_<?%s d$name ?> = <?%s d$name ?>; <?R
                                }
	                        if (tp$zeropar) { ?>
                <?%s d$name ?> = 0.0f; <?R
                                }
                        } ?>
		Run_b(); <?R
		        if (tp$Globals == "Globs") for (d in rows(DensityAD)) if (d$parameter) { ?>
                old_<?%s d$name ?> -= <?%s d$name ?>;
                AddToAdjointRes(old_<?%s d$name ?>*old_<?%s d$name ?>); <?R
                        } ?>
		constContainer.push_adj_<?%s s$name ?>(*this); <?R
		} else if (tp$Action == "Opt") { ?>

                constContainer.pop_<?%s s$name ?>(*this); <?R
		        for (i in 1:nrow(Density)) {
		                d=Density[i,];
                                da=DensityAD[i,];?>
		<?%s da$name ?> = <?%s d$name ?>; <?R
		        } ?>

		<?%s s$main ?>();
		constContainer.push_noparam_<?%s s$name ?>(*this); <?R
		        for (i in 1:nrow(Density)) {
		                d=Density[i,];
                                da=DensityAD[i,];?>
		<?%s d$name ?> = <?%s da$name ?>; <?R
		        } ?>
		constContainer.pop_adj_<?%s s$name ?>(*this); <?R
		        for (d in rows(DensityAD)) if (d$parameter) { ?>
		<?%s d$name ?> = GradientSmooth*<?%s d$name ?>; <?R
		        } ?>
		Run_b(); <?R
		        for (d in rows(DensityAD)) if (d$parameter) { ?>
                <?%s d$name ?> /= 1.+GradientSmooth; <?R
                        } ?>
		constContainer.push_adj_<?%s s$name ?>(*this);
		Opt();
		constContainer.push_param_<?%s s$name ?>(*this); <?R
		} else if (tp$Action == "Init") { ?>
		constContainer.getType(*this);
		Init();
		constContainer.push_<?%s s$name ?>(*this); <?R
		} else if (tp$Action == "No") { ?>
	        constContainer.pop_<?%s s$name ?>(*this); 
		<?%s s$main ?>();
		constContainer.push_<?%s s$name ?>(*this); <?R
		} else {
		        stop(paste("Unknown Action:",tp$Action,"in Dispatch (cuda.cu / conf.R)"));
		} ?>
	} <?R
	} #################################################################################### ?>
}; <?R
	for (g in rows(GlobalsD)) { ?>
#undef AddTo<?%s g$name ?><?R
	}
} 
cat("\n")
ifdef()
?>

#include "LatticeContainer.cu"
