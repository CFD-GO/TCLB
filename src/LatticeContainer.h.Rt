<?R
	source("conf.R");
	c_header()
?>


#ifndef SETTINGS_H
<?R
	for (v in rows(Settings)) { ?>
    CudaExternConstantMemory(real_t <?%s v$name ?>); <?R
	} ?>
    void initSettings();
    void setConstSetting(int i, real_t tmp);

#define SETTINGS_H 1
#endif


#ifndef LATTICECONTAINER_H

#include "Consts.h"

class LatticeContainer {
	public:
  FTabs in;
  FTabs out;
#ifdef ADJOINT
  FTabs adjout;
  FTabs adjin;
#endif
  flag_t * NodeType;
  real_t * Globals;
  int dx, dy, dz;
  int nx, ny, nz;
  int fx, fy, fz;
  int kx,ky;
  int iter;

  void Alloc (int,int,int);
  void Free();
  CudaDeviceFunction void fill();
  template<class N>  CudaDeviceFunction void push(N & f);
  template<class N>  CudaDeviceFunction void push_param(N & f);
  template<class N>  CudaDeviceFunction void push_noparam(N & f);
  template<class N>  CudaDeviceFunction void pull(N & f);
  template<class N>  CudaDeviceFunction void pop(N & f);
  template<class N>  CudaDeviceFunction void getType(N & f);
#ifdef ADJOINT
  template<class N>  CudaDeviceFunction void push_adj(N & f);
  template<class N>  CudaDeviceFunction void pull_adj(N & f);
  template<class N>  CudaDeviceFunction void pop_adj(N & f);
#endif
//  CudaDeviceFunction void Glob(Node);
//  CudaDeviceFunction void Glob(Node_Globs);
//  template<class N>  CudaDeviceFunction void Glob(N & f);
  void Init();
  void Color( uchar4 *optr );
  template<class N> inline void RunBorderT(CudaStream_t);
  template<class N> inline void RunInteriorT(CudaStream_t);
<?R for(tp in rows(Dispatch)) { ?>
  void RunBorder<?%s tp$suffix ?>(CudaStream_t);
  void RunInterior<?%s tp$suffix ?>(CudaStream_t);
<?R } ?>
  void CopyToConst();
  void WaitAll();
  void WaitBorder();

  inline void clearGlobals() {
        CudaMemset(Globals, 0, GLOBALS*sizeof(real_t));
  }

  <?R for (v in rows(Globals)) { ?>
        inline real_t get<?%s v$name ?>(){
                real_t ret;
                CudaMemcpy(&ret, &Globals[<?%s v$Index ?>],sizeof(real_t),cudaMemcpyDeviceToHost);
                return ret;
        }
  <?R } ?>
	inline void getGlobals(real_t * tab) {
                CudaMemcpy(tab, Globals, GLOBALS * sizeof(real_t), cudaMemcpyDeviceToHost);
	}
};

template<class N> CudaGlobalFunction void RunKernel();
CudaGlobalFunction void nodes_to_color( uchar4 *optr);
CudaGlobalFunction void nodes_fill( int width, int height);

<?R
for (q in rows(Quantities)) { ifdef(q$adjoint);
?>
CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale); <?R
	for (tp in c("float","double"))
        { ?>
CudaGlobalFunction void get<?%s q$name ?>_<?%s tp ?>(lbRegion , <?%s tp ?> *, int);
<?R
	}
}
ifdef() ?>

void * BAlloc(size_t size);
void BPreAlloc(void **, size_t size);

#endif
#define LATTICECONTAINER_H 1
