<?R source("conf.R") ?>

#ifndef LATTICECONTAINER_H

#ifdef CROSS_CPU
	#define XSDIM 1
	#define YSDIM 1
	#define DXSDIM 1
#else
	#define XSDIM _xsdim
	#define YSDIM _ysdim
	#define DXSDIM blockDim.x
#endif

#ifdef GRID_3D
	#define X (CudaThread.x+CudaBlock.z*DXSDIM)
	#define Y (CudaBlock.x)
	#define Z (CudaBlock.y)
	#define BLOCKS dim3(region.ny,region.nz,container->kx)
#else
	#define X (CudaThread.x+_z_*DXSDIM)
	#define Y (CudaBlock.x)
	#define Z (CudaBlock.y)
	#define BLOCKS dim3(region.ny,region.nz,1)
#endif
#define THREADS dim3(XSDIM,1)
#define OFFSET (X + nx*Y + nx*ny*Z)

extern int _xsdim;
extern int _ysdim;

class LatticeContainer {
	public:
  FTabs in;
  FTabs out;
  flag_t * NodeType;
  real_t * Globals;
  int dx, dy, dz;
  int nx, ny, nz;
  int fx, fy, fz;
  int kx,ky;
  int iter;

  void Alloc (int,int,int);
  void Free();
  CudaDeviceFunction void fill();
  template<class N>  CudaDeviceFunction void push(N & f);
  template<class N>  CudaDeviceFunction void pop(N & f);
  CudaDeviceFunction void Glob(Node);
  CudaDeviceFunction void Glob(Node_Globs);
  template<class N>  CudaDeviceFunction void Glob(N & f);
  CudaDeviceFunction void popXYZ(Node & f, int, int, int);
  void Init();
  template<class N> inline void RunBorderT(CudaStream_t);
  template<class N> inline void RunInteriorT(CudaStream_t);
  void RunBorderG(CudaStream_t);
  void RunBorder (CudaStream_t);
  void RunInteriorG(CudaStream_t);
  void RunInterior (CudaStream_t);
  void CopyToConst();
  void WaitAll();
  void WaitBorder();
  CudaDeviceFunction inline int Offset(int _z_)
  {
          return OFFSET;
  };


  inline void clearGlobals() {
        CudaMemset(Globals, 0, <?%d nrow(Globals) ?>*sizeof(real_t));
  }

  <?R for (i in 1:nrow(Globals)) { v=Globals$name[i]; ?>
        inline real_t get<?%s v ?>(){
                real_t ret;
                CudaMemcpy(&ret, &Globals[<?%d i-1 ?>],sizeof(real_t),cudaMemcpyDeviceToHost);
                return ret;
        }
  <?R } ?>
	inline void getGlobals(real_t * tab) {
                CudaMemcpy(tab, Globals, <?%d nrow(Globals) ?>*sizeof(real_t), cudaMemcpyDeviceToHost);
	}
};

template<class N> CudaGlobalFunction void RunKernel();
CudaGlobalFunction void nodes_to_color( uchar4 *optr);
CudaGlobalFunction void nodes_fill( int width, int height);

<?R
for (i in 1:nrow(Quantities))
{
	q = Quantities[i,,drop=F];
	ifdef(q$adjoint);
?>
CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale); <?R
	for (tp in c("float","double"))
        { ?>
CudaGlobalFunction void get<?%s q$name ?>_<?%s tp ?>(lbRegion , <?%s tp ?> *, int);
<?R
	}
}
ifdef() ?>

#endif
#define LATTICECONTAINER_H 1
