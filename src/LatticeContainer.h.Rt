<?R
	source("conf.R");
	c_header()
?>
/** \file LatticeContainer.h
  File defining LatticeContainer and some additional CUDA functions
*/

#ifndef SETTINGS_H
<?R
	for (v in rows(Settings)) { ?>
    CudaExternConstantMemory(real_t <?%s v$name ?>); <?R
	} ?>
    void initSettings();
    void setConstSetting(int i, real_t tmp);

#define SETTINGS_H 1
#endif


#ifndef LATTICECONTAINER_H

#include "Consts.h"

/// Container class used for storing all the data needed on GPU
/**
  Main class for storing the data needed on GPU and running kernels.
  LatticeContainer is the container class which
  owns all the data needed by the kernels on device
  like pointers to the global gpu memory etc.
  It defines push/pull/pop functions allowing access
  to node data stored in memory.
*/
class LatticeContainer {
	public:
  FTabs in; ///< Main FTabs used for Primal iteration as input
  FTabs out; ///< Main FTabs used for Primal iteration as output
#ifdef ADJOINT
  FTabs adjout; ///< FTabs used for Adjoint iteration as output
  FTabs adjin; ///< FTabs used for Adjoint iteration as input
#endif
  flag_t * NodeType; ///< Table of flags/NodeTypes of all the nodes
  real_t * Globals; ///< Pointer to the GPU table to store the calculated values of Globals
  int dx, dy, dz; ///< Offset of the region to calculate in the interior kernel run
  int nx, ny, nz; ///< Size of the Lattice region
  int fx, fy, fz; ///< End of the region to calculate in the interior kernel run
  int kx,ky; ///< X and Y thread division
  int iter; ///< Iteration number

  void Alloc (int,int,int);
  void Free();
  CudaDeviceFunction void fill();
  template<class N>  CudaDeviceFunction void push(N & f);
  template<class N>  CudaDeviceFunction void push_param(N & f);
  template<class N>  CudaDeviceFunction void push_noparam(N & f);
  template<class N>  CudaDeviceFunction void pull(N & f);
  template<class N>  CudaDeviceFunction void pop(N & f);
  template<class N>  CudaDeviceFunction void getType(N & f);
#ifdef ADJOINT
  template<class N>  CudaDeviceFunction void push_adj(N & f);
  template<class N>  CudaDeviceFunction void pull_adj(N & f);
  template<class N>  CudaDeviceFunction void pop_adj(N & f);
#endif

//  template <class N> CudaDeviceFunction void pop_new(N & node); <?R
  for (f in Fields) { ?>
  template <int dx, int dy, int dz>
  CudaDeviceFunction real_t& load_<?%s f$nicename ?> (const int & x, const int & y, const int & z); <?R
  } ?>
//  template <class N> CudaDeviceFunction void push_new(N & node);


  void Color( uchar4 *optr );
  template<class N> inline void RunBorderT(CudaStream_t);
  template<class N> inline void RunInteriorT(CudaStream_t);
<?R for(tp in rows(Dispatch)) { ?>
  void RunBorder<?%s tp$suffix ?>(CudaStream_t);
  void RunInterior<?%s tp$suffix ?>(CudaStream_t);
<?R } ?>
  void CopyToConst();
  void WaitAll();
  void WaitBorder();

  inline void clearGlobals() {
        CudaMemset(Globals, 0, GLOBALS*sizeof(real_t));
  }

  <?R for (v in rows(Globals)) { ?>
/// Get [<?%s v$comment ?>] from GPU memory
        inline real_t get<?%s v$name ?>(){
                real_t ret;
                CudaMemcpy(&ret, &Globals[<?%s v$Index ?>],sizeof(real_t),cudaMemcpyDeviceToHost);
                return ret;
        }
  <?R } ?>
/// Get all the globals from GPU memory
	inline void getGlobals(real_t * tab) {
                CudaMemcpy(tab, Globals, GLOBALS * sizeof(real_t), cudaMemcpyDeviceToHost);
	}
};

template<class N> CudaGlobalFunction void RunKernel();
CudaGlobalFunction void ColorKernel( uchar4 *optr);

<?R
for (q in rows(Quantities)) { ifdef(q$adjoint);
?>
CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale); <?R
	for (tp in c("float","double"))
        { ?>
CudaGlobalFunction void get<?%s q$name ?>_<?%s tp ?>(lbRegion , <?%s tp ?> *, int);
<?R
	}
}
ifdef() ?>

void * BAlloc(size_t size);
void BPreAlloc(void **, size_t size);

#endif
#define LATTICECONTAINER_H 1
