<?R
	source("conf.R");
	c_header()
?>

#ifndef LATTICECONTAINER_H

#include "Consts.h"

#ifdef CROSS_CPU
	#define XSDIM 1
	#define YSDIM 1
	#define DXSDIM 1
#else
	#define XSDIM _xsdim
	#define YSDIM _ysdim
	#define DXSDIM blockDim.x
#endif

#ifdef GRID_3D
//	#define X (CudaThread.x+CudaBlock.z*DXSDIM)
//	#define Y (CudaBlock.x)
//	#define Z (CudaBlock.y)
	#define BLOCKS dim3(region.ny,region.nz,container->kx)
#else
//	#define X (CudaThread.x+_z_*DXSDIM)
//	#define Y (CudaBlock.x)
//	#define Z (CudaBlock.y)
	#define BLOCKS dim3(region.ny,region.nz,1)
#endif
#define THREADS dim3(XSDIM,1)
//#define OFFSET (X + nx*Y + nx*ny*Z)

extern int _xsdim;
extern int _ysdim;

class LatticeContainer {
	public:
  FTabs in;
  FTabs out;
#ifdef ADJOINT
  FTabs adjout;
  FTabs adjin;
#endif
  flag_t * NodeType;
  real_t * Globals;
  int dx, dy, dz;
  int nx, ny, nz;
  int fx, fy, fz;
  int kx,ky;
  int iter;

  void Alloc (int,int,int);
  void Free();
  CudaDeviceFunction void fill();
  template<class N>  CudaDeviceFunction void push(N & f);
  template<class N>  CudaDeviceFunction void pull(N & f);
  template<class N>  CudaDeviceFunction void pop(N & f);
  template<class N>  CudaDeviceFunction void getType(N & f);
#ifdef ADJOINT
  template<class N>  CudaDeviceFunction void push_adj(N & f);
  template<class N>  CudaDeviceFunction void pull_adj(N & f);
  template<class N>  CudaDeviceFunction void pop_adj(N & f);
#endif
//  CudaDeviceFunction void Glob(Node);
//  CudaDeviceFunction void Glob(Node_Globs);
//  template<class N>  CudaDeviceFunction void Glob(N & f);
  void Init();
  void Color( uchar4 *optr );
  template<class N> inline void RunBorderT(CudaStream_t);
  template<class N> inline void RunInteriorT(CudaStream_t);
<?R for(tp in rows(Dispatch)) { ?>
  void RunBorder<?%s tp$suffix ?>(CudaStream_t);
  void RunInterior<?%s tp$suffix ?>(CudaStream_t);
<?R } ?>
  void CopyToConst();
  void WaitAll();
  void WaitBorder();

  inline void clearGlobals() {
        CudaMemset(Globals, 0, GLOBALS*sizeof(real_t));
  }

  <?R for (v in rows(Globals)) { ?>
        inline real_t get<?%s v$name ?>(){
                real_t ret;
                CudaMemcpy(&ret, &Globals[<?%s v$Index ?>],sizeof(real_t),cudaMemcpyDeviceToHost);
                return ret;
        }
  <?R } ?>
	inline void getGlobals(real_t * tab) {
                CudaMemcpy(tab, Globals, GLOBALS * sizeof(real_t), cudaMemcpyDeviceToHost);
	}
};

template<class N> CudaGlobalFunction void RunKernel();
CudaGlobalFunction void nodes_to_color( uchar4 *optr);
CudaGlobalFunction void nodes_fill( int width, int height);

<?R
for (q in rows(Quantities)) { ifdef(q$adjoint);
?>
CudaGlobalFunction void get<?%s q$name ?>(lbRegion r, <?%s q$type ?> * tab, real_t scale); <?R
	for (tp in c("float","double"))
        { ?>
CudaGlobalFunction void get<?%s q$name ?>_<?%s tp ?>(lbRegion , <?%s tp ?> *, int);
<?R
	}
}
ifdef() ?>

void * BAlloc(size_t size);
void BPreAlloc(void **, size_t size);

#endif
#define LATTICECONTAINER_H 1
