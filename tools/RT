#!/usr/bin/env Rscript

ret=try(library(optparse, quietly=T))
if ("try-error" %in% class(ret)) {
	warning("############### optparse package not installed. Trying to install ########\n")
	ret=try(install.packages("optparse"))
	if ("try-error" %in% class(ret)) {
		stop("Failed to install package.\nInstall optparse by running R
			and typing: install.packages('optparse')")
	}
	ret=try(library(optparse, quietly=T))
	if ("try-error" %in% class(ret)) {
		stop("Failed to load package.\nInstall optparse by running R
			and typing: install.packages('optparse')")
	}
}

options <- list(
        make_option(c("-f","--file"), "store", default="", help="Input file", type="character"),
	make_option(c("-o","--out"), "store", default="", help="Output file", type="character"),
	make_option(c("-x","--kill"), "store_true", default=FALSE, help="Put the output in a file without \".Rt\" (make a \"dead\" file)"),
	make_option(c("-d","--destroy"), "store_true", default=FALSE, help="Delete the orginal template"),
	make_option(c("-e","--exterminate"), "store_true", default=FALSE, help="Kill and Destroy"),
	make_option(c("-c","--code"), "store_true", default=FALSE, help="Generate R code"),
	make_option(c("-s","--shell"), "store_true", default=FALSE,help="Discart first '#!...' line"),
        make_option(c("-i","--include"), "store", default="", help="Include a .R file", type="character"),
        make_option(c("-I","--includedir"), "store", default="", help="Include directory", type="character"),
        make_option(c("-w","--workdir"), "store", default="", help="Set working directory", type="character"),
	make_option(c("-q","--quiet"), "store_true", default=FALSE,help="Quiet (print only errors)"),
        make_option(c("-t","--csv"), "store", default="", help="Read csv. use: \"-t example.csv:3\" the 3 record of example.csv", type="character")
)

opt <- parse_args(OptionParser(usage="Usage: RT [-x] -f inputfile [-o outputfile]", options), positional_arguments=TRUE)


RT.standards = c(
	"printf = function(...) {cat(sprintf(...))}",
	"quiet.source = function(..., comment=\"# \"){",
	"f=textConnection(\"quiet.source.text\",\"w\");",
	"sink(f); ret=source(...); sink(); close(f);",
	"cat(paste(comment,quiet.source.text,\"\n\",sep=\"\"),sep=\"\")",
	"ret }",
	"if (!exists(\"include.dir\")) include.dir=NULL;",
	"source = function(file,...) {",
	"pot = c(file, paste(include.dir,file,sep=\"/\"))",
	"sel = sapply(pot,file.exists)",
	"sel = which(sel)",
	"if (length(sel) < 1) stop(\"file not found:\",file,\" in include
	directories:\",paste(include.dir,collapse=\",\"))",
	"newfile=pot[sel[1]]",
	"base::source(file=newfile,...)",
	"}"
)

RT = function(infile, add=NULL, shell=N)
{
        if (is.character(infile)) {
                f = file(infile,"r")
        } else {
                f = infile
        }
        l = readLines(f)
        if (is.character(infile)) close(f)

	if (shell) {
		if (substr(l[1],1,2) == "#!") {
			l = l[-1]
		}
	}

        x = gregexpr("<[?][^[:blank:]]*", l)
        y = gregexpr("[?]>", l)

        transf = function(x) {
                r = data.frame(line=c(),start=c(),end=c())
                for (i in 1:length(x))
                {	p = x[[i]]
                        if (p[1] != -1)
                        {
                                tags = substring(l[i],p+2,p+attr(p,"match.length")-1)
                                r = rbind(r,
                                        data.frame(line=i,start=p, end=p+attr(p,"match.length"),tag=tags)
                                )
                        }
                }
                r
        }

        x = transf(x)
        if (nrow(x) > 0) {
                x$open=T
                y = transf(y)
                y$open=F
                tokens = rbind(x,y)
#                print(tokens)
                i = order(tokens$line,tokens$start)
                tokens = tokens[i,]

                check = cumsum(tokens$open*2-1)
                if (any(check > 1 | check < 0) ) stop ("Non matching <? and ?> found\n")

                chunks = data.frame(
                        start.line = c(1,tokens$line), start.char = c(1,tokens$end),
                        end.line = c(tokens$line,length(l)), end.char = c(tokens$start-1,nchar(l[length(l)])), tag=c("",as.character(tokens$tag)) )
	} else {chunks = data.frame(
                        start.line = 1, start.char = 1,
                        end.line = length(l), end.char = nchar(l[length(l)]), tag="")
	}
#	print(chunks)
		

        #print(chunks)


	output = c(
		"# RTemplate genereted code.",
		"############# RT standard functions ########",
		"",
		RT.standards,
		"",
		"############# Parameters and settings ######",
		"",
		add,
		"",
		"############# Code from Rt file ############",
		""
	)		
        for (i in 1:nrow(chunks))
        {
                n=chunks[i,]
                lu = l[n$start.line:n$end.line]
                if (n$start.line == n$end.line) {
                        lu = substr(lu,n$start.char,n$end.char)
                } else {
                        lu[1] = substr(lu[1],n$start.char,nchar(lu[1]))
                        lu[length(lu)] = substr(lu[length(lu)],1,n$end.char)
                }
                tag = as.character(n$tag)
		outadd = NULL
                if (tag == "") {
                        if (n$start.line != n$end.line)
                          lu[2:length(lu) - 1] = paste(lu[2:length(lu) - 1],"\n",sep="")
                        outadd = paste("cat( ", encodeString(lu,quote="\"")," );",sep="") 
                } else if (tag == "R") {
			outadd = lu;
                } else if (substr(tag,1,1) == "%") {
			if (length(lu) > 1) stop("'%' tag allowed only for one-line expressions");
			outadd = paste("cat(sprintf(",encodeString(tag,quote="\""),",  ", lu, "  ));",sep="");
		} else { cat("Unknown tag",tag,"\n");
		        if (n$start.line != n$end.line)
                          lu[2:length(lu) - 1] = paste(lu[2:length(lu) - 1],"\n",sep="")
                        outadd = c(
				paste("cat( ", encodeString(paste("<?",tag,sep=""),quote="\"")," );",sep="") ,
				paste("cat( ", encodeString(lu,quote="\"")," );",sep=""),
				paste("cat( ", encodeString("?>",quote="\"")," );",sep="")
			)	
                
		}
		output = c(output,outadd)
        }
	outadd = "cat(\"\\n\")"
	output = c(output,outadd)
	output
}




args = opt$args
opt = opt$options
#print(args)


if (opt$file == "") stop("Input file not specified\nUsage: RT -f file\n");
if (opt$exterminate) { opt$kill = T; opt$destroy = T; }


if (opt$out == "") opt$out = NULL
if (opt$kill) {
	if (is.null(opt$out))
	{	re = "[.]R[tT][^.]*$";
		if (!grepl(re, opt$file))
		{
			cat("Warning: file not enfing with .Rt* while killing - generating .dead file\n")
			opt$out = paste(opt$file,"dead",sep=".");
		} else {
			opt$out = sub(re,"",opt$file);
		}
		if (opt$code) opt$out = paste(opt$out,".R",sep="");
	} else {
		cat("Warning: output file name provided while killing\n");
	}
}

if (!is.null(opt$out) && !(opt$quiet))
	cat("Parsing RT:",opt$file, "->", opt$out,"\n");



addcode = NULL
e = new.env()

if(opt$csv != "")
{
#        cat("Getting params from",opt$csv,"\n");
        csv = strsplit(opt$csv,":")
        csv = csv[[1]];
	ind = 1;
	if (length(csv) == 2) {ind = as.integer(csv[2]); csv = csv[1]; }
	if (length(csv) >  2) stop("Wrong format -t argument: file:record");
	addcode = c(addcode,
		paste("csvfile = \"", encodeString(csv), "\";",sep=""),
		paste("record = ", ind, ";",sep=""),
		"tab = read.csv(csvfile);",
		"for (n in names(tab))",
		"assign(n,tab[record,n]);"
	)
}

if (length(args) > 0) {
#	cat("Evaluating commandline arguments\n");
#	argp = parse(text=args)
#	eval(argp,e)
	addcode = c(addcode,
		args
	)
}

if (opt$includedir != "") {
	opt$includedir = strsplit(opt$includedir,",")[[1]]
	addcode = c(addcode, paste("include.dir =
c(include.dir,paste(getwd(),\"",opt$includedir,"\",sep=\"/\"))",sep=""))
}


if (opt$workdir != "") {
	addcode = c(addcode, paste("setwd(\"",opt$workdir,"\")",sep=""))
}


if (opt$include != "") {
	opt$include = strsplit(opt$include,",")[[1]]
	addcode = c(addcode, paste("source(\"", opt$include, "\")",sep=""))
}

code = RT(opt$file, add=addcode, shell=opt$shell)

if (opt$code) {
	if (is.null(opt$out)) {
		writeLines(code);
	} else {
		writeLines(code, con=opt$out);
	}
} else {
	code.p = parse(text=code)
	if (! is.null(opt$out)) sink(opt$out);
	eval(code.p)
	if (! is.null(opt$out)) sink()
	
}

if (opt$destroy)
{
	cat("Should destroy:\n");
	cat("rm",opt$file,"\n");
}
