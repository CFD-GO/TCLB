<?R
    source("conf.R")
    c_header();
    source("lib/feq.R")
    source("lib/boundary.R")
?>
// 04/02/2017 - Model Developed: A. Fakhari, T. Mitchell
//    Extension to 3D from:
// """" A roust phase-field lattice Boltzmann model
//		for immiscible fluids at high density ratios """"
//
// Maintainer: Travis-Mitchell @TravisMitchell

// Code updates:
//		01/04/2017: Development starts...
//			    Plan is d3q27 for hydrodynamics
//			    and d3q15 for interface dynamics
//		08/04/2017: Verification and validation 
//				- Layered Poiseuille flow
//				- Rayleigh Taylor up to water-air like properties and Re=3000
//				- Validated with air Taylor bubble rising through olive oil
//				  experiment by Bugg et al. (2002)
//		14/08/2017: Look to improve readability by incorporating more R code
//				- e.g. for MRT operations etc.
//		12/12/2017: Model updated for inclusion in v6.2
//				- MRT collision updated to moment space
//				- Symmetry bounds removed, autosym added to options
//				- BGK made option
//		21/03/2018: Fix of solid contact
//				- Previous issue with bulk solid regions i.e. solid cells
//				  surrounded by all solid nodes
//				- Check added for these cases to stop nan appearances
//		28/04/2020: Added thermocapillary effects option
//		07/04/2021: Code clean up
//				- thermocapillary moved to the bottom of the file to separate
//				- forces broken up into individual functions, set up so that additional
//				  physics can be added simply if only a force needs to be altered
// 				- edge case for wall phase calculation in which normal direction points
//				  towards a solid node was found. Temporary fix by setting this to a 
//				  reasonable value (1) has been made - this is not ideal... 

<?R
    g=PV(DensityAll$name[DensityAll$group=="g"])
    wg = PV(paste0("wg[",1:27-1,"]"))
	# Extracting velocity set
    U = as.matrix(DensityAll[DensityAll$group=="g",c("dx","dy","dz")])
    u = PV(c("U","V","W"))
    absCi2 = (U[,1]*U[,1]+U[,2]*U[,2]+U[,3]*U[,3])
    if (Options$q27){
	    PF_velocities = 27
    } else {
	    PF_velocities = 15
    }
	# Formulate Weighted-MRT matrix
    m0 = matrix(1, 1, 27)
    m1 = U[,1]
    m2 = U[,2]
    m3 = U[,3]
    m4 = U[,1]*U[,2]
    m5 = U[,2]*U[,3]
    m6 = U[,3]*U[,1]
    m7 = 3*U[,1]*U[,1] - absCi2
    m8 = U[,2]*U[,2] - U[,3]*U[,3]
    m9 = absCi2 - 1
    m10 = U[,1] * (3*absCi2 - 5)
    m11 = U[,2] * (3*absCi2 - 5)
    m12 = U[,3] * (3*absCi2 - 5)
    m13 = U[,1] * (U[,2]*U[,2] - U[,3]*U[,3])
    m14 = U[,2] * (U[,3]*U[,3] - U[,1]*U[,1])
    m15 = U[,3] * (U[,1]*U[,1] - U[,2]*U[,2])
    m16 = U[,1]*U[,2]*U[,3]
    m17 = 0.5 * (3*absCi2*absCi2 - 7*absCi2+2)
    m18 = (3*absCi2 - 4) * (3*U[,1]*U[,1] - absCi2)
    m19 = (3*absCi2 - 4) * (U[,2]*U[,2] - U[,3]*U[,3])
    m20 = U[,1]*U[,2]*(3*absCi2 - 7)
    m21 = U[,2]*U[,3]*(3*absCi2 - 7)
    m22 = U[,3]*U[,1]*(3*absCi2 - 7)
    m23 = 0.5 * U[,1]*(9*absCi2*absCi2 - 33*absCi2 + 26)
    m24 = 0.5 * U[,2]*(9*absCi2*absCi2 - 33*absCi2 + 26)
    m25 = 0.5 * U[,3]*(9*absCi2*absCi2 - 33*absCi2 + 26)
    m26 = 0.5 * (9*absCi2*absCi2*absCi2 - 36*absCi2*absCi2 + 33*absCi2 - 2)

	M = rbind(m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m14,m15,m16,m17,m18,m19,m20,m21,m22,m23,m24,m25,m26)
	m = PV(c(paste("m[",1:27-1,"]",sep="")))
	invM = solve(M)

	geq = PV(c(paste("geq[",1:27-1,"]",sep="")))
	Fi  = PV(c(paste("F_i[",1:27-1,"]",sep="")))
	h   = PV(c(paste("h",1:PF_velocities-1,sep="")))
	heq  = PV(c(paste("heq[",1:PF_velocities-1,"]",sep="")))
	Fphi = PV(c(paste("F_phi[",1:PF_velocities-1,"]",sep="")))
	gammah = PV(c(paste("Gamma[",1:PF_velocities-1,"]",sep="")))
	if (Options$q27){
		w_h = PV(c(paste("wg[",1:27-1,"]",sep="")))
	} else {
		w_h = c(0.75, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0)
	}
	omega = PV("omega_phi")
	phase = PV("PhaseF")
	gammag = PV(c(paste("Gamma[",1:27-1,"]",sep="")))

	if (Options$OutFlow) {
		g_neighbours = Density$nicename[Density$group =="g"]
		h_neighbours = Density$nicename[Density$group =="h"]
		g_old = PV(Density$name[Density$group == "gold"])
		h_old = PV(Density$name[Density$group == "hold"])
		g_n = PV(paste(g_neighbours,"(",-Density$dx[Density$group=="g"]-1,",",-Density$dy[Density$group=="g"],",",-Density$dz[Density$group=="g"],")",sep=""))
		h_n = PV(paste(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],",",-Density$dz[Density$group=="h"],")",sep=""))
		U_loc = PV("U_local")
		U_inv = PV("invU")
	}
?>

<?R
	IsotropicGrad <- function(myStringVec, myStringSca){
		cat(paste0(myStringVec,".y = 16.00 * (",myStringSca, "(0,1,0) - ", myStringSca, "(0,-1,0)) + ", myStringSca, "(1,1,1) + ", myStringSca, "(-1,1,1) - ", myStringSca, "(1,-1,1) - ", myStringSca, "(-1,-1,1) + ", myStringSca, "(1,1,-1)+ ", myStringSca, "(-1,1,-1)- ", myStringSca,  "(1,-1,-1)- ", myStringSca, "(-1,-1,-1) +  4.00 * (", myStringSca, "(1,1,0) + ", myStringSca, "(-1,1,0) - ", myStringSca, "(1,-1,0) - ", myStringSca, "(-1,-1,0) +  ", myStringSca, "(0,1,1) - ", myStringSca, "(0,-1,1) + ", myStringSca, "(0,1,-1) - ", myStringSca, "(0,-1,-1));\n"))
		cat(paste0(myStringVec,".x = 16.00 * (",myStringSca, "(1,0,0) - ", myStringSca, "(-1,0,0)) + ", myStringSca, "(1,1,1) - ", myStringSca, "(-1,1,1) + ", myStringSca, "(1,-1,1) - ", myStringSca, "(-1,-1,1) + ", myStringSca, "(1,1,-1)- ", myStringSca, "(-1,1,-1) + ", myStringSca, "(1,-1,-1) - ", myStringSca, "(-1,-1,-1) +  4.00 * (", myStringSca, "(1,1,0) - ", myStringSca, "(-1,1,0) + ", myStringSca, "(1,-1,0) - ", myStringSca, "(-1,-1,0) + ", myStringSca, "(1,0,1) - ", myStringSca, "(-1,0,1) + ", myStringSca, "(1,0,-1) - ", myStringSca, "(-1,0,-1));\n"))
		cat(paste0(myStringVec,".z = 16.00 * (",myStringSca, "(0,0,1) - ", myStringSca, "(0,0,-1)) + ", myStringSca, "(1,1,1) + ", myStringSca, "(-1,1,1) + ", myStringSca, "(1,-1,1) + ", myStringSca, "(-1,-1,1) - ", myStringSca, "(1,1,-1)- ", myStringSca, "(-1,1,-1)- ", myStringSca,  "(1,-1,-1)- ", myStringSca, "(-1,-1,-1) +  4.00 * (", myStringSca, "(1,0,1) + ", myStringSca, "(-1,0,1) - ", myStringSca, "(1,0,-1) - ", myStringSca, "(-1,0,-1) +  ", myStringSca, "(0,1,1) + ", myStringSca, "(0,-1,1) - ", myStringSca, "(0,1,-1) - ", myStringSca, "(0,-1,-1));\n"))
		cat(paste0(myStringVec,".x /= 72.0;\n"))
		cat(paste0(myStringVec,".y /= 72.0;\n"))
		cat(paste0(myStringVec,".z /= 72.0;\n"))
	}
	myLaplace <- function(myStringVec, myStringSca){
			cat(paste0(myStringVec, " = 16.0 *((", myStringSca, "(1,0,0)) + (", myStringSca, "(-1,0,0)) + (", myStringSca, "(0,1,0)) + (", myStringSca, "(0,-1,0))+ (", myStringSca, "(0,0,1)) + (", myStringSca, "(0,0,-1)))	+ 1.0 *((", myStringSca, "(1,1,1)) + (", myStringSca, "(-1,1,1)) + (", myStringSca, "(1,-1,1))+ (", myStringSca, "(-1,-1,1)) + (", myStringSca, "(1,1,-1))+ (", myStringSca, "(-1,1,-1)) + (", myStringSca, "(1,-1,-1))+(", myStringSca, "(-1,-1,-1))) + 4.0 *((", myStringSca, "(1,1,0)) + (", myStringSca, "(-1,1,0))+ (", myStringSca, "(1,-1,0))+ (", myStringSca, "(-1,-1,0))+ (", myStringSca, "(1,0,1)) + (", myStringSca, "(-1,0,1))+ (", myStringSca, "(1,0,-1))+ (", myStringSca, "(-1,0,-1))+ (", myStringSca, "(0,1,1)) + (", myStringSca, "(0,-1,1))+ (", myStringSca, "(0,1,-1))+ (", myStringSca, "(0,-1,-1))) - 152.0 * ", myStringSca, "(0,0,0);\n"))
			cat(paste0(myStringVec, "/= 36.0;\n"))
	}
?>

#include <math.h>
#define PI 3.14159265
#define cs2 0.33333333
#ifdef OPTIONS_q27
#define hPops 27 
#else
#define hPops 15
#endif
//######EXPORTABLE QUANTITIES######//
<?R
if (Options$ML){
	for (myDensity in 0:26){
		cat(paste0("CudaDeviceFunction real_t getg",myDensity,"(){\n"))
		cat(paste0("\t return g",myDensity,";\n"))
		cat("}\n")
	}
	for (myDensity in 0:(PF_velocities-1)){
		cat(paste0("CudaDeviceFunction real_t geth",myDensity,"(){\n"))
		cat(paste0("\t return h",myDensity,";\n"))
		cat("}\n")
	}
}
?>


#ifdef OPTIONS_DEBUG
    #define debug_printf(...) printf(__VA_ARGS__)
#else
    #define debug_printf(...) do {} while (0)
#endif


CudaConstantMemory real_t const d3q27_faces_normals[6][3] = {{-1, 0, 0}, {1, 0, 0}, {0, -1, 0}, {0, 1, 0}, {0, 0, -1}, {0, 0, 1}};
CudaConstantMemory real_t const d3q27_faces_drop_indexes[6] = {0, 0, 1, 1, 2, 2};
CudaConstantMemory real_t const d3q27_triangles[6][8][3][3] = {\
  {{{1, 0, 0}, {1, 1, 1},  {1, 1, 0.0}},
  {{1, 0, 0}, {1, 1, 1},   {1, 0.0, 1}},
  {{1, 0, 0}, {1, -1, 1},  {1, 0.0, 1}},
  {{1, 0, 0}, {1, -1, 1},  {1, -1, 0.0}},
  {{1, 0, 0}, {1, -1, -1}, {1, -1, 0.0}},
  {{1, 0, 0}, {1, -1, -1}, {1, 0.0, -1}},
  {{1, 0, 0}, {1, 1, -1},  {1, 0.0, -1}},
  {{1, 0, 0}, {1, 1, -1},  {1, 1, 0.0}}},
 {{{-1, 0, 0}, {-1, 1, 1}, {-1, 1, 0.0}},
  {{-1, 0, 0}, {-1, 1, 1}, {-1, 0.0, 1}},
  {{-1, 0, 0}, {-1, -1, 1}, {-1, 0.0, 1}},
  {{-1, 0, 0}, {-1, -1, 1}, {-1, -1, 0.0}},
  {{-1, 0, 0}, {-1, -1, -1}, {-1, -1, 0.0}},
  {{-1, 0, 0}, {-1, -1, -1}, {-1, 0.0, -1}},
  {{-1, 0, 0}, {-1, 1, -1}, {-1, 0.0, -1}},
  {{-1, 0, 0}, {-1, 1, -1}, {-1, 1, 0.0}}},
 {{{0, 1, 0}, {1, 1, 1}, {1, 1, 0.0}},
  {{0, 1, 0}, {1, 1, 1}, {0.0, 1, 1}},
  {{0, 1, 0}, {-1, 1, 1}, {0.0, 1, 1}},
  {{0, 1, 0}, {-1, 1, 1}, {-1, 1, 0.0}},
  {{0, 1, 0}, {-1, 1, -1}, {-1, 1, 0.0}},
  {{0, 1, 0}, {-1, 1, -1}, {0.0, 1, -1}},
  {{0, 1, 0}, {1, 1, -1}, {0.0, 1, -1}},
  {{0, 1, 0}, {1, 1, -1}, {1, 1, 0.0}}},
 {{{0, -1, 0}, {1, -1, 1}, {1, -1, 0.0}},
  {{0, -1, 0}, {1, -1, 1}, {0.0, -1, 1}},
  {{0, -1, 0}, {-1, -1, 1}, {0.0, -1, 1}},
  {{0, -1, 0}, {-1, -1, 1}, {-1, -1, 0.0}},
  {{0, -1, 0}, {-1, -1, -1}, {-1, -1, 0.0}},
  {{0, -1, 0}, {-1, -1, -1}, {0.0, -1, -1}},
  {{0, -1, 0}, {1, -1, -1}, {0.0, -1, -1}},
  {{0, -1, 0}, {1, -1, -1}, {1, -1, 0.0}}},
 {{{0, 0, 1}, {1, 1, 1}, {1, 0.0, 1}},
  {{0, 0, 1}, {1, 1, 1}, {0.0, 1, 1}},
  {{0, 0, 1}, {-1, 1, 1}, {0.0, 1, 1}},
  {{0, 0, 1}, {-1, 1, 1}, {-1, 0.0, 1}},
  {{0, 0, 1}, {-1, -1, 1}, {-1, 0.0, 1}},
  {{0, 0, 1}, {-1, -1, 1}, {0.0, -1, 1}},
  {{0, 0, 1}, {1, -1, 1}, {0.0, -1, 1}},
  {{0, 0, 1}, {1, -1, 1}, {1, 0.0, 1}}},
 {{{0, 0, -1}, {1, 1, -1}, {1, 0.0, -1}},
  {{0, 0, -1}, {1, 1, -1}, {0.0, 1, -1}},
  {{0, 0, -1}, {-1, 1, -1}, {0.0, 1, -1}},
  {{0, 0, -1}, {-1, 1, -1}, {-1, 0.0, -1}},
  {{0, 0, -1}, {-1, -1, -1}, {-1, 0.0, -1}},
  {{0, 0, -1}, {-1, -1, -1}, {0.0, -1, -1}},
  {{0, 0, -1}, {1, -1, -1}, {0.0, -1, -1}},
  {{0, 0, -1}, {1, -1, -1}, {1, 0.0, -1}}}
};


<?R for (vertex in c(1, 2, 3)) { ?>
/* Reconstruct full coordinates of the <?R vertex ?> vertex of the triangle "triangle_id"
 * on face "face" and store in "coords"
 */
CudaDeviceFunction void triangle_id_to_vertex_<?%s vertex ?>_coords(int face, int triangle_id, int *coords)
{
	// compute triangle on the fly to save memory
	int index_pos = face / 2;
	int is_positive = face % 2;

	int first_component = 0;
	int second_component = 0;

<?R	if (vertex == 1) { ?>

	first_component = 0;
	second_component = 0;

<?R } else if (vertex == 2) { ?>

	second_component = 1 - 2*(triangle_id / 4 );
	first_component = 1 - 2*((triangle_id + 2) % 8) / 4;

<?R } else if (vertex == 3) { ?>

    second_component = triangle_id <= 3 ? int((triangle_id % 4 ) % 3 != 0): -int((triangle_id % 4 ) % 3 != 0);
    int val = (triangle_id + 2) % 8;
    first_component = val <= 3 ? int((val % 4 ) % 3 != 0): -int((val % 4 ) % 3 != 0);

<?R } ?>

	coords[index_pos] = is_positive ? 1 : -1;
	coords[index_pos == 0] = first_component;
	coords[2 - (index_pos == 2)] = second_component;
}
<?R } ?>


CudaDeviceFunction real_t getIsItBoundary() {
	return IsBoundary(0, 0, 0);
}

<?R
# Definition of various special boundary points that need special treatment
NORMAL_POINTING_INTO_SOLID_ON_NEXT_NODE = 1
NORMAL_POINTING_INTO_SOLID_ON_FURTHER_NEXT_NODE = 2
NEXT_NEXT_INTERPOLATING_POINTS_ARE_SOLID = 3
NEXT_INTERPOLATING_POINTS_ARE_SOLID = 4
# below is not a special point actually, below set simply for more readable code
BOTH_NEXT_AND_NNEXT_INTERPOLATING_POINTS_ARE_SOLID = 0
SPECIAL_POINT_HUGE_MAGIC_NUMBER = 2342e10
?>


CudaDeviceFunction real_t getSpecialBoundaryPoint() {
	return IsSpecialBoundaryPoint;
}


#ifdef OPTIONS_staircaseimp

CudaDeviceFunction vector_t getActualNormal() {
	vector_t actualNormal;
	actualNormal.x = nw_actual_x;
	actualNormal.y = nw_actual_y;
	actualNormal.z = nw_actual_z;
	return actualNormal;
}

#endif


#ifdef OPTIONS_altContactAngle
CudaDeviceFunction vector_t getGradPhi() {
	vector_t gradPhi;
	gradPhi.x = gradPhiVal_x(0,0,0);
	gradPhi.y = gradPhiVal_y(0,0,0);
	gradPhi.z = gradPhiVal_z(0,0,0);
	return gradPhi;
}


/*
  Corrects gradient values on the next layer closer to the boundary, trying
  its best to avoid taking the boundary values into the calculation of gradient
  and using 2nd order finite difference instead when possible. Should be
  used in conjunction of function calculating isotropic gradient everywhere else.
 */
CudaDeviceFunction void calcPhaseGradCloseToBoundary(){
	// handle boundaries
	// NOTE: we don't want to use them because the boundary values
	// are already calculated based on the phase field
	// gradient, we don't want to have implicit linking
	<?R
    lattice <- expand.grid(-1:1, -1:1, -1:1)
	diagonals <- lattice[apply(lattice, 1, function(r) sum(abs(r)) > 2), ]
	str_diagonals <- apply(diagonals, 1, function(x) paste(x, collapse=","))
	axis_shift <- function(x, axis = 0) {
		if (axis == 0) x else c(tail(x, -axis), head(x, axis))
	}
	directions = c("x", "y", "z")
	str_coord <- function(x, y, z, axis)  paste(axis_shift(c(x,y,z), axis), collapse=",")

	?>

    // if either of the diagonal nodes on the lattice is boundary node we force to
    // try to use finite difference
	bool forcedFiniteDifferenceInAllDirections = \
		  <?%s cat(Reduce(function(red, curr) paste(red, sprintf('IsBoundary(%s)', curr), sep = ' || '), str_diagonals, 'false')) ?>;


    real_t h = 1.0;


	bool canForceFiniteDifferenceUp;
	bool canForceFiniteDifferenceDown;

	<?R for (axis in c(0,1,2)) { ?>

	// if we want to use finite differences, try to pick the best directions
	canForceFiniteDifferenceDown = forcedFiniteDifferenceInAllDirections && \
		(!IsBoundary(<?%s str_coord(-1, 0, 0, axis) ?>)) && (!IsBoundary(<?%s str_coord(-2, 0, 0, axis) ?>));

	canForceFiniteDifferenceUp = forcedFiniteDifferenceInAllDirections && \
		(!IsBoundary(<?%s str_coord(1, 0, 0, axis) ?>)) && (!IsBoundary(<?%s str_coord(2, 0, 0, axis) ?>));

	if (IsBoundary(<?%s str_coord(1, 0, 0, axis) ?>) || canForceFiniteDifferenceDown ) {
		if (IsBoundary(<?%s str_coord(-1, 0, 0, axis) ?>)
			|| IsBoundary(<?%s str_coord(-2, 0, 0, axis) ?>)) {
			// keep it as it is, calculated using the previously set gradient and the boundary
			// value
		} else {
			gradPhiVal_<?%s directions[axis+1] ?> = -(4*PhaseF(<?%s str_coord(-1, 0, 0, axis) ?>) - \
							 PhaseF(<?%s str_coord(-2, 0, 0, axis) ?>) - 3*PhaseF(0, 0, 0))/(2.0*h);
		}
	}
	// check other direction and make sure that even points futher away are
	// handled properly, otherwise continue using isotropic gradient
	else if ((IsBoundary(<?%s str_coord(-1, 0, 0, axis) ?>) || canForceFiniteDifferenceUp) \
			 && (!IsBoundary(<?%s str_coord(2, 0, 0, axis) ?>))) {
		gradPhiVal_<?%s directions[axis+1] ?> = (4*PhaseF(<?%s str_coord(1, 0, 0, axis)  ?>) -
						PhaseF(<?%s str_coord(2, 0, 0, axis) ?>) - 3*PhaseF(0, 0, 0))/(2.0*h);
	}

	// end of the chunk for direction <?%s directions[axis + 1] ?>
	<?R } ?>

	if (IsBoundary(0,0,0)) {
		gradPhiVal_x = 0.;
		gradPhiVal_y = 0.;
		gradPhiVal_z = 0.;
	}

}


CudaDeviceFunction void calcPhaseGrad(){
    vector_t gradPhi;
    <?R
        IsotropicGrad('gradPhi', 'PhaseF')
    ?>
    gradPhiVal_x = gradPhi.x;
    gradPhiVal_y = gradPhi.y;
    gradPhiVal_z = gradPhi.z;
	calcPhaseGradCloseToBoundary();
}

CudaDeviceFunction void calcPhaseGrad_init(){
	// NOTE: Need to initialize gradients at the first time step,
	// because isotropic gradients would not work, as the wall values have no
	// Phase field values just yet
	//
	// Might be improved
    real_t h = 1.0;

	gradPhiVal_x = gradPhiVal_x(0, 0, 0);
	gradPhiVal_y = gradPhiVal_y(0, 0, 0);
	gradPhiVal_z = gradPhiVal_z(0, 0, 0);

	gradPhiVal_x = (PhaseF(1, 0, 0) - PhaseF(-1, 0, 0) )/ (2.0*h);
	gradPhiVal_y = (PhaseF(0, 1, 0) - PhaseF(0, -1, 0) )/ (2.0*h);
	gradPhiVal_z = (PhaseF(0, 0, 1) - PhaseF(0, 0, -1) )/ (2.0*h);

	calcPhaseGradCloseToBoundary();

	// accidentally touched the boundary, it is ok, this should be
	// fixed on the next iterations
	<?R for (d in c('x', 'y', 'z')) { ?>
		if (fabs(gradPhiVal_<?%s d ?>) > 20) {
			gradPhiVal_<?%s d ?> = 0;
		}
	<?R } ?>
}

#endif


#ifdef OPTIONS_ML
<?R
for (myDensity in 0:26){
	cat(paste0("CudaDeviceFunction real_t getg",myDensity,"(){\n"))
	cat(paste0("\t return g",myDensity,";\n"))
	cat("}\n")
}
for (myDensity in 0:14){
	cat(paste0("CudaDeviceFunction real_t geth",myDensity,"(){\n"))
	cat(paste0("\t return h",myDensity,";\n"))
	cat("}\n")
}
?>
#endif

CudaDeviceFunction real_t getRho(){
	if ( IamWall || IamSolid) {
		return 0.0;
	} else {
		return Density_l + (Density_h-Density_l) * (PhaseF(0,0) - PhaseField_l)/(PhaseField_h - PhaseField_l);
	}
}
CudaDeviceFunction real_t getPhaseField(){
	return PhaseF(0,0,0);
}
CudaDeviceFunction vector_t getU(){
	vector_t u;
	if ( IamWall || IamSolid ) {
		u.x = 0.0; u.y = 0.0; u.z = 0.0;
	} else {
		u.x = U; u.y = V; u.z = W;
	}
	return u;
}
CudaDeviceFunction real_t getPstar(){
	return pnorm; 
}
CudaDeviceFunction real_t getP(){
//May need to update this to not work off of streamed populations
	real_t   d = getRho(); 

	return pnorm*d*cs2;
}
CudaDeviceFunction vector_t getNormal(){
	vector_t n = {nw_x, nw_y, nw_z};
	return n;
}

//######HELPER FUNCTIONS#######//
CudaDeviceFunction vector_t calcGradPhi(){
	vector_t gradPhi = {0.0,0.0,0.0};
	#ifdef OPTIONS_OutFlow
		if ((NodeType & NODE_BOUNDARY) == NODE_ENeumann || (NodeType & NODE_BOUNDARY) == NODE_EConvect) {
			gradPhi.x = 0.0;
			gradPhi.y = 16.00 * (PhaseF(0,1,0) - PhaseF(0,-1,0))
						+ 2.0*(PhaseF(-1,1,1) - PhaseF(-1,-1,1)
						+ PhaseF(-1,1,-1)- PhaseF(-1,-1,-1))
						+  4.00 * (2.0*( PhaseF(-1,1,0) - PhaseF(-1,-1,0))
							+  PhaseF(0,1,1) - PhaseF(0,-1,1) + PhaseF(0,1,-1) - PhaseF(0,-1,-1));
			gradPhi.z = 16.00 * (PhaseF(0,0,1) - PhaseF(0,0,-1))
						+ 2.0*( PhaseF(-1,1,1) + PhaseF(-1,-1,1)
						-  PhaseF(-1,1,-1)- PhaseF(-1,-1,-1))
						+  4.00 * (2.0*( PhaseF(-1,0,1) - PhaseF(-1,0,-1))
							+  PhaseF(0,1,1) + PhaseF(0,-1,1) - PhaseF(0,1,-1) - PhaseF(0,-1,-1));
		} else if ((NodeType & NODE_BOUNDARY)) {
			// If single phase inlet/outlet, dont want periodic bounds to interfere - can cause waves/instabilities
			gradPhi.x = 0.0;gradPhi.y = 0.0;gradPhi.z = 0.0;
		} else {	
			<?R
				IsotropicGrad('gradPhi', 'PhaseF')
			?>
		}
	#else
		    <?R
			IsotropicGrad('gradPhi', 'PhaseF')
		    ?>
	#endif	
	return gradPhi;
}

CudaDeviceFunction void calcPhaseF(){
	updateBoundary();
	PhaseF = <?R C(sum(h))?>;
}


CudaDeviceFunction void calcWallPhase_correction() {
	PhaseF = PhaseF(0,0,0);

	if (IsSpecialBoundaryPoint == <?%s NORMAL_POINTING_INTO_SOLID_ON_NEXT_NODE ?> ) {
		// take the phase field calculated already from the node in front.
		// Might as well calculate using the neighbors, e.g. averaging
		PhaseF = PhaseF_dyn(nw_x, nw_y, nw_z);
	}
}

CudaDeviceFunction void calcWallPhase(){
	PhaseF = PhaseF(0,0,0); //For fluid nodes.
	if ( IamWall || IamSolid ) {
		real_t a, h, pf_f;

		pf_f = PhaseF_dyn(nw_x, nw_y, nw_z);
		h = 0.5 * sqrt(nw_x*nw_x + nw_y*nw_y + nw_z*nw_z);

		if (h < 0.001) {
			// If I am a wall/solid node and I am surrounded by solid nodes
			PhaseF = 1;
		} else if (IsSpecialBoundaryPoint == <?%d NORMAL_POINTING_INTO_SOLID_ON_NEXT_NODE ?>) {
			// Pass for now. Dont' calculate anything, just set it to some huge number, purely to make sure
			// that the value is corrected in calcWall_correction, and otherwise the error would be visible
			// and hopefulyl breake the simulation
			PhaseF = <?%f SPECIAL_POINT_HUGE_MAGIC_NUMBER ?>;
		} else if  (IsSpecialBoundaryPoint == <?%d NORMAL_POINTING_INTO_SOLID_ON_FURTHER_NEXT_NODE ?>) {
			// eventhough I am geometric boundary condition, still apply surface energy
			// here because otherwise we can't really apply anything else
			a = -h * (4.0/IntWidth) * cos( radAngle );
			PhaseF = (1 + a - sqrt( (1+a)*(1+a) - 4*a*pf_f))/(a+1e-12) - pf_f;
		} else if (fabs(radAngle - PI/2.0) < 1e-4) {
			// If I am not surrounded, but contact angle is pi/2 (90d)
			PhaseF = pf_f;
		} else {

#ifdef OPTIONS_staircaseimp

// Really ugly way to mix compile time and runtime defs
#ifdef OPTIONS_altContactAngle
        bool use_surface_energy_staircase_imp = false;

		// try to use the surface energy staircase implementation, if the next layer
		// is solid
		// NOTE: Currently unused, because mixing schemes slows down the simulation
		// significantly (presumably because irregular memory access to PhaseF and gradPhi)
        if (IsSpecialBoundaryPoint == <?%d NEXT_NEXT_INTERPOLATING_POINTS_ARE_SOLID ?>) {
            use_surface_energy_staircase_imp = false;
        }

#else
        bool use_surface_energy_staircase_imp = true;
#endif

		int face_index = int(triangle_index) / 8;
		int face_triangle_index = int(triangle_index) % 8;

		int vertex_coords[3] = {0,0,0};

		<?R for (v in c(1, 2, 3)) { ?>
			triangle_id_to_vertex_<?%s v ?>_coords(face_index, face_triangle_index, vertex_coords);
			int v<?%s v ?>_x = vertex_coords[0], v<?%s v ?>_y = vertex_coords[1], v<?%s v ?>_z = vertex_coords[2];
		<?R } ?>


		if (use_surface_energy_staircase_imp) {

			<?R for (v in c(1, 2, 3)) { ?>
				real_t pf_v<?%s v?> = PhaseF_dyn(v<?%s v?>_x, v<?%s v?>_y, v<?%s v?>_z);
			<?R } ?>


			// don't do staircase improvement if any of the interpolating nodes are solid
			if (IsSpecialBoundaryPoint != <?%d NEXT_INTERPOLATING_POINTS_ARE_SOLID ?>) {
				real_t pf_interpolated = coeff_v1 * pf_v1 + coeff_v2 * pf_v2 + coeff_v3 * pf_v3;
				h = 0.5 * sqrt(nw_actual_x*nw_actual_x + nw_actual_y*nw_actual_y + nw_actual_z*nw_actual_z);
				pf_f = pf_interpolated;


				// apply surface energy BC to the interpolated value if I am edge case of geometric staircase and quit
				#ifdef OPTIONS_altContactAngle
					// apply surface energy boundary conditions
					a = -h * (4.0/IntWidth) * cos( radAngle );
					PhaseF = (1 + a - sqrt( (1+a)*(1+a) - 4*a*pf_f))/(a+1e-12) - pf_f;
					return;
				#endif
			}
		}
#endif
// Case 1: Apply surface energy BC
#ifndef OPTIONS_altContactAngle
			// apply surface energy boundary conditions
			a = -h * (4.0/IntWidth) * cos( radAngle );
			PhaseF = (1 + a - sqrt( (1+a)*(1+a) - 4*a*pf_f))/(a+1e-12) - pf_f;
#else


// Case 2: Apply geometric BC
// Case 2.1: Apply geometric BC with staircase improvement
#ifdef OPTIONS_staircaseimp
			// handling the last special case...
			vector_t solid_normal = {nw_actual_x, nw_actual_y, nw_actual_z};
			real_t der_x_1, der_y_1, der_z_1, der_x_2, der_y_2, der_z_2;

			// interpolate only if none of the interpolating points are solid
			if (IsSpecialBoundaryPoint != <?%d NEXT_INTERPOLATING_POINTS_ARE_SOLID ?> && IsSpecialBoundaryPoint != <?%d NEXT_NEXT_INTERPOLATING_POINTS_ARE_SOLID ?> ) {
//				<?R for (d in c('x', 'y', 'z')) { ?>
//					der_<?%s d ?>_1 = coeff_v1*gradPhiVal_<?%s d ?>_dyn(v1_x, v1_y, v1_z) + \
//										coeff_v2*gradPhiVal_<?%s d ?>_dyn(v2_x, v2_y, v2_z) +  \
//										coeff_v3*gradPhiVal_<?%s d ?>_dyn(v3_x, v3_y, v3_z);
//				<?R } ?>

                der_x_1 = 0;
                der_y_1 = 0;
                der_z_1 = 0;

				<?R for (d in c('x', 'y', 'z')) { ?>
					der_<?%s d ?>_1 += coeff_v1*gradPhiVal_<?%s d ?>_dyn(v1_x, v1_y, v1_z);
				<?R } ?>

				<?R for (d in c('x', 'y', 'z')) { ?>
					der_<?%s d ?>_1 += coeff_v2*gradPhiVal_<?%s d ?>_dyn(v2_x, v2_y, v2_z);
				<?R } ?>

				<?R for (d in c('x', 'y', 'z')) { ?>
					der_<?%s d ?>_1 += coeff_v3*gradPhiVal_<?%s d ?>_dyn(v3_x, v3_y, v3_z);
				<?R } ?>

	// Case 2.1a: Apply geometric BC with staircase improvement and "larger" second triangle
	#ifndef OPTIONS_tprec
				// Bigger triangle
				// Get gradient on the second node in the normal direction
				// <?R for (d in c('x', 'y', 'z')) { ?>
				// 	der_<?%s d ?>_2 = coeff_v1*gradPhiVal_<?%s d ?>_dyn(2*v1_x, 2*v1_y, 2*v1_z) + \
				// 						coeff_v2*gradPhiVal_<?%s d ?>_dyn(2*v2_x, 2*v2_y, 2*v2_z) +  \
				// 						coeff_v3*gradPhiVal_<?%s d ?>_dyn(2*v3_x, 2*v3_y, 2*v3_z);

				// <?R } ?>

				// Bigger triangle
				// Get gradient on the second node in the normal direction
                der_x_2 = 0;
                der_y_2 = 0;
                der_z_2 = 0;

				<?R for (d in c('x', 'y', 'z')) { ?>
					der_<?%s d ?>_2 += coeff_v1*gradPhiVal_<?%s d ?>_dyn(2*v1_x, 2*v1_y, 2*v1_z);
				<?R } ?>

				<?R for (d in c('x', 'y', 'z')) { ?>
					der_<?%s d ?>_2 += coeff_v2*gradPhiVal_<?%s d ?>_dyn(2*v2_x, 2*v2_y, 2*v2_z);
				<?R } ?>

				<?R for (d in c('x', 'y', 'z')) { ?>
					der_<?%s d ?>_2 += coeff_v3*gradPhiVal_<?%s d ?>_dyn(2*v3_x, 2*v3_y, 2*v3_z);
				<?R } ?>

	// Case 2.1b: Apply geometric BC with staircase improvement and "precice/smaller" triangle triangle
	#else
				// TODO: This needs handling for the case if one of interpolating points points into a solid node
				// get new triangle vertices in relation to one vertice of the previous triangle (plane index remains the same)
				int face_triangle_index2 = int(triangle_index2) % 8;

				<?R for (v in c(1, 2, 3)) { ?>
					triangle_id_to_vertex_<?%s v ?>_coords(face_index, face_triangle_index2, vertex_coords);
					int v2_<?%s v ?>_x = vertex_coords[0], v2_<?%s v?>_y = vertex_coords[1], v2_<?%s v?>_z = vertex_coords[2];
				<?R } ?>


				// Get gradient on the second node in the normal direction (triangle indexing relative to the second node of the first triangle because it is the closest)
				<?R for (d in c('x', 'y', 'z')) { ?>
					der_<?%s d ?>_2 = coeff2_v1*gradPhiVal_<?%s d?>_dyn(v2_1_x + v2_x, v2_1_y + v2_y, v2_1_z + v2_z) + \
										coeff2_v2*gradPhiVal_<?%s d?>_dyn(v2_2_x + v2_x, v2_2_y + v2_y, v2_2_z + v2_z) + \
										coeff2_v3*gradPhiVal_<?%s d?>_dyn(v2_3_x + v2_x, v2_3_y + v2_y, v2_3_z + v2_z);
				<?R } ?>

  #endif // end tprec ifdef
			} else {
			// Revert to using "normals rounded to lattice directions" method,
			// which should not point to solid nodes hopefully
			// unfortunately code is duplicated between #ifdef branches
			// and if branches, but I can't see a way around it
			<?R for (d in c('x', 'y', 'z')) { ?>
				solid_normal.<?%s d ?> = nw_<?%s d ?>;
				// Get gradient on the first node in the normal direction
				der_<?%s d ?>_1 = gradPhiVal_<?%s d ?>_dyn(nw_x, nw_y, nw_z);
				// Get gradient on the second node in the normal direction
				der_<?%s d ?>_2 = gradPhiVal_<?%s d ?>_dyn(2*nw_x, 2*nw_y, 2*nw_z);
				<?R } ?>
		}


  #else // no staircase improvement
// Case 2.2: No staircase improvement
		    vector_t solid_normal = {nw_x, nw_y, nw_z};
			<?R for (d in c('x', 'y', 'z')) { ?>
				// Get gradient on the first node in the normal direction
				real_t der_<?%s d ?>_1 = gradPhiVal_<?%s d ?>_dyn(nw_x, nw_y, nw_z);
				// Get gradient on the second node in the normal direction
				real_t der_<?%s d ?>_2 = gradPhiVal_<?%s d ?>_dyn(2*nw_x, 2*nw_y, 2*nw_z);
			<?R } ?>


#endif // end staircase improvement ifdef
// Case 2 general: Continue applying geometric formulas
			real_t norm = solid_normal.x*solid_normal.x + solid_normal.y * solid_normal.y + solid_normal.z * solid_normal.z;
			real_t coeff;

			// project the gradients of two nodes in the normal direction on the boundary plane
			<?R for (i in c(1, 2)) { ?>
					coeff = (der_x_<?%s i ?> * solid_normal.x + der_y_<?%s i ?>* solid_normal.y + der_z_<?%s i ?>* solid_normal.z)/norm;
					vector_t proj_grad_<?%s i ?> = {der_x_<?%s i ?> - coeff*solid_normal.x, der_y_<?%s i ?> - coeff*solid_normal.y, der_z_<?%s i ?> - coeff * solid_normal.z};
			<?R } ?>

			// extrapolate their components
			vector_t grad_tangent_v = { 1.5 * proj_grad_1.x - 0.5 * proj_grad_2.x,
										1.5 * proj_grad_1.y - 0.5 * proj_grad_2.y,
										1.5 * proj_grad_1.z - 0.5 * proj_grad_2.z};


			// compute the norm
			real_t grad_tangent = sqrt(grad_tangent_v.x * grad_tangent_v.x  + \
									 grad_tangent_v.y * grad_tangent_v.y + \
									 grad_tangent_v.z * grad_tangent_v.z);

			// apply geometric boundary condition
			PhaseF =  tan(PI/2.0 - radAngle) * grad_tangent * 2.0*h + pf_f;
#endif // end boundary condition pick
		}
	} 
}

CudaDeviceFunction real_t calcMu(real_t C){
	real_t pfavg, lpPhi, mu;
	pfavg = 0.5*(PhaseField_l+PhaseField_h);
	#ifdef OPTIONS_OutFlow
		if ((NodeType & NODE_BOUNDARY) == NODE_ENeumann || (NodeType & NODE_BOUNDARY) == NODE_EConvect) { 
			lpPhi = 16.0 *( 2.0* PhaseF(-1,0,0)
						+ (PhaseF(0,1,0)) + (PhaseF(0,-1,0))
						+ (PhaseF(0,0,1)) + (PhaseF(0,0,-1)))
					+ 1.0 *(  2.0*(PhaseF(-1,1,1)
						+ (PhaseF(-1,-1,1))
							+ (PhaseF(-1,1,-1))
							+ (PhaseF(-1,-1,-1))))
					+ 4.0 *(2.0*( (PhaseF(-1,1,0))
						+ (PhaseF(-1,-1,0))
						+ (PhaseF(-1,0,1))
						+ (PhaseF(-1,0,-1)))
						+ (PhaseF(0,1,1)) + (PhaseF(0,-1,1))
						+ (PhaseF(0,1,-1))+ (PhaseF(0,-1,-1)))
				- 152.0 * PhaseF(0,0,0);
		} else if ((NodeType & NODE_BOUNDARY)) {
			// If single phase inlet/outlet, dont want periodic bounds
			// to interfere - can cause waves/instabilities
			lpPhi = 0.0;
		} else {
			<?R
				myLaplace('lpPhi', 'PhaseF')
			?>
		}
	#else
			<?R
				myLaplace('lpPhi', 'PhaseF')
			?>
	#endif
	#ifdef OPTIONS_thermo
		mu = 4.0*(12.0*SurfaceTension(0,0,0)/IntWidth)*(C-PhaseField_l)*(C-PhaseField_h)*(C-pfavg)
			- (1.5 *SurfaceTension(0,0,0)*IntWidth) * lpPhi;
	#else
		mu = 4.0*(12.0*sigma/IntWidth)*(C-PhaseField_l)*(C-PhaseField_h)*(C-pfavg)
			- (1.5 *sigma*IntWidth) * lpPhi;
	#endif
	return mu;
}

CudaDeviceFunction real_t calcGamma(int i, real_t u, real_t v, real_t w, real_t u2mag){
	real_t gamma, tmp;
	tmp = (d3q27_ex[i]*u+d3q27_ey[i]*v+d3q27_ez[i]*w);

	gamma = wg[i] * (1 + 3.0*(tmp) + 4.5*(tmp*tmp) - 1.5*(u2mag)) ;
	return gamma;
}

CudaDeviceFunction real_t calcF_phi(int i, real_t tmp1, real_t nx, real_t ny, real_t nz){
	real_t f_phi;
#ifdef OPTIONS_q27
	f_phi = wg[i] * tmp1 * (d3q27_ex[i]*nx + d3q27_ey[i]*ny + d3q27_ez[i]*nz);
#else
	f_phi = wh[i] * tmp1 * (d3q27_ex[i]*nx + d3q27_ey[i]*ny + d3q27_ez[i]*nz);
#endif
	return f_phi;
}

//	INITIALISATION:
CudaDeviceFunction void Init() {
	PhaseF = PhaseField;
	specialCases_Init();
	if ( IamWall || IamSolid ) PhaseF = -999;

	if (developedFlow > 0.1) {
		U = 6.0 * Uavg * Y*(HEIGHT - Y)/(HEIGHT*HEIGHT);
        	V = 0.0;
        	W = 0.0;
	} else if ( developedPipeFlow_X > 0.1 ){
		U = 2.0 * Uavg * (1 - pow( (sqrt(pow((Y-pipeCentre_Y),2) + pow((Z-pipeCentre_Z),2)) / pipeRadius),2));
		V = 0.0;
		W = 0.0;
	} else if (shearFlow > 0.1) {
		U = Y*VelocityX / HEIGHT;
		V = 0;
		W = 0;
	} else {
		U = VelocityX;	V = VelocityY;	W = VelocityZ;
	}

}

CudaDeviceFunction void InitFromFieldsStage(){
	PhaseF = Init_PhaseField_External;
	U = Init_UX_External;
	V = Init_UY_External;
	W = Init_UZ_External;
	if ( IamWall || IamSolid ) PhaseF = -999;
}

CudaDeviceFunction void specialCases_Init(){
	#ifdef OPTIONS_thermo
		Temp   = T_init;
		if (fabs(dT) > 0){
			Temp = T_init + dT*Y;
		}
		if (fabs(dTx) > 0){
			Temp = T_init + dTx*X;
		}
		#ifdef OPTIONS_planarBenchmark
			if ( (NodeType & NODE_ADDITIONALS) == NODE_BWall) { //bottom wall
				real_t x, omega;
				x = (X-0.5) - myL;
				omega = 3.1415926535897 / myL;
				Temp = T_h + T_0 * cos(omega * x);
				printf("y,x=%.4lf,%.4lf\n", Y,x);
			} else if ( (NodeType & NODE_ADDITIONALS) == NODE_TWall) {
				Temp = T_c;
				printf("y,x=%.4lf,%.4lf\n", Y, X);
			}
			PhaseF = 0.5 + PLUSMINUS * (0.5) * tanh( (Y - MIDPOINT)/(IntWidth/2) );
		#endif
		if (surfPower > 1) {
			SurfaceTension = sigma + sigma_TT*pow((Temp(0,0,0) - T_ref),surfPower) * (1.0/surfPower);
		} else {
			SurfaceTension = sigma + sigma_T*(Temp(0,0,0) - T_ref);
		}
		Cond = interp(PhaseF, k_h, k_l);
	#endif											
	// Pre-defined Initialisation patterns:
	// Diffuse interface sphere
	   // BubbleType = -1 refers to light fluid bubble.
        if ( Radius > 0 ){ 
                real_t Ri;
                Ri = sqrt( (X - CenterX)*(X - CenterX) + (Y - CenterY)*(Y - CenterY) + (Z - CenterZ)*(Z - CenterZ) );
                PhaseF = 0.5*(PhaseField_h + PhaseField_l)
                       - 0.5*(PhaseField_h - PhaseField_l) * BubbleType * tanh(2 * (Ri - Radius)/IntWidth);
        }	
 	// Rayleigh-Taylor Instability
	    // Initialises with a sharp interface
	if (RTI_Characteristic_Length > 0){
		real_t d = RTI_Characteristic_Length;
		real_t ycutoff;
        if (pseudo2D > 0.5){
		ycutoff = 2.0*d + Perturbation*d*(cos(2.0*PI*X/d));
		PhaseF = 0.5 * (PhaseField_h + PhaseField_l)
                   	+ 0.5 * (PhaseField_h - PhaseField_l) * tanh(2.0 * (Y - ycutoff)/IntWidth);
        } else {
		ycutoff = 2.0*d + Perturbation*d*(cos(2.0*PI*X/d) + cos(2.0*PI*Z/d));
		if (Y < ycutoff) {PhaseF = 0.0; }
		else             {PhaseF = 1.0;	}
        }
	}
    // Annular Taylor bubble set up
	if ( DonutTime > 0){
		real_t intLocation = Donut_D * 
					sqrt( pow(Donut_h,2) 
					    - pow( DonutTime - sqrt(pow(Y-CenterY,2) + pow(Z-CenterZ,2)), 2) );
		real_t shifter = atan2( (Z-CenterZ), (Y-CenterY));
		if (shifter < 0) shifter = shifter + 2*PI;
		if (  (X < Donut_x0 + intLocation*sin(shifter/2)) && (X > Donut_x0 - intLocation) )
		{
			PhaseF = 0.0;
		} else {
			PhaseF = 1.0;
		}
	}
    // Washburn Law test setup
    if ((Washburn_start > 0) && (Washburn_end > 0) ) {
		PhaseF = 1 - 0.5 *  ( tanh( 2.0 * ( X - Washburn_start ) / IntWidth ) -
						   tanh( 2.0 * ( X - Washburn_end  )  / IntWidth ));
	}
}

CudaDeviceFunction void Init_wallNorm(){
	PhaseF = PhaseF(0,0,0);
    IsBoundary = IsBoundary(0,0,0);
	IsBoundary = 0.0;
	IsSpecialBoundaryPoint = 0.0;
#ifdef OPTIONS_staircaseimp
	coeff_v1 = 0;
	coeff_v2 = 0;
	coeff_v3 = 0;
#endif
	if ( IamWall || IamSolid ) {
        IsBoundary = 1.0;
	// Am I surrounded by solid nodes?
		int i,j,k;
	  	real_t tmp = 0.0;
	  	for (i=-1;i<2;i++){for (j=-1;j<2;j++){for (k=-1;k<2;k++){
			tmp += PhaseF_dyn(i,j,k);
	  	}}}

	  	if ( abs(tmp) > 26000){
		// yes I am surrounded (sum(pf) = 27*-999 = -26973 if surrounded):
			nw_x = 0.0;nw_y = 0.0;nw_z = 0.0;
#ifdef OPTIONS_staircaseimp
			nw_actual_x = 0.0;
			nw_actual_y = 0.0;
			nw_actual_z = 0.0;
#endif
	  	} else { 
		// no I am not surrounded, so calc normal:
			int solidFlag[27]; 
			int maxi = 0;
			real_t myNorm[3] = {0.0,0.0,0.0};
			real_t maxn=0.0, dot;

			// Calculate the normal direction:
			// NOTE: We are simply getting solid flags below
			<?R
			    myN   = PV(paste0("myNorm[",1:3-1,"]"))
			    pf    = PV(paste0("PhaseF(",U[,1],",",U[,2],",",U[,3],")/-998"))
			    solid = PV(paste0("solidFlag[",1:27-1,"]"))
			
			    C(solid, pf)
			?>
			for (i=0;i<27;i++){
				myNorm[0] += wg[i] * solidFlag[i] * d3q27_ex[i];
				myNorm[1] += wg[i] * solidFlag[i] * d3q27_ey[i];
				myNorm[2] += wg[i] * solidFlag[i] * d3q27_ez[i];
			
			}
			myNorm[0] *= -1.0/3.0;myNorm[1] *= -1.0/3.0;myNorm[2] *= -1.0/3.0;
			tmp = myNorm[0]*myNorm[0] + myNorm[1]*myNorm[1] + myNorm[2]*myNorm[2];

			// Calculate the closest discrete direction for normal:
			for (i = 0; i<27; i++) {
				dot = (myNorm[0]*d3q27_ex[i] + myNorm[1]*d3q27_ey[i] + myNorm[2]*d3q27_ez[i]) /
			      		sqrt( tmp*(d3q27_ex[i]*d3q27_ex[i] + d3q27_ey[i]*d3q27_ey[i] + 
					 	   d3q27_ez[i]*d3q27_ez[i]) + 1e-12);
				if (dot > maxn) {
					maxn = dot; maxi = i;
				}
			}
			if (maxi < 0) {
				// This should not happen ?
				nw_x = 0.0;nw_y = 0.0;nw_z = 0.0;
			} else {
				nw_x = d3q27_ex[maxi];
				nw_y = d3q27_ey[maxi];
				nw_z = d3q27_ez[maxi];

				// normal points into another solid node, save it for the later treatment
				// NOTE: Can't use IsBoundary here, because it is not yet necessary set for
				// the neighboring nodes
				if (PhaseF_dyn(nw_x, nw_y, nw_z) < -100) {
					IsSpecialBoundaryPoint = <?%d NORMAL_POINTING_INTO_SOLID_ON_NEXT_NODE ?>;
				}
			}

#ifdef OPTIONS_staircaseimp
			real_t truncated_normals[3] = {nw_x, nw_y, nw_z};
			real_t intersection_point[3];
			int face_index;
			real_t coeff[3];
			real_t coeff2[3];
			int t_index;
			int t_index2;

			calcIntersectionTriangleId(myNorm, t_index, face_index, coeff, intersection_point, t_index2, coeff2);

			// make sure normal vector is extended to the surface (to use it during interpolation)
			nw_actual_x = intersection_point[0];
			nw_actual_y = intersection_point[1];
			nw_actual_z = intersection_point[2];
			triangle_index = triangle_index(0,0,0);
			triangle_index = t_index + face_index*8;


            coeff_v1 = coeff[0];
            coeff_v2 = coeff[1];
            coeff_v3 = coeff[2];

#ifdef OPTIONS_tprec
			triangle_index2 = triangle_index2(0,0,0);
			triangle_index2 = t_index2 + face_index*8;
            coeff2_v1 = coeff2[0];
            coeff2_v2 = coeff2[1];
            coeff2_v3 = coeff2[2];
#endif
#endif

#ifdef OPTIONS_staircaseimp
		// NOTE: Detect if any of the triangle vertices is a solid node and
		// if so, use the simple normal instead if possible
		real_t h = 0.5 * sqrt(nw_x*nw_x + nw_y*nw_y + nw_z*nw_z);

		int face_triangle_index = t_index;

		int vertex_coords[3] = {0,0,0};

		<?R for (v in c(1, 2, 3)) { ?>
			triangle_id_to_vertex_<?%s v ?>_coords(face_index, face_triangle_index, vertex_coords);
			int v<?%s v ?>_x = vertex_coords[0], v<?%s v ?>_y = vertex_coords[1], v<?%s v ?>_z = vertex_coords[2];
			real_t pf_v<?%s v?> = PhaseF_dyn(v<?%s v?>_x, v<?%s v?>_y, v<?%s v?>_z);
		<?R } ?>


#ifdef OPTIONS_altContactAngle
		bool will_interpolate_further_from_the_boundary = PhaseF_dyn(2*v1_x, 2*v1_y, 2*v1_z) < -100 || PhaseF_dyn(2*v2_x, 2*v2_y, 2*v2_z) < -100 || PhaseF_dyn(2*v3_x, 2*v3_y, 2*v3_z) < -100;
#endif
		// TODO: Can be simplified
		bool will_interpolate_from_the_boundary = pf_v3 < -100 || pf_v2 < -100 || pf_v1 < -100;

		// If I am trying to interpolate from the boundary,
		// better remove staircase approximation all together to simplify
		if (will_interpolate_from_the_boundary) {
			// if normal vector points to the solid, continue marking this point as the special point
			// because this is definitely a vector vertices of which coincide with the one of triangle
			// vertices
			if (IsSpecialBoundaryPoint == <?%d NORMAL_POINTING_INTO_SOLID_ON_NEXT_NODE ?> ) {
				// for clarity
				IsSpecialBoundaryPoint = <?%d NORMAL_POINTING_INTO_SOLID_ON_NEXT_NODE ?>;
			}
			else { // otherwise we just used the node in the normal direction when calculating
				IsSpecialBoundaryPoint = <?%d NEXT_INTERPOLATING_POINTS_ARE_SOLID ?>;
			}
		}
#ifdef OPTIONS_altContactAngle


		// if some of distanced points point into the boundary, mark it to interpolate
		// from closer nodes using surface energy method,
		 if (will_interpolate_further_from_the_boundary) {
			bool normal_pointing_into_solid_on_further_next_node = PhaseF_dyn(2*nw_x, 2*nw_y, 2*nw_z) < -100;

			if  (!will_interpolate_from_the_boundary) {
				// use surface energy and do staircase interpolation, since this must be possible
				IsSpecialBoundaryPoint = <?%d NEXT_NEXT_INTERPOLATING_POINTS_ARE_SOLID ?>;
			} else if (IsSpecialBoundaryPoint != <?%d NORMAL_POINTING_INTO_SOLID_ON_NEXT_NODE ?> ) {
				//  otherwise, if the node is the normal direction is still fine but some of the rest are solids,
				// mark this point to switch off staircase inteprolation for the geometric method

				// if the next-next node is solid, we can't really compute anything with geometric method :(
				if (normal_pointing_into_solid_on_further_next_node) {
					// switch-off geometric method entirely
					IsSpecialBoundaryPoint = <?%d NORMAL_POINTING_INTO_SOLID_ON_FURTHER_NEXT_NODE ?>;
				} else {
					// keep using it, since at least 2 points in the normal direction (next and next-next)
					// are fine
					IsSpecialBoundaryPoint = <?%d BOTH_NEXT_AND_NNEXT_INTERPOLATING_POINTS_ARE_SOLID ?>;
				}
			}
		}
#endif

#else
// when there is no staircase improvement and I'am altContactAngle
#ifdef OPTIONS_altContactAngle
		// if the next-next node is solid, we can't really compute anything with geometric method :(
		if (PhaseF_dyn(2*nw_x, 2*nw_y, 2*nw_z) < -100) {
			IsSpecialBoundaryPoint = <?%d NORMAL_POINTING_INTO_SOLID_ON_FURTHER_NEXT_NODE ?>;
		}
#endif
#endif

	  	}
	} else {
	// I am a fluid node, I dont need no solid normal.
		nw_x = 0.0;
		nw_y = 0.0;
		nw_z = 0.0;
#ifdef OPTIONS_staircaseimp
		nw_actual_x = 0.0;
		nw_actual_y = 0.0;
		nw_actual_z = 0.0;
		coeff_v1 = 0.0;
		coeff_v2 = 0.0;
		coeff_v3 = 0.0;
		triangle_index = 0;
#ifdef OPTIONS_tprec
		coeff2_v1 = 0.0;
		coeff2_v2 = 0.0;
		coeff2_v3 = 0.0;
		triangle_index2 = 0;
#endif
#endif
	}
}

CudaDeviceFunction void Init_distributions(){
	// Initialise phase variables:
	int i;
	real_t C0 = 0.5*(PhaseField_h - PhaseField_l);
	PhaseF = PhaseF(0,0,0);
	real_t d = Density_l + (Density_h-Density_l) * (PhaseF - PhaseField_l)/(PhaseField_h - PhaseField_l);
    pnorm = Pressure / (d*cs2);

	// Gradients and phasefield normals:
	real_t nx, ny, nz, magnPhi;
	vector_t gradPhi = calcGradPhi();
	magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z);

#ifdef OPTIONS_altContactAngle
    gradPhiVal_x = gradPhi.x;
	gradPhiVal_y = gradPhi.y;
	gradPhiVal_z = gradPhi.z;
#endif
	if (magnPhi < minGradient){
		nx=0.0; ny=0.0; nz=0.0;
	} else {
		nx = gradPhi.x/magnPhi;
		ny = gradPhi.y/magnPhi;
		nz = gradPhi.z/magnPhi;
	}

	U = U(0,0,0);
	V = V(0,0,0);
	W = W(0,0,0);

	real_t mag = U*U + V*V + W*W;
	real_t Gamma[27];
	// ##### heq
	real_t F_phi[hPops]; 
	real_t tmp1 = (1.0 - 4.0*(PhaseF - C0)*(PhaseF - C0))/IntWidth;
	for (i=0; i< 27; i++){
		Gamma[i] = calcGamma(i, U, V, W, mag);
		if (i < hPops) F_phi[i] = calcF_phi(i, tmp1, nx, ny, nz);
	}

	<?R
    if (Options$q27){
	#	C(h, w_h * phase * gammah - 0.5 * Fphi)
		C(h, phase * gammah )
    } else {
		C(h, w_h * phase * gammah )
    }
	?>
		
	// ##### geq
	<?R
		w_g = PV(c(paste("wg[",1:27-1,"]",sep="")))
		press = PV("pnorm")
		C(g, press*w_g + (gammag-w_g) )
	?>
        pnorm  = <?R C(sum(g)) ?>;
		PhaseF = <?R C(sum(h)) ?>;
	#ifdef OPTIONS_thermo
		Temp   = Temp(0,0,0);
		Cond   = interp(PhaseF, k_h, k_l);
	#endif
	#ifdef OPTIONS_OutFlow
			if ((NodeType & NODE_BOUNDARY) == NODE_EConvect){
					<?R if (Options$OutFlow){
							C(g_old, g)
							C(h_old, h)     }       ?>
			}
	#endif
}



CudaDeviceFunction void calcIntersectionTriangleId(
												  real_t vec[],
												  int& triangle_index,
												  int& face_index,
												  real_t koeff[],
												  real_t intersection_point[],
												  int& triangle_index2,
												  real_t koeff2[]
												   ) {
	/* Get the ID of the triangle with which the vector intersects */
	real_t plane_angle = -1;

	for (int i = 0; i < 6; ++i) {
		// find on which face the point lies
		// assume it is defined somewhere
		// face_normal[i] = 0
		real_t prod = d3q27_faces_normals[i][0]*vec[0] + d3q27_faces_normals[i][1] * vec[1] + d3q27_faces_normals[i][2] * vec[2];
		// rays in other direction
		if (prod > 0) continue;
		// NOTE: need to properly compare to zero here, otherwise there will be division by zero
		if (fabs(prod) < 1e-10) continue;
		// the same direction as the original vector
		real_t point[3] = { - vec[0] / prod,  - vec[1] / prod, - vec[2] / prod };
		// get coordinate in 2d
		real_t drop_index = d3q27_faces_drop_indexes[i];
		// Mimicing collection.drop()
		real_t point2d[2] = { point[drop_index == 1 ? 0 : (int(drop_index) + 1) % 3], point[drop_index == 1? 2 : (int(drop_index) + 2) % 3] };
		if (point2d[0] >= -1 && point2d[0] <= 1 && point2d[1] >= -1 && point2d[1] <= 1) {
			// it is inside
			face_index = i;
			// determine in which triangle we lie, based on the plane angle
			// (similar to identity circle, going anti clockwise by 45 degrees
			// triangles)
			real_t x = point2d[0];
			real_t y = point2d[1];

			plane_angle = atan2(y, x) * 180.0 / PI;
			plane_angle = plane_angle < 0? plane_angle + 360 : plane_angle;

			// find matching triangle index
			for (int j = 0; j < 8; j++) {
				if (plane_angle >= j*45 && plane_angle < (j + 1) * 45) {
					triangle_index = j;
					break;
				}
			}
            // map triangle to 2D and get barycentric coordinates
            real_t triangle2d[3][2];
            for (int i = 0; i < 3; ++i) {
                // map triangle to 2D and (all points of it)
                triangle2d[i][0] = d3q27_triangles[face_index][triangle_index][i][drop_index == 1? 0 : (int(drop_index) + 1) % 3];
                triangle2d[i][1] = d3q27_triangles[face_index][triangle_index][i][drop_index == 1? 2 : (int(drop_index) + 2) % 3];
            }
			// get barycentric coordinates for the points inside triangle
            real_t detT = (triangle2d[1][1] - triangle2d[2][1]) * (triangle2d[0][0] - triangle2d[2][0]) + \
                           (triangle2d[2][0] - triangle2d[1][0]) * (triangle2d[0][1]- triangle2d[2][1]);

            real_t koeff_1 = (triangle2d[1][1] - triangle2d[2][1]) * (point2d[0] - triangle2d[2][0]) + \
                    (triangle2d[2][0] - triangle2d[1][0]) * (point2d[1]- triangle2d[2][1]);

            real_t koeff_2 = (triangle2d[2][1] - triangle2d[0][1]) * (point2d[0] - triangle2d[2][0]) + \
                     (triangle2d[0][0] - triangle2d[2][0]) * (point2d[1]- triangle2d[2][1]);

            koeff_1 /= detT;
            koeff_2 /= detT;

			// NOTE: Adjustment to prevent round-off errors
			if (koeff_1 < 1e-12) koeff_1 = 0.;
			if (koeff_2 < 1e-12) koeff_2 = 0.;

			intersection_point[0] = point[0];
			intersection_point[1] = point[1];
			intersection_point[2] = point[2];

            koeff[0] = koeff_1; 
            koeff[1] = koeff_2; 
            koeff[2] = 1 - koeff_1 - koeff_2;


			// ----------------------------------
			// TODO: Duplicate code to be removed
			// ----------------------------------

			// get coordinate point in the new reference plane, relative to the point / vertex of the first triangle of the
			// form (-1, -1) (1, -1), etc, the poin2d coordinates relative it should always be in the range (-1, 1), as we want it
			real_t point2_2d[2] = {2*point2d[0] - triangle2d[1][0], 2*point2d[1] - triangle2d[1][1] };
			x = point2_2d[0];
			y = point2_2d[1];

			real_t plane_angle2 = atan2(y, x) * 180.0 / PI;
			plane_angle2 = plane_angle2 < 0? plane_angle2 + 360 : plane_angle2;
			// find matching triangle index
			for (int j = 0; j < 8; j++) {
				if (plane_angle2 >= j*45 && plane_angle2 < (j + 1) * 45) {
					triangle_index2 = j;
					break;
				}
			}

            // map triangle to 2D and get barycentric coordinates
            real_t triangle2_2d[3][2];
            for (int i = 0; i < 3; ++i) {
                // map triangle2_ to 2D and (all point2_s of it)
                triangle2_2d[i][0] = d3q27_triangles[face_index][triangle_index2][i][drop_index == 1? 0 : (int(drop_index) + 1) % 3];
                triangle2_2d[i][1] = d3q27_triangles[face_index][triangle_index2][i][drop_index == 1? 2 : (int(drop_index) + 2) % 3];
            }
			// get barycentric coordinates for the point2_s inside triangle2_
            detT = (triangle2_2d[1][1] - triangle2_2d[2][1]) * (triangle2_2d[0][0] - triangle2_2d[2][0]) + \
                           (triangle2_2d[2][0] - triangle2_2d[1][0]) * (triangle2_2d[0][1]- triangle2_2d[2][1]);

            koeff_1 = (triangle2_2d[1][1] - triangle2_2d[2][1]) * (point2_2d[0] - triangle2_2d[2][0]) + \
                    (triangle2_2d[2][0] - triangle2_2d[1][0]) * (point2_2d[1]- triangle2_2d[2][1]);

            koeff_2 = (triangle2_2d[2][1] - triangle2_2d[0][1]) * (point2_2d[0] - triangle2_2d[2][0]) + \
                     (triangle2_2d[0][0] - triangle2_2d[2][0]) * (point2_2d[1]- triangle2_2d[2][1]);

            koeff_1 /= detT;
            koeff_2 /= detT;

			// NOTE: Adjustment to prevent round-off errors
			if (koeff_1 < 1e-12) koeff_1 = 0.;
			if (koeff_2 < 1e-12) koeff_2 = 0.;

            koeff2[0] = koeff_1;
            koeff2[1] = koeff_2;
            koeff2[2] = 1 - koeff_1 - koeff_2;

			break;
		}
	}
}



//	ITERATION:
CudaDeviceFunction void Run() {
	// propagate it into the next iteration
	IsBoundary = IsBoundary(0,0,0);
	// If desired, incorporate a smoothing stage, in this we simply let diffusion occur
    if ((NodeType & NODE_ADDITIONALS) == NODE_Smoothing) {
		Init_distributions();
    } else {
        updateBoundary();	
    
		#ifdef OPTIONS_BGK
			if (NodeType & NODE_BGK) {
				CollisionBGK();
		}
		#else
			if (NodeType & NODE_MRT)
			{
				CollisionMRT();
			} 
		#endif
	}
        pnorm  = <?R C(sum(g)) ?>;
}

CudaDeviceFunction real_t calcTau(real_t pf){
	real_t tau;
	if ( pf < PhaseField_l){
		tau = tau_l + 0.5;
	} else if (pf > PhaseField_h) {
		tau = tau_h + 0.5;
	} else {
	    if (tauUpdate == 1) { // Linear update:
            tau = 0.5 + tau_l + (pf-PhaseField_l)*(tau_h - tau_l)/(PhaseField_h - PhaseField_l);
        } else if (tauUpdate == 2){ // Inverse update:
		    tau = (pf - PhaseField_l)/(PhaseField_h - PhaseField_l) * (1.0/tau_h - 1.0/tau_l) + 1.0/tau_l;
		    tau = 1.0/tau + 0.5;
		// NOTE: For some reason Viscosity_h and Viscosity_l are set to zero. Deduce it from tau here
		// instead for tauUpdate 3 and tauUpdate 4
        } else if (tauUpdate == 3){	// Viscosity update:
		    real_t DynVisc = Density_l*tau_l / 3.0 + pf * (tau_h*Density_h/3.0 - Density_l*tau_l/3.0);
            real_t rho = getRho();
		    tau = 3.0 * DynVisc / rho + 0.5;
        } else if (tauUpdate == 4) { // update from Zu-He 2013
			real_t mu_l = Density_l * tau_l / 3.0;
			real_t mu_h = Density_h * tau_h / 3.0;
		    real_t DynVisc = mu_l * mu_h * (PhaseField_h - PhaseField_l) / ((pf - PhaseField_l)*mu_l  + (PhaseField_h - pf)*mu_h);
            real_t rho = getRho();
			tau = 3.0 * DynVisc / rho + 0.5;
			//printf("Viscosity is %lf %lf", tau_l/3, tau_h/3);
		} else {
            tau = 0.5 + tau_l + (pf-PhaseField_l)*(tau_h - tau_l)/(PhaseField_h - PhaseField_l);
        }
	}
	return tau;
}

CudaDeviceFunction void calc_Fp(real_t *fx, real_t *fy, real_t *fz, real_t pressure, vector_t gPhi){
	*fx = (-1.0/3.0) * pressure * (Density_h-Density_l) * gPhi.x;
	*fy = (-1.0/3.0) * pressure * (Density_h-Density_l) * gPhi.y;
	*fz = (-1.0/3.0) * pressure * (Density_h-Density_l) * gPhi.z;
}
CudaDeviceFunction void calc_Fb(real_t *fx, real_t *fy, real_t *fz, real_t rho){
        *fx = (Density_h-rho)*BuoyancyX + rho*GravitationX;
	*fy = (Density_h-rho)*BuoyancyY + rho*GravitationY;
	*fz = (Density_h-rho)*BuoyancyZ + rho*GravitationZ;
}
CudaDeviceFunction void calc_Fs(real_t *fx, real_t *fy, real_t *fz, real_t mu, vector_t gPhi){
	#ifdef OPTIONS_thermo
		Temp = Temp(0,0,0);
		SurfaceTension = SurfaceTension(0,0,0);
		Cond = Cond(0,0,0);
		real_t tmpSig, delta_s, dotTMP, magnPhi, magnPhi2;
		magnPhi = sqrt(gPhi.x*gPhi.x + gPhi.y*gPhi.y + gPhi.z*gPhi.z);
		magnPhi2 = magnPhi*magnPhi;
		vector_t gradT;
		<?R
			IsotropicGrad('gradT','Temp')
		?>
		dotTMP = dotProduct(gradT,gPhi);
		if (surfPower < 2) {
			delta_s = 1.5*IntWidth*sigma_T;
			*fx = mu * gPhi.x + delta_s*( magnPhi2*gradT.x - dotTMP*gPhi.x );
			*fy = mu * gPhi.y + delta_s*( magnPhi2*gradT.y - dotTMP*gPhi.y );
			*fz = mu * gPhi.z + delta_s*( magnPhi2*gradT.z - dotTMP*gPhi.z );
		} else {
			vector_t gradSig;
			<?R
				IsotropicGrad('gradSig','SurfaceTension')
			?>
			delta_s = 1.5*IntWidth;
			*fx = mu * gPhi.x + delta_s*gradSig.x*( magnPhi2*gradT.x - dotTMP*gPhi.x );
			*fy = mu * gPhi.y + delta_s*gradSig.y*( magnPhi2*gradT.y - dotTMP*gPhi.y );
			*fz = mu * gPhi.z + delta_s*gradSig.z*( magnPhi2*gradT.z - dotTMP*gPhi.z );			
		}
	#else
		*fx = mu * gPhi.x;
		*fy = mu * gPhi.y;
		*fz = mu * gPhi.z;
	#endif
}

#ifndef OPTIONS_BGK
CudaDeviceFunction void CollisionMRT(){
	PhaseF = PhaseF(0,0,0);
	int i, j;
	real_t C  = PhaseF;
    real_t mu = calcMu( C );
	real_t tau, DynVisc, rho, p;			// Macroscopic Properties
	vector_t n, gradPhi;					// Phase field gradients
	real_t magnPhi;							// Normals
	real_t F_pressure[3], F_body[3], F_mu[3], F_surf[3], F_total[3]; // Forces
	real_t tmp1, stress[6]={0.0,0.0,0.0,0.0,0.0,0.0};     // Stress tensor calculation
	real_t F_phi[hPops], heq[hPops];				// Phase field collision terms
	real_t F_i[27];							// Momentum distribution forcing term
	real_t m[27]; 							//MRT Details

	// Find Macroscopic Details
	rho = Density_l + (C - PhaseField_l)*(Density_h - Density_l)/(PhaseField_h - PhaseField_l);

	updateMyGlobals( C );
	
	real_t m0[27];
	<?R
		EQ = MRT_eq(U,PV(1),u,mat=t(M))
		selR = EQ$order < 10
		EQ$Req[1] = PV("p")
		EQ$feq = solve(M) %*% EQ$Req
		Omega = PV(rep(1,sum(selR)))
		Omega[5:9] = PV("tau")^(-1)
		Omega[1:4] = PV(1)
		m0 = PV("m0[",1:27-1,"]")
		C(m0[selR], (M %*% g)[selR])
		F_total = PV("F_total[",1:3-1,"]")
		rho = PV("rho")
		rho.inv = rho ^ (-1)
	?>
	p = m0[0];

	tau = calcTau( C );

	// GRADIENTS AND NORMALS
	gradPhi = calcGradPhi();
	magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z);

	if (magnPhi < minGradient){
		n.x=0.0; n.y=0.0; n.z=0.0;
	} else {
		n.x = gradPhi.x/magnPhi;
		n.y = gradPhi.y/magnPhi;
		n.z = gradPhi.z/magnPhi;
	}
	//magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z + 1e-2);
	//n.x = gradPhi.x/magnPhi;
	//n.y = gradPhi.y/magnPhi;
	//n.z = gradPhi.z/magnPhi;

	// CALCULATE FORCES:
    calc_Fp(&F_pressure[0], &F_pressure[1], &F_pressure[2], p, gradPhi);
	calc_Fb(&F_body[0], &F_body[1], &F_body[2], rho);
    calc_Fs(&F_surf[0], &F_surf[1], &F_surf[2], mu, gradPhi);
	//  Viscous Force:
	for (j=0;j<2;j++) {
	<?R
		C(m[selR], (m0 - EQ$Req)[selR] * Omega)

		stress = PV("stress[",1:6-1,"]");
		new_g = solve(M) %*% m
		C(stress[1], sum( U[,1]*U[,1] * new_g )); # XX
		C(stress[2], sum( U[,1]*U[,2] * new_g )); # XY
		C(stress[3], sum( U[,1]*U[,3] * new_g )); # XZ
		C(stress[4], sum( U[,2]*U[,2] * new_g )); # YY
		C(stress[5], sum( U[,2]*U[,3] * new_g )); # YZ
		C(stress[6], sum( U[,3]*U[,3] * new_g )); # ZZ
	?>
		F_mu[0] = (0.5-tau) * (Density_h-Density_l) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y + stress[2]*gradPhi.z);
		F_mu[1] = (0.5-tau) * (Density_h-Density_l) * (stress[1]*gradPhi.x + stress[3]*gradPhi.y + stress[4]*gradPhi.z);
		F_mu[2] = (0.5-tau) * (Density_h-Density_l) * (stress[2]*gradPhi.x + stress[4]*gradPhi.y + stress[5]*gradPhi.z);
		F_total[0] = F_surf[0] + F_pressure[0] + F_body[0] + F_mu[0];
		F_total[1] = F_surf[1] + F_pressure[1] + F_body[1] + F_mu[1];
		F_total[2] = F_surf[2] + F_pressure[2] + F_body[2] + F_mu[2];

	<?R 	C( u, m0[2:4] + 0.5 * F_total * rho.inv) ?>
	}
	// PHASE FIELD POPULATION UPDATE:
	tmp1 = (1.0 - 4.0*(C - 0.5)*(C - 0.5))/IntWidth;
	<?R
		n = PV("n",c(".x",".y",".z"))
		EQ_h = MRT_eq(U[1:PF_velocities,],PV(1),u)
		C(heq, EQ_h$feq * PV("C"))
		EQ_h = MRT_eq(U[1:PF_velocities,],PV(1),PV(c(0,0,0)))
		if (Options$q27){
			wh = EQ_h$feq
		    EQ_h = MRT_eq(U[1:PF_velocities,],PV(1),u)
		} else {
			wh = c(rep(16/72,1),rep(8/72,6),rep(1/72,8))
        	}
		C(Fphi, wh * PV("tmp1") * (U[1:PF_velocities,] %*% n))
    		C(h, h - omega * (h - heq + 0.5*Fphi) + Fphi)

		mF = PV(rep(0,27))
		mF[2:4] = F_total * rho.inv

		C(m, m0 - (m0 - EQ$Req + mF*0.5)[selR] * Omega + mF)
		C(g, invM %*% m)
	?>

    updateTrackers( C );
}
#endif

//######BOUNDARY CONDITIONS######//
#ifdef OPTIONS_OutFlow
#define myMax(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a > _b ? _a : _b; })

CudaDeviceFunction void EConvect(){
	real_t U_local = myMax(0, U(-1,0,0));
	real_t invU = 1.0/(1+ U_local);
	<?R
		if (Options$OutFlow) {
			C(g, (g_old + U_loc*g_n)*U_inv)
			C(h, (h_old + U_loc*h_n)*U_inv)
			
			C(g_old, g)
			C(h_old, h)
		}
	?>
}

CudaDeviceFunction void ENeumann(){
	<?R
		if (Options$OutFlow){
			C(g, PV(paste0(g_neighbours,"(",-Density$dx[Density$group=="g"]-1,",",-Density$dy[Density$group=="g"],",",-Density$dz[Density$group=="g"],")")))	
			C(h, PV(paste0(h_neighbours,"(",-Density$dx[Density$group=="h"]-1,",",-Density$dy[Density$group=="h"],",",-Density$dz[Density$group=="h"],")")))	
		}
	?>
}
#endif

CudaDeviceFunction void WVelocity(){
	U = VelocityX;
	V = VelocityY;
	W = VelocityZ;
	if ( developedFlow > 0.1 ){
		U = 6.0 * Uavg * Y*(HEIGHT - Y)/(HEIGHT*HEIGHT);
		V = 0.0;
		W = 0.0;
	}
	if ( developedPipeFlow_X > 0.1 ){
		U = 2.0 * Uavg * (1 - pow( (sqrt(pow((Y-pipeCentre_Y),2) + pow((Z-pipeCentre_Z),2)) / pipeRadius),2));
		V = 0.0;
		W = 0.0;
	}
	<?R
		n = c(-1,0,0)
		geq = EQ$feq
		bounce = Bounce(U)
		sel = as.vector( (U %*% n) < 0)

		sel2 = as.vector( ( U %*% n) == 0)	
		exM = (g[sel2] - geq[sel2]) %*% U[sel2,]
        Unknowns = 1.0/max(colSums(U[sel2,]^2)) # should be 6 for q27, 4 for q15
        Nmat = t(U[sel,]) %*% U[sel,]

		C(g[sel], g[bounce][sel] + (geq[sel] - geq[bounce][sel]) - 0.5* (exM %*% solve(Nmat) %*% t(U))[sel])
	?>
	<?R
		U_PF = U[1:PF_velocities,]
        	pf = PV("PhaseField")
		n = c(-1,0,0)
		heq = pf * EQ_h$feq
		bounce = Bounce(U_PF)
		sel = as.vector( (U_PF %*% n) < 0)

		sel2 = as.vector( ( U_PF %*% n) == 0)	
		exM = (h[sel2] - heq[sel2]) %*% rep(1,sum(sel2)) 
		Unknowns = 1.0/sum(sel)

		C(h[sel], heq[sel] + heq[bounce][sel] - h[bounce][sel] - 0.5 * Unknowns * (exM))
	?>
}

CudaDeviceFunction void EVelocity(){
	U = VelocityX;
	V = VelocityY;
	W = VelocityZ;
	if ( Uavg > 0 ){
		U = 6.0 * Uavg * Y*(HEIGHT - Y)/(HEIGHT*HEIGHT);
		V = 0.0;
		W = 0.0;
	}
	<?R
		n = c(1,0,0)
		geq = EQ$feq
		bounce = Bounce(U)
		sel = as.vector( (U %*% n) < 0)

		sel2 = as.vector( ( U %*% n) == 0)	
		exM = (g[sel2] - geq[sel2]) %*% U[sel2,]
        Unknowns = 1.0/max(colSums(U[sel2,]^2)) 
        Nmat = t(U[sel,]) %*% U[sel,]

		C(g[sel], g[bounce][sel] + (geq[sel] - geq[bounce][sel]) - 0.5 * (exM %*% solve(Nmat) %*% t(U))[sel])
	?>
	<?R
		U_PF = U[1:PF_velocities,]
       	pf = PV("PhaseField")
		n = c(1,0,0)
		heq = pf * EQ_h$feq
		bounce = Bounce(U_PF)
		sel = as.vector( (U_PF %*% n) < 0)

		sel2 = as.vector( ( U_PF %*% n) == 0)	
		exM = (h[sel2] - heq[sel2]) %*% rep(1,sum(sel2)) 
		Unknowns = 1.0/sum(sel)

		C(h[sel], heq[sel] + heq[bounce][sel] - h[bounce][sel] - 0.5 * Unknowns * (exM))
	?>
}

CudaDeviceFunction void Velocity_Y_neg(){
	U = VelocityX;
	V = VelocityY;
	W = VelocityZ;
	<?R
		n = c(0,-1,0)
			geq = EQ$feq
			bounce = Bounce(U)
			sel = as.vector( (U %*% n) < 0)

		sel2 = as.vector( ( U %*% n) == 0)	
		exM = (g[sel2] - geq[sel2]) %*% U[sel2,]
		Unknowns = 1.0/9.0

		C(g[sel], g[bounce][sel] + (geq[sel] - geq[bounce][sel]) - Unknowns * (exM %*% t(U))[sel])
	?>
	{
		<?R ZouHeRewrite(EQ_h, h, c(0,-1,0),"pressure", rhs=PV("PhaseField")) ?>
	}
}

CudaDeviceFunction void NVelocity(){
	U = VelocityX;
	V = VelocityY;
	W = VelocityZ;
	<?R
		n = c(0,0,-1)
			geq = EQ$feq
			bounce = Bounce(U)
			sel = as.vector( (U %*% n) < 0)

		sel2 = as.vector( ( U %*% n) == 0)	
		exM = (g[sel2] - geq[sel2]) %*% U[sel2,]
		Unknowns = 1.0/9.0

		C(g[sel], g[bounce][sel] + (geq[sel] - geq[bounce][sel]) - Unknowns * (exM %*% t(U))[sel])
	?>
	{
		<?R ZouHeRewrite(EQ_h, h, c(0,0,-1),"pressure", rhs=PV("PhaseField")) ?>
	}
}

CudaDeviceFunction void WPressure(){
	{
		<?R ZouHeRewrite(EQ, g, c(-1,0,0),"pressure")  ?>
	}
	{
		<?R ZouHeRewrite(EQ_h, h, c(-1,0,0),"pressure", rhs=PV("PhaseField")) ?>
	}
}

CudaDeviceFunction void EPressure(){
    real_t d = getRho();
	real_t pstar = Pressure / (d*cs2);
	<?R
        EQ = MRT_eq(U,PV(1),u,mat=t(M))
       	pstar = PV("pstar")
		n = c(1,0,0)
		geq = pstar*w_g + (EQ$feq - w_g)
		bounce = Bounce(U)
		sel = as.vector( (U %*% n) < 0)

		sel2 = as.vector( ( U %*% n) == 0)	
		exM = (g[sel2] - geq[sel2]) %*% rep(1,sum(sel2)) 
		Unknowns = 1.0/sum(sel)

		C(g[sel], geq[sel] + geq[bounce][sel] - g[bounce][sel] - 0.5 * Unknowns * (exM))
	?>
	<?R
		U_PF = U[1:PF_velocities,]
       	pf = PV("PhaseField")
		n = c(1,0,0)
		heq = pf * EQ_h$feq
		bounce = Bounce(U_PF)
		sel = as.vector( (U_PF %*% n) < 0)

		sel2 = as.vector( ( U_PF %*% n) == 0)	
		exM = (h[sel2] - heq[sel2]) %*% rep(1,sum(sel2)) 
		Unknowns = 1.0/sum(sel)

		C(h[sel], heq[sel] + heq[bounce][sel] - h[bounce][sel] - 0.5 * Unknowns * (exM))
	?>
}

CudaDeviceFunction void MovingNWall(){
	g4  = g3;
	g24 = g25;
	g26 = g23;

	g9  = g12 + VelocityX/36.0;
	g13 = g8  + VelocityX/36.0;
	g17 = g16 + VelocityX/9.0;

	g10 = g11 - VelocityX/36.0;
	g14 = g7  - VelocityX/36.0;
	g18 = g15 - VelocityX/9.0;
	{
		<?R ZouHeRewrite(EQ_h, h, c(1,0,0),"pressure", rhs=PV("PhaseField")) ?>
	}

//	h4  = h3 ;
//	h9  = h12;
//	h10 = h11;
//	h13 = h8 ;
//	h14 = h7 ;
}

CudaDeviceFunction void MovingSWall(){
	g3  = g4;
	g25 = g24;
	g23 = g26;

	g12 = g9  - VelocityX/36.0;
	g8  = g13 - VelocityX/36.0;
	g16 = g17 - VelocityX/9.0;

	g11 = g10 + VelocityX/36.0;
	g7  = g14 + VelocityX/36.0;
	g15 = g18 + VelocityX/9.0;
	{
		<?R ZouHeRewrite(EQ_h, h, c(1,0,0),"pressure", rhs=PV("PhaseField")) ?>
	}

//	h3  = h4 ;
//	h12 = h9 ;
//	h11 = h10;
//	h8  = h13 ;
//	h7  = h14 ;
}

CudaDeviceFunction void BounceBack(){
	real_t tmp;
	tmp = g0; g0 = g0; g0 = tmp;
	tmp = g1; g1 = g2; g2 = tmp;
	tmp = g3; g3 = g4; g4 = tmp;
	tmp = g5; g5 = g6; g6 = tmp;
	tmp = g7; g7 = g14; g14 = tmp;
	tmp = g8; g8 = g13; g13 = tmp;
	tmp = g9; g9 = g12; g12 = tmp;
	tmp = g10; g10 = g11; g11 = tmp;
	tmp = g15; g15 = g18; g18 = tmp;
	tmp = g16; g16 = g17; g17 = tmp;
	tmp = g19; g19 = g22; g22 = tmp;
	tmp = g20; g20 = g21; g21 = tmp;
	tmp = g23; g23 = g26; g26 = tmp;
	tmp = g24; g24 = g25; g25 = tmp;

	tmp = h0; h0 = h0; h0 = tmp;
	tmp = h1; h1 = h2; h2 = tmp;
	tmp = h3; h3 = h4; h4 = tmp;
	tmp = h5; h5 = h6; h6 = tmp;
	tmp = h7; h7 = h14; h14 = tmp;
	tmp = h8; h8 = h13; h13 = tmp;
	tmp = h9; h9 = h12; h12 = tmp;
	tmp = h10; h10 = h11; h11 = tmp;
#ifdef OPTIONS_q27
	tmp = h15; h15 = h18; h18 = tmp;
	tmp = h16; h16 = h17; h17 = tmp;
	tmp = h19; h19 = h22; h22 = tmp;
	tmp = h20; h20 = h21; h21 = tmp;
	tmp = h23; h23 = h26; h26 = tmp;
	tmp = h24; h24 = h25; h25 = tmp;
#endif
}
//############//

CudaDeviceFunction vector_t getA(){
	vector_t ret;
	return ret;
}
CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = PhaseF(0,0);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}

#ifdef OPTIONS_BGK
CudaDeviceFunction void CollisionBGK(){
    PhaseF = PhaseF(0,0,0);
	int i, j;
	real_t C  = PhaseF; 
    real_t mu = calcMu( C );
	real_t tau, DynVisc, rho, p;			// Macroscopic Properties
	vector_t gradPhi;				// Phase field gradients
	real_t nx, ny, nz, magnPhi;			// Normals
	real_t Gamma[27], geq[27], mag;			// equilibrium, pressure equilibrium, velocity magnitude
	real_t F_surf[3], F_pressure[3], F_body[3], F_mu[3], F_total[3]; // Forces
	real_t tmp1, stress[6]={0.0,0.0,0.0,0.0,0.0,0.0};     // Stress tensor calculation
	real_t F_phi[hPops], heq[hPops];			// Phase field collision terms
	real_t F_i[27];					// Momentum distribution forcing term

	// Find Macroscopic Details
	rho = Density_l + (C - PhaseField_l)*(Density_h - Density_l)/(PhaseField_h - PhaseField_l);
	p = <?R C(sum(g)) ?>;
	tau = calcTau( C );

	updateMyGlobals( C );

	// GRADIENTS AND NORMALS
	gradPhi = calcGradPhi();
	magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z + 1e-32);
	nx = gradPhi.x/magnPhi;
	ny = gradPhi.y/magnPhi;
	nz = gradPhi.z/magnPhi;

	// CALCULATE FORCES:
    calc_Fp(&F_pressure[0], &F_pressure[1], &F_pressure[2], p, gradPhi);
	calc_Fb(&F_body[0], &F_body[1], &F_body[2], rho);
    calc_Fs(&F_surf[0], &F_surf[1], &F_surf[2], mu, gradPhi);
    // VISCOUS FORCE:
    for (j=0;j<2;j++) {
    // GAMMA AND EQUILIBRIUM
        mag = U*U + V*V + W*W;
        for (i=0; i< 27; i++){
            Gamma[i] = calcGamma(i, U, V, W, mag);
            geq[i] = wg[i]*p + Gamma[i] - wg[i];
        }

    <?R 	C( geq, g - geq ) ?>
            // Stress/strain Tensor
        for (i=0; i< 6 ; i++)
        {
            stress[i] = 0.0;
        }
        for (i=0; i< 27; i++){
            stress[0] += geq[i]*d3q27_ex[i]*d3q27_ex[i];
            stress[1] += geq[i]*d3q27_ex[i]*d3q27_ey[i];
            stress[2] += geq[i]*d3q27_ex[i]*d3q27_ez[i];
            stress[3] += geq[i]*d3q27_ey[i]*d3q27_ey[i];
            stress[4] += geq[i]*d3q27_ey[i]*d3q27_ez[i];
            stress[5] += geq[i]*d3q27_ez[i]*d3q27_ez[i];
        }

        F_mu[0] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y + stress[2]*gradPhi.z);
        F_mu[1] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[1]*gradPhi.x + stress[3]*gradPhi.y + stress[4]*gradPhi.z);
        F_mu[2] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[2]*gradPhi.x + stress[4]*gradPhi.y + stress[5]*gradPhi.z);
        F_total[0] = F_surf[0] + F_pressure[0] + F_body[0] + F_mu[0];
        F_total[1] = F_surf[1] + F_pressure[1] + F_body[1] + F_mu[1];
        F_total[2] = F_surf[2] + F_pressure[2] + F_body[2] + F_mu[2];

    <?R C( u, g %*% U) ?>
        U = U + (0.5*F_total[0])/rho;
        V = V + (0.5*F_total[1])/rho;
        W = W + (0.5*F_total[2])/rho;
    }

	// PHASE FIELD POPULATION UPDATE:
	tmp1 = (1.0 - 4.0*(C - 0.5)*(C - 0.5))/IntWidth;
	for (i=0; i< hPops; i++){
		F_phi[i] = calcF_phi(i, tmp1, nx, ny, nz); 		// Forcing Terms
		heq[i] = C * Gamma[i];      	// heq
	}

	<?R	C(h, h - omega * ( h - w_h*heq + 0.5*Fphi) + Fphi) ?>

	// PRESSURE EVOLUTION UPDATE:
	for (i=0; i< 27; i++) {
		F_i[i] = 3.0*wg[i] * (F_total[0]*d3q27_ex[i] + F_total[1]*d3q27_ey[i] + F_total[2]*d3q27_ez[i])/rho;
	}
	real_t omega_g = 1.0/tau;
	<?R	
		om= PV("omega_g")
		C(g, g - (geq+0.5*Fi)*om + Fi)
	?>
    updateTrackers( C );
}
#endif

//######UPDATE FUNCTIONS#######//
CudaDeviceFunction void updateBoundary(){
    switch (NodeType & NODE_BOUNDARY) {
		case NODE_Solid:
		case NODE_Wall:
			BounceBack();
			break;
		case NODE_EVelocity:
			EVelocity();
			break;
		case NODE_WVelocity:
			WVelocity();
			break;
		case NODE_NVelocity:
			NVelocity();
			break;
		case NODE_Velocity_Y_neg:
			Velocity_Y_neg();
			break;
		case NODE_EPressure:
			EPressure();
			break;
		case NODE_WPressure:
			WPressure();
			break;
		case NODE_MovingWall_N:
			MovingNWall();
			break;
		case NODE_MovingWall_S:
			MovingSWall();
			break;
		#ifdef OPTIONS_OutFlow
			case NODE_EConvect:
				EConvect();
				break;
			case NODE_ENeumann:
				ENeumann();
				break;
		#endif
	}
}

CudaDeviceFunction void updateMyGlobals(real_t pf){
	real_t tmpPF = 1 - pf;
	real_t rho = Density_l + ((pf) - PhaseField_l)*(Density_h - Density_l)/(PhaseField_h - PhaseField_l);
	real_t u2mag = (U*U+V*V+W*W);
	AddToTotalDensity( rho ); // Add globals of post-stream, pre-collide macroscopic globals.
	AddToKineticEnergy( rho * u2mag );

	if ( (pf) < 0.5 ) 
	{
	    AddToGasTotalVelocity( tmpPF*sqrt(u2mag));
	    AddToGasTotalVelocityX( tmpPF*U );
	    AddToGasTotalVelocityY( tmpPF*V );
	    AddToGasTotalVelocityZ( tmpPF*W );
	    AddToGasTotalPhase( tmpPF );
	    AddToXLocation( tmpPF*X );
	} else {
	    AddToLiqTotalVelocity( pf*sqrt(u2mag));
	    AddToLiqTotalVelocityX( U*pf );
	    AddToLiqTotalVelocityY( V*pf );
	    AddToLiqTotalVelocityZ( W*pf );
	    AddToLiqTotalPhase( pf );
	    AddToTotalDensityLiquid( rho );
	}

	if (IsSpecialBoundaryPoint) {
		AddToSpecialBoundaryPoints(1);
	}
}

CudaDeviceFunction void updateTrackers(real_t C){
	real_t location;

	// track top of the interface in Y direction, only on actual nodes
	if ((NodeType & NODE_BGK) || (NodeType & NODE_MRT)) {
		if ( C < 0.5 && PhaseF(0, -1, 0) > 0.5) {
			location = Y - (C-0.5)/(C-PhaseF(0,-1,0));
			AddToInterfaceYTop(location);
		}
	}

	// TODO: Adjust the position to be more precice
	// If my value if above 0.5 and next node is solid
	// taking minimum of those positions on Y direction
	// we obtaine the most bottom point of the interface
	if (IsBoundary(1, 0, 0) && PhaseF(0, 0, 0) > 0.5) {
		real_t distance_to_top = constContainer.ny - Y;
		AddToDropletLeftInterfaceBottomY(distance_to_top);
	}

	if (IsBoundary(-1, 0, 0) && PhaseF(0, 0, 0) > 0.5) {
		real_t distance_to_top = constContainer.ny - Y;
		AddToDropletRightInterfaceBottomY(distance_to_top);
	}

	switch (NodeType & NODE_ADDITIONALS) {
		case NODE_Centerline:
		    if ( fabs(xyzTrack-1) < 1e-3 )
		    {  // track along X
                if (C < 0.5 && PhaseF(1,0,0) > 0.5)
                {
                    location = X + (C-0.5)/(C-PhaseF(1,0,0));
                    AddToInterfacePosition(location);
                    AddToVback(U);
                }
                if (C >0.5 && PhaseF(-1,0,0) < 0.5)
                {
                    AddToVfront(U);
                }
		    } else if ( fabs(xyzTrack-2) < 1e-3)
		    { // track along Y
                if (C < 0.5 && PhaseF(0,1,0) > 0.5)
                {
                    location = Y + (C-0.5)/(C-PhaseF(0,1,0));
                    AddToInterfacePosition(location);
                    AddToVback(V);
                }
                if (C >0.5 && PhaseF(0,-1,0) < 0.5)
                {
                    AddToVfront(V);
                }
		    } else if ( fabs(xyzTrack-3) < 1e-3)
		    { // track along Z
			if (C < 0.5 && PhaseF(0,0,1) > 0.5)
                {
                    location = Z + (C-0.5)/(C-PhaseF(0,0,1));
                    AddToInterfacePosition(location);
                    AddToVback(W);
                }
                if (C >0.5 && PhaseF(0,0,-1) < 0.5)
                {
                    AddToVfront(W);
                }
		    } else if ( fabs(xyzTrack-4) < 1e-3 )
		    {  // track reverse along X
                if (C < 0.5 && PhaseF(-1,0,0) > 0.5)
                {
                    location = X - (C-0.5)/(C-PhaseF(-1,0,0));
                    AddToInterfacePosition(location);
				    AddToVback(U);
			    }
            } else if ( fabs(xyzTrack-5) < 1e-3 )
		    {  // track reverse along Y (e.g. tracking north pole of the droplet
			   // as it is falling)
                if (C < 0.5 && PhaseF(0,-1,0) > 0.5)
                {
                    location = Y - (C-0.5)/(C-PhaseF(0,-1,0));
                    AddToInterfacePosition(location);
			    }
            }

		case NODE_Spiketrack:
			if (C < 0.5 && PhaseF(0,1,0) > 0.5)
			{
				location = Y + (C-0.5)/(C-PhaseF(0,1,0));
				AddToRTISpike(location);
			}
		case NODE_Saddletrack:
			if (C < 0.5 && PhaseF(0,1,0) > 0.5)
			{
				location = Y + (C-0.5)/(C-PhaseF(0,1,0));
				AddToRTISaddle(location);
			}
		case NODE_Bubbletrack:
			if (C < 0.5 && PhaseF(0,1,0) > 0.5)
			{
				location = Y + (C-0.5)/(C-PhaseF(0,1,0));
				AddToRTIBubble(location);
			}
	}
}
//#############//
//######THERMOCAPILLARY UPDATE######//
#ifdef OPTIONS_thermo
	CudaDeviceFunction real_t getT(){
		return Temp(0,0,0);
	}
	CudaDeviceFunction real_t getST(){
		real_t surfaceTen;
		if (surfPower > 1) {
			surfaceTen = sigma + sigma_TT*pow((Temp(0,0,0) - T_ref),surfPower) * (1.0/surfPower);
		} else {
			surfaceTen = sigma + sigma_T*(Temp(0,0,0) - T_ref);
		}
		return surfaceTen;
	}
	CudaDeviceFunction void TempCopy(){
		// Save everything from buffer 1 to 2.
		g0  = g0(0,0,0);
		g1  = g1(0,0,0);
		g2  = g2(0,0,0);
		g3  = g3(0,0,0);
		g4  = g4(0,0,0);
		g5  = g5(0,0,0);
		g6  = g6(0,0,0);
		g7  = g7(0,0,0);
		g8  = g8(0,0,0);
		g9  = g9(0,0,0);
		g10 = g10(0,0,0);
		g11 = g11(0,0,0);
		g12 = g12(0,0,0);
		g13 = g13(0,0,0);
		g14 = g14(0,0,0);
		g15 = g15(0,0,0);
		g16 = g16(0,0,0);
		g17 = g17(0,0,0);
		g18 = g18(0,0,0);
		g19 = g19(0,0,0);
		g20 = g20(0,0,0);
		g21 = g21(0,0,0);
		g22 = g22(0,0,0);
		g23 = g23(0,0,0);
		g24 = g24(0,0,0);
		g25 = g25(0,0,0);
		g26 = g26(0,0,0);

		h0 = h0(0,0,0);
		h1 = h1(0,0,0);
		h2 = h2(0,0,0);
		h3 = h3(0,0,0);
		h4 = h3(0,0,0);
		h5 = h4(0,0,0);
		h6 = h5(0,0,0);
		h7 = h7(0,0,0);
		h8 = h8(0,0,0);
		h9 = h9(0,0,0);
		h10 = h10(0,0,0);
		h11 = h11(0,0,0);
		h12 = h12(0,0,0);
		h13 = h13(0,0,0);
		h14 = h14(0,0,0);

		U = U(0,0,0);
		V = V(0,0,0);
		W = W(0,0,0);

		nw_x = nw_x(0,0,0);
		nw_y = nw_y(0,0,0);
		nw_z = nw_z(0,0,0);

		PhaseF = PhaseF(0,0,0);

		Temp = Temp(0,0,0); 
		Cond = Cond(0,0,0); 
		SurfaceTension = SurfaceTension(0,0,0);
	}

	CudaDeviceFunction void ThermalCopy(){
		Temp = Temp(0,0,0); 
		Cond = Cond(0,0,0); 
		SurfaceTension = SurfaceTension(0,0,0);
	}

	CudaDeviceFunction real_t exp_thermal_source(real_t x, real_t y){
		real_t distance_sqr = ((x-ts_X)*(x-ts_X) + (y-ts_Y)*(y-ts_Y));
		if ( distance_sqr <= ts_dia*ts_dia) {
			return (thermal_source * exp( -2.0 * distance_sqr / (ts_ws*ts_ws) ));
		} else {
			return 0.0;
		}
	}

	CudaDeviceFunction void TempUpdate1(){
		PhaseF = PhaseF(0,0,0);
		if ( IamWall || IamSolid || ((NodeType & NODE_ADDITIONALS) == NODE_ConstantTemp) ) {
			RK1 = Temp(0,0,0);
		} else {
			real_t myCp, lapT, rho, tmpT, tmpK, UpdateT;
			int i;
			vector_t gradT = {0.0,0.0,0.0};
			vector_t gradK = {0.0,0.0,0.0}; 
			vector_t vel   = {U(0,0,0), V(0,0,0), W(0,0,0)};
			myCp = interp(PhaseF, cp_h, cp_l);
			rho  = interp(PhaseF, Density_h, Density_l);
			<?R
				IsotropicGrad('gradT', 'Temp')
				IsotropicGrad('gradK', 'Cond')
				myLaplace('lapT', 'Temp')
			?>
			// RK1 = Tn + 0.5h1
			RK1 = Temp(0,0,0) + stabiliser*0.5*(-1.0*dotProduct(vel, gradT) + (1.0/(rho*myCp)) * (dotProduct(gradK,gradT) + Cond(0,0,0)*lapT));
		}
	}

	CudaDeviceFunction void TempUpdate2(){
		PhaseF = PhaseF(0,0,0);
		if ( IamWall || IamSolid || ((NodeType & NODE_ADDITIONALS) == NODE_ConstantTemp) ) {
			RK2 = Temp(0,0,0);
		} else {
			real_t myCp, lapT, rho, tmpT, tmpK, UpdateT;
			int i;
			vector_t gradT = {0.0,0.0,0.0};
			vector_t gradK = {0.0,0.0,0.0}; 
			vector_t vel   = {U(0,0,0), V(0,0,0), W(0,0,0)};
			myCp = interp(PhaseF, cp_h, cp_l);
			rho  = interp(PhaseF, Density_h, Density_l);

			<?R
				IsotropicGrad('gradT', 'RK1')
				IsotropicGrad('gradK', 'Cond')
				myLaplace('lapT', 'RK1')
			?>      
			// RK2 = Tn + 0.5h2
			RK2 = Temp(0,0,0) + stabiliser*0.5*(-1.0*dotProduct(vel, gradT) + (1.0/(rho*myCp)) * (dotProduct(gradK,gradT) + Cond(0,0,0)*lapT));
		}
	}

	CudaDeviceFunction void TempUpdate3(){
		PhaseF = PhaseF(0,0,0);
		RK2 = RK2(0,0,0);
		if ( IamWall || IamSolid || ((NodeType & NODE_ADDITIONALS) == NODE_ConstantTemp) ) {
			RK3 = Temp(0,0,0);
		//	} else if ((NodeType & NODE_ADDITIONALS) == NODE_EAdiabatic) {
		//		RK3 = Temp(-1,0,0);
		} else {
			real_t myCp, lapT, rho, tmpT, tmpK, UpdateT;
			int i;
			vector_t gradT = {0.0,0.0,0.0};
			vector_t gradK = {0.0,0.0,0.0}; 
			vector_t vel   = {U(0,0,0), V(0,0,0), W(0,0,0)};
			myCp = interp(PhaseF, cp_h, cp_l);
			rho  = interp(PhaseF, Density_h, Density_l);

			<?R
				IsotropicGrad('gradT', 'RK2')
				IsotropicGrad('gradK', 'Cond')
				myLaplace('lapT', 'RK2')
			?>  
			// RK3 = Tn + h3
			RK3 = Temp(0,0,0) + stabiliser*1.0*(-1.0*dotProduct(vel, gradT) + (1.0/(rho*myCp)) * (dotProduct(gradK,gradT) + Cond(0,0,0)*lapT));
		}
	}

	CudaDeviceFunction void TempUpdate4(){
		PhaseF = PhaseF(0,0,0);
		RK3 = RK3(0,0,0);
		if ( IamWall || IamSolid || ((NodeType & NODE_ADDITIONALS) == NODE_ConstantTemp) ) {
			Temp = Temp(0,0,0);
		//	} else if ((NodeType & NODE_ADDITIONALS) == NODE_EAdiabatic) {
		//		Temp = RK3(0,0,0);		
		} else {
			real_t myCp, lapT, rho, tmpT, tmpK, UpdateT;
			int i;
			vector_t gradT = {0.0,0.0,0.0};
			vector_t gradK = {0.0,0.0,0.0}; 
			vector_t vel   = {U(0,0,0), V(0,0,0), W(0,0,0)};
			myCp = interp(PhaseF, cp_h, cp_l);
			rho  = interp(PhaseF, Density_h, Density_l);

			<?R
				IsotropicGrad('gradT', 'RK3')
				IsotropicGrad('gradK', 'Cond')
				myLaplace('lapT', 'RK3')
			?>  

			UpdateT = Temp(0,0,0);
			Temp = (1-4.0/3.0)*UpdateT + (2*RK1(0,0,0) + 4*RK2(0,0,0) + 2*RK3(0,0,0) - 
			         stabiliser*(1.0*dotProduct(vel, gradT) + (1.0/(rho*myCp)) * (dotProduct(gradK,gradT) + Cond(0,0,0)*lapT )))/6.0;
			
			Temp = Temp + stabiliser*exp_thermal_source(X, Y);

			AddToTempChange( (Temp-UpdateT)*(Temp-UpdateT)  );
		}
		if (surfPower > 1) {
			SurfaceTension = sigma + sigma_TT*pow((Temp(0,0,0) - T_ref),surfPower) * (1.0/surfPower);
		} else {
			SurfaceTension = sigma + sigma_T*(Temp(0,0,0) - T_ref);
		}
	}

	CudaDeviceFunction void BoundUpdate(){
		if ((NodeType & NODE_ADDITIONALS) == NODE_EAdiabatic) {
			Temp = Temp(-1,0,0);
		} else if ((NodeType & NODE_ADDITIONALS) == NODE_WAdiabatic){
			Temp = Temp(1,0,0);
		} else {
			Temp = Temp(0,0,0);
		}
		if (surfPower > 1) {
			SurfaceTension = sigma + sigma_TT*pow((Temp(0,0,0) - T_ref),surfPower) * (1.0/surfPower);
		} else {
			SurfaceTension = sigma + sigma_T*(Temp(0,0,0) - T_ref);
		}
	}

	CudaDeviceFunction real_t dotProduct( vector_t a, vector_t b) {
		return a.x*b.x + a.y*b.y + a.z*b.z;
	}

	CudaDeviceFunction real_t interp(real_t current, real_t upper, real_t lower){
		return lower + current*(upper - lower);
	}
#endif
//#############//

/* MRT Matrix Check:
<?R
	options(width=200)
	print(M)

	printf <- function(...) cat(sprintf(...))

	myWeighting = c(8./27.,
					2./27., 2./27., 2./27., 2./27., 2./27., 2./27.,
					1./216., 1./216., 1./216., 1./216.,
					1./216., 1./216., 1./216., 1./216.,
					1./54.,  1./54.,  1./54.,  1./54.,
					1./54.,  1./54.,  1./54.,  1./54.,
					1./54.,  1./54.,  1./54.,  1./54.)
	printf("Orthogonality Check \n")
	for (i in 1:27) {
		printf("Moment %d: ", i-1)
		for (j in i:27) {
			tmp <- myWeighting %*% ( M[i,] * M[j,] )
			printf(" %.2f,", tmp)  
		}
		printf("\n")
	}
?>
*/

