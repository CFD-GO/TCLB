<?R  
	source("conf.R")
	c_header();
	source("lib/boundary.R")
	source("lib/feq.R")


	if (NumberOfDREs > 0){
		i = 1
		gname = paste("dre",i,sep="_")
		dre_gnames = c(gname)
		fs = list( PV(DensityAll$name[DensityAll$group==gname]) )	
		while (i < NumberOfDREs + 1 ) {
		# declaration of densities
			i = i + 1
			gname =  paste("dre",i,sep="_")
			dre_gnames = append(dre_gnames, gname)
			fs = append( fs, list(PV(DensityAll$name[DensityAll$group==gname]) ))
		}	
	}

	if (NumberOfODEs > 0){
		i = 1
		gname = paste("ode",i,sep="_")
		ode_gnames = c(gname)
		odes = list( PV(Fields$name[Fields$group==gname]) )	
		while (i < NumberOfODEs + 1) {
		# declaration of densities
			i = i + 1
			gname =  paste("ode",i,sep="_")
			ode_gnames = append(ode_gnames, gname)
			odes = append( odes, PV(Fields$name[Fields$group==gname]) )
		}	
	}

	f_tmp = c(PV(paste('f_tmp[',seq(0,8),']', sep='')))
	qs = c(PV(paste('q[',seq(0,NumberOfODEs + NumberOfDREs),']', sep='')))

?>
//this is object-wide variable
real_t f_tmp[9];
real_t q[<?%s NumberOfODEs + NumberOfDREs ?>];
real_t phi[<?%s NumberOfODEs + NumberOfDREs ?>];


CudaDeviceFunction float2 Color() {
  float2 ret;
  ret.x = 0;
  ret.y = <?R C(sum(fs[[1]])) ?>;
  return ret;
}

// ------------------------ PARAVIEW OUTPUT BLOCK ------------------------
// Use this functions is only for vtk output.

<?R
dre_loop( function(i) {
?>
CudaDeviceFunction real_t getDRE_<?%s i ?>() {
	DispatchCalcPhi();
	return phi[<?%s i-1 ?>];
}
<?R
})
?>

<?R
ode_loop( function(i) {
?>
CudaDeviceFunction real_t getODE_<?%s i ?>() {
	DispatchCalcPhi();
	return phi[<?%s NumberOfDREs+i-1 ?>];
}
<?R
})
?>



// ------------------------ END OF PARAVIEW OUTPUT BLOCK ------------------------

CudaDeviceFunction void Init() { 
	<?R


	dre_loop( function(i) {
		?>
		phi[<?%s i-1 ?>] = Init_DRE_<?%s i ?>;
		<?R
	})

	ode_loop( function(i) {
		?>
		phi[<?%s NumberOfDREs+i-1 ?>] = Init_ODE_<?%s i ?>;
		<?R		
	})

	?>

	DispatchCalcQ();

	<?R


	dre_loop( function(i) {
		?>
		Init_eq(Init_DRE_<?%s i ?> - 0.5*q[<?%s i-1 ?>]);
		<?R
		C(fs[[i]], f_tmp)
	})

	ode_loop( function(i) {
		C(odes[[i]], PV(paste('Init_ODE_',i,sep='')) - 0.5*qs[NumberOfDREs+i] );
	})

	?>
	DispatchCalcPhi();

}

CudaDeviceFunction void InitFromExternal() { 
	<?R


	dre_loop( function(i) {
		?>
		phi[<?%s i-1 ?>] = Init_DRE_<?%s i ?>_External(0,0);
		<?R
	})

	ode_loop( function(i) {
		?>
		phi[<?%s NumberOfDREs+i-1 ?>] = Init_ODE_<?%s i ?>_External(0,0);
		<?R		
	})

	?>

	DispatchCalcQ();

	<?R


	dre_loop( function(i) {
		?>
		Init_eq(Init_DRE_<?%s i ?>_External(0,0) - 0.5*q[<?%s i-1 ?>]);
		<?R
		C(fs[[i]], f_tmp)
	})

	ode_loop( function(i) {
		C(odes[[i]], PV(paste('Init_ODE',i,'External(0,0)',sep='_')) - 0.5*qs[NumberOfDREs+i] );
	})

	?>
	DispatchCalcPhi();

}


	
CudaDeviceFunction void Run() {
	DispatchCalcPhi();
	DispatchCalcQ();



    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Wall:
		BounceBack();
		return;
		break;
	}
	<?R

	dre_loop( function(i) {
		C(f_tmp,fs[[i]])
		?>
		SRT(Diffusivity_DRE_<?%s i ?>, q[<?%s i-1 ?>]);
		<?R
		C(fs[[i]], f_tmp)
	})

	ode_loop( function(i) {
		accessor = PV( paste('ode_', i, '(0,0)', sep=''))
		C(odes[[i]], accessor  + qs[NumberOfDREs+i] );
	})

	?>

 }



CudaDeviceFunction void BounceBack()
{
<?R FullBounceBack() ?>
}


 CudaDeviceFunction void Init_eq(real_t Init_Phi_Tilde) 
 {

	<?R
		Init_Phi_Tilde = PV('Init_Phi_Tilde')
		U = as.matrix(Density[Density$group=='dre_1',c("dx","dy")])
		feq = MRT_feq(U, Init_Phi_Tilde, c(0,0))
		C(f_tmp, feq)

	?>

 }

CudaDeviceFunction void SRT(real_t diffusivity, const real_t q) 
{


	real_t omega_ade = 1.0/(3*diffusivity+0.5);
	real_t tilde_phi = <?%s  C(sum(f_tmp)) ?>;

	<?R
		omega = PV('omega_ade')
		tilde_phi = PV('tilde_phi')
		q = PV('q')

		U = as.matrix(Density[Density$group=='dre_1',c("dx","dy")])
		feq = MRT_feq(U, tilde_phi, c(0,0))
		qeq = MRT_feq(U, q, c(0,0))

		C(f_tmp, f_tmp - omega*(f_tmp-feq) + qeq)

	?>
}



CudaDeviceFunction void DispatchCalcPhi() 
{	

    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Wall:

		<?R


		dre_loop( function(i) {
			?>
			phi[<?%s i-1 ?>] = 0;
			<?R
		})

		ode_loop( function(i) {
			?>
			phi[<?%s NumberOfDREs+i-1 ?>] = 0;
			<?R		
		})

		?>

		return;
		break;
	}

	CalcPhi();
}
CudaDeviceFunction void DispatchCalcQ() 
{	
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Wall:


		return;
		break;
	}

	CalcQ();
}




<?R 
	if (Qname == 'Allen-Cahn') {
?>


	CudaDeviceFunction void CalcPhi() 
	{	
		real_t tilde_phi = <?%s  C(sum(fs[[1]])) ?>;

		const real_t dt = 1.;
		const real_t lambda = C_1;
		const real_t  x0 = cbrt(3.) ; 
		const real_t  x1 = 1/(dt*lambda) ; 
		const real_t  x2 = dt*lambda - 2 ; 
		const real_t  x3 = cbrt(-9*tilde_phi*x1 + sqrt(3.)*sqrt((27*pow(tilde_phi, 2) - x1*pow(x2, 3))/(pow(dt, 2)*pow(lambda, 2)))) ; 
		phi[0] = -1.0/3.0*x0*(x0*x1*x2 + pow(x3, 2))/x3 ;  
	}
	CudaDeviceFunction void CalcQ() 
	{	
		const real_t lambda = C_1;
		q[0] = lambda*phi[0]*(1 - pow(phi[0], 2)) ;
	}
<?R		
	}
?>



<?R 
	if (Qname == 'SIR_SimpleLaplace') {
?>


	CudaDeviceFunction void CalcPhi() 
	{	
		const real_t x0 = <?%s  C(sum(fs[[1]])) ?>;
		const real_t x1 = <?%s  C(sum(fs[[2]])) ?>;
		const real_t x2 = <?%s  C(sum(fs[[3]])) ?>;

		//x0 = S^\star
		//x1 = I^\star
		//x2 = R^\star
		const real_t x3 = C_1; // R0
		const real_t x4 = C_2; // nondimensional dt

		// Opers0 =  356
		const real_t  x5 = 4*x4 ; // 1
		const real_t  x6 = pow(x4, 2) ; // 1
		const real_t  x7 = x0*x3 ; // 1
		const real_t  x8 = x1*x3 ; // 1
		const real_t  x9 = 2*x6 ; // 1
		const real_t  x10 = pow(x3, 2)*x6 ; // 2
		const real_t  x11 = sqrt(x10*(pow(x0, 2) + 2*x0*x1 + pow(x1, 2)) - x5*x7 + x5*x8 + x5 + x6 - x7*x9 + x8*x9 + 4) ; // 20
		const real_t  x12 = x4 + 2 ; // 1
		const real_t  x13 = x11 + x12 ; // 1
		const real_t  x14 = x3*x4 ; // 1
		const real_t  x15 = x0*x14 ; // 1
		const real_t  x16 = x1*x14 ; // 1
		const real_t  x17 = x15 + x16 ; // 1
		const real_t  x18 = 1.0/x3 ; // 1
		const real_t  x19 = x18/x4 ; // 1
		const real_t  x20 = (1.0/2.0)*x19 ; // 1
		const real_t  x21 = 1.0/x12 ; // 1
		const real_t  x22 = x19*x21 ; // 1
		const real_t  x23 = -x11 + x17 ; // 1
		const real_t  x24 = -x4 - 2 ; // 2
		const real_t  x25 = 2*x2*(x14 + 2*x3) ; // 4
		const real_t  x26 = (1.0/2.0)*x18*x21 ; // 2
		const real_t  x27 = x11 + x17 + x24 ; // 2
		const real_t Sp = x20*(x13 + x17) ; // 2
		const real_t Ip = x22*(-x13 + x15 + x16) ; // 3
		const real_t Rp = x26*(x23 + x24 + x25) ; // 3
		const real_t Sm = x20*(x12 + x23) ; // 2
		const real_t Im = x22*x27 ; // 1
		const real_t Rm = x26*(x25 + x27) ; // 2
		// Opers =  91


		const real_t eps = -1E-12;
		if ( Sp >=eps && Ip >=eps && Rp >=eps ) {
			phi[0] = Sp < 0 ? 0 : Sp;
			phi[1] = Ip < 0 ? 0 : Ip;
			phi[2] = Rp < 0 ? 0 : Rp;
		} else if ( Sm >=eps&& Im >=eps && Rm >=eps ) {
			phi[0] = Sm < 0 ? 0 : Sm;
			phi[1] = Im < 0 ? 0 : Im;
			phi[2] = Rm < 0 ? 0 : Rm;
		} else {
			printf("x3 x4 %f %f \n", x3, x4);
			printf("s %e %e %e \n", x0, x1, x2);
			printf("p %e %e %e \n", Sp, Ip, Rp);
			printf("m %e %e %e \n", Sm, Im, Rm);
			assert(0);
		}


	}
	CudaDeviceFunction void CalcQ() 
	{	
		const real_t R0 = C_1;

		const real_t  x0 = R0*phi[0] ; 
		q[0] = -C_2*phi[1]*x0 ; 
		q[1] =  C_2*phi[1]*(x0 - 1.) ;
		q[2] =  C_2*phi[1] ; 

		// printf("Phi %f %f %f \n", phi[0], phi[1], phi[2]);
		// printf("Q %f %f %f \n", q[0], q[1], q[2]);
		

	}
<?R		
	}
?>



<?R 
	if (Qname == 'SIR_ModifiedPeng') {
?>


	CudaDeviceFunction void CalcPhi() 
	{	
		const real_t x0 = <?%s  C(sum(fs[[1]])) ?>;
		const real_t x1 = <?%s  C(odes[[1]]) ?>(0,0);
		const real_t x2 = <?%s  C(odes[[2]]) ?>(0,0);
		const real_t x3 = <?%s  C(odes[[3]]) ?>(0,0);

		// x0 = W^\star
		// x1 = S^\star
		// x2 = I^\star
		// x3 = R^\star

		// x4 = R0
		// x5 = Beta
		// x6 = dt		
		const real_t x4 = C_1;
		const real_t x5 = C_2;
		const real_t x6 = C_3;
		
		// Opers0 =  1854
		const real_t  x7 = pow(x6, 2) ; // 1
		const real_t  x8 = x5*x7 ; // 1
		const real_t  x9 = x4*x8 ; // 1
		const real_t  x10 = x1*x9 ; // 1
		const real_t  x11 = x2*x9 ; // 1
		const real_t  x12 = 2*x6 ; // 1
		const real_t  x13 = x12*x5 ; // 1
		const real_t  x14 = x12 + x13 + x8 + 4 ; // 3
		const real_t  x15 = -x10 - x11 + x14 ; // 2
		const real_t  x16 = 16*x6 ; // 1
		const real_t  x17 = 4*x7 ; // 1
		const real_t  x18 = x0*x4 ; // 1
		const real_t  x19 = pow(x6, 3) ; // 1
		const real_t  x20 = 4*x19 ; // 1
		const real_t  x21 = x20*x5 ; // 1
		const real_t  x22 = pow(x5, 2) ; // 1
		const real_t  x23 = pow(x6, 4) ; // 1
		const real_t  x24 = x22*x23 ; // 1
		const real_t  x25 = x18*x7 ; // 1
		const real_t  x26 = x20*x22 ; // 1
		const real_t  x27 = x18*x5 ; // 1
		const real_t  x28 = 2*x23 ; // 1
		const real_t  x29 = x1*x4 ; // 1
		const real_t  x30 = x2*x4 ; // 1
		const real_t  x31 = pow(x4, 2) ; // 1
		const real_t  x32 = pow(x0, 2)*x31 ; // 2
		const real_t  x33 = 2*x24 ; // 1
		const real_t  x34 = x0*x31 ; // 1
		const real_t  x35 = x1*x34 ; // 1
		const real_t  x36 = x28*x5 ; // 1
		const real_t  x37 = x2*x34 ; // 1
		const real_t  x38 = x24*x31 ; // 1
		const real_t  x39 = sqrt(pow(x1, 2)*x38 + 2*x1*x2*x38 - 8*x10 + 8*x11 + x16*x18 + x16*x5 + x16 + x17*x22 + x17*x32 + x17 + x18*x20 + 8*x18*x8 + 8*x19*x27 + pow(x2, 2)*x38 + x20*x32 - x21*x29 + x21*x30 + x21*x35 + x21*x37 + x21 + x23*x32 + x24 + 16*x25 - x26*x29 + x26*x30 + x26 + x27*x28 - x29*x33 + x30*x33 + x35*x36 + x36*x37 + 16*x8 + 16) ; // 67
		const real_t  x40 = x12*x18 ; // 1
		const real_t  x41 = -x25 + x39 - x40 ; // 2
		const real_t  x42 = 1.0/x4 ; // 1
		const real_t  x43 = 1.0/x6 ; // 1
		const real_t  x44 = x42*x43 ; // 1
		const real_t  x45 = x44/x14 ; // 1
		const real_t  x46 = (1.0/2.0)*x42 ; // 1
		const real_t  x47 = 1.0/x5 ; // 1
		const real_t  x48 = x47/x7 ; // 1
		const real_t  x49 = x39*x46*x48 ; // 2
		const real_t  x50 = x0*x47 ; // 1
		const real_t  x51 = x42*x48 ; // 1
		const real_t  x52 = (1.0/2.0)*x1 + (1.0/2.0)*x2 + x43*x50 + x44*x47 + x44 + x46 + (1.0/2.0)*x50 + 2*x51 ; // 13
		const real_t  x53 = x25 + x39 + x40 ; // 2
		const real_t  x54 = x15 + x53 ; // 1
		const real_t  x55 = 1.0/(x6 + 2) ; // 2
		const real_t  x56 = x51*x55 ; // 1
		const real_t  x57 = 4*x3*x4*x5*x6 ; // 4
		const real_t  x58 = 2*x3*x9 ; // 2
		const real_t  x59 = x43*x46*x47*x55 ; // 3
		const real_t  x60 = x10 + x11 - x12 - x13 - x8 - 4 ; // 5
		const real_t  Wp = -x45*(x15 + x41) ; // 3
		const real_t  Sp = x49 + x52 ; // 1
		const real_t  Ip = -x54*x56 ; // 2
		const real_t  Rp = x59*(-x54 + x57 + x58) ; // 3
		const real_t  Wm = x45*(x53 + x60) ; // 2
		const real_t  Sm = -x49 + x52 ; // 1
		const real_t  Im = x56*(-x15 - x25 + x39 - x40) ; // 4
		const real_t  Rm = x59*(x41 + x57 + x58 + x60) ; // 4
		// Opers =  232

		const real_t eps = -1E-10;
		if ( Sp >=eps && Ip >=eps && Rp >=eps && Wp >=eps) {
			phi[1] = Sp < 0 ? 0 : Sp;
			phi[2] = Ip < 0 ? 0 : Ip;
			phi[3] = Rp < 0 ? 0 : Rp;
			phi[0] = Wp < 0 ? 0 : Wp;

		} else if ( Sm >=eps&& Im >=eps && Rm >=eps && Wm >=eps ) {
			phi[1] = Sm < 0 ? 0 : Sm;
			phi[2] = Im < 0 ? 0 : Im;
			phi[3] = Rm < 0 ? 0 : Rm;
			phi[0] = Wm < 0 ? 0 : Wm;

		} else {
			printf("x4 x5 x6 %f %f %f\n", x4, x5, x6);
			printf("s %e %e %e %e \n", x0, x1, x2, x3);
			printf("p %e %e %e %e \n", Wp, Sp, Ip, Rp);
			printf("m %e %e %e %e \n", Wm, Sm, Im, Rm);
			assert(0);
		}


	}
	CudaDeviceFunction void CalcQ() 
	{	
		const real_t R0 = C_1;
		const real_t Beta = C_2;

		 
		const real_t W = phi[0];
		const real_t S = phi[1];
		const real_t I = phi[2];
		const real_t R = phi[3];

		q[0] =   C_3*Beta*(I-W);
		q[1] =  -C_3*R0*S*W;
		q[2] =   C_3*(R0*S*W - I); 
		q[3] =   C_3*I;
		
		//printf("Phi %f %f %f %f\n", phi[0], phi[1], phi[2], phi[3]);
		//printf("Q %f %f %f %f\n", q[0], q[1], q[2], q[3]);
	}
<?R		
	}
?>


<?R 
	if (Qname == 'SimpleDiffusion') {
?>
	CudaDeviceFunction void CalcPhi() 
	{	
		phi[0] = <?%s  C(sum(fs[[1]])) ?>;
	}
	CudaDeviceFunction void CalcQ() 
	{	
		q[0] = 0;
	}
<?R		
	}
?>