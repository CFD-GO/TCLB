<?R  

	if (!IncludedADREModel) {
		source("conf.R")
		c_header();
		source("lib/boundary.R")
		source("lib/feq.R")
	}

	if (NumberOfDREs > 0){
		i = 1
		gname = paste("dre",i,sep="_")
		dre_gnames = c(gname)
		fs = list( PV(DensityAll$name[DensityAll$group==gname]) )	
		while (i < NumberOfDREs + 1 ) {
		# declaration of densities
			i = i + 1
			gname =  paste("dre",i,sep="_")
			dre_gnames = append(dre_gnames, gname)
			fs = append( fs, list(PV(DensityAll$name[DensityAll$group==gname]) ))
		}	
	}

	if (NumberOfODEs > 0){
		i = 1
		gname = paste("ode",i,sep="_")
		ode_gnames = c(gname)
		odes = list( PV(Fields$name[Fields$group==gname]) )	
		while (i < NumberOfODEs + 1) {
		# declaration of densities
			i = i + 1
			gname =  paste("ode",i,sep="_")
			ode_gnames = append(ode_gnames, gname)
			odes = append( odes, PV(Fields$name[Fields$group==gname]) )
		}	
	}

	adre_f_tmp = c(PV(paste('adre_f_tmp[',seq(0,length(U[,1])-1),']', sep='')))
	adre_qs = c(PV(paste('q[',seq(0,NumberOfODEs + NumberOfDREs),']', sep='')))
?>


//this is object-wide variable
real_t adre_f_tmp[<?%s length(U[,1]) ?>];
real_t q[<?%s NumberOfODEs + NumberOfDREs ?>];
real_t phi[<?%s NumberOfODEs + NumberOfDREs ?>];


// --- Those functions should not exists if model is included (Actions, Color ETC.)
// --- For such cases Upper model developer is responsible for calling Run_Dispatch 

<?R if (!IncludedADREModel) { ?>

// turn off the advection of Reaction-Diffusion models
#define AdvectX 0
#define AdvectY 0
#define AdvectZ 0

CudaDeviceFunction float2 Color() {
  float2 ret;
  ret.x = 0;
  ret.y = <?R C(sum(fs[[1]])) ?>;
  return ret;
}


CudaDeviceFunction void Init() { 
	DoADRE_Init();
}

CudaDeviceFunction void InitFromExternal() { 
	DoADRE_InitFromExternal();
}

CudaDeviceFunction void  Run() {
	DoADRE_Run();
}
<?R } ?>

// ------------------------ PARAVIEW OUTPUT BLOCK ------------------------
// Use this functions is only for vtk output.

<?R
dre_loop( function(i) {
?>
CudaDeviceFunction real_t get<?%s DREs[i] ?>() {
	DoADRE_DispatchCalcPhi();
	return phi[<?%s i-1 ?>];
}
<?R
})
?>

<?R
ode_loop( function(i) {
?>
CudaDeviceFunction real_t get<?%s ODEs[i] ?>() {
	DoADRE_DispatchCalcPhi();
	return phi[<?%s NumberOfDREs+i-1 ?>];
}
<?R
})
?>



// ------------------------ END OF PARAVIEW OUTPUT BLOCK ------------------------

CudaDeviceFunction void DoADRE_Init() { 
	<?R


	dre_loop( function(i) {
		?>
		phi[<?%s i-1 ?>] = Init_<?%s DREs[i] ?>;
		<?R
	})

	ode_loop( function(i) {
		?>
		phi[<?%s NumberOfDREs+i-1 ?>] = Init_<?%s ODEs[i] ?>;
		<?R		
	})

	if (QIntegrator == 'Trapezoid') { 
		?> 
		DoADRE_DispatchCalcQ();
		<?R
	}


	dre_loop( function(i) {
		
		if (QIntegrator == 'Trapezoid') { ?> DoADRE_Init_eq(Init_<?%s DREs[i] ?> - 0.5*adre_q[<?%s i-1 ?>]); <?R }
		if (QIntegrator == 'Heun') { ?> DoADRE_Init_eq(Init_<?%s DREs[i] ?>); <?R }
		if (QIntegrator == 'Euler') { ?> DoADRE_Init_eq(Init_<?%s DREs[i] ?>); <?R }
		
		C(fs[[i]], adre_f_tmp)
	})

	ode_loop( function(i) {	
		
		if (QIntegrator == 'Trapezoid') { C(odes[[i]], PV(paste('Init', ODEs[i] , sep="_")) - 0.5*adre_qs[NumberOfDREs+i] ); }
		if (QIntegrator == 'Heun') { C(odes[[i]], PV(paste('Init', ODEs[i] , sep="_")) );}
		if (QIntegrator == 'Euler') { C(odes[[i]], PV(paste('Init', ODEs[i] , sep="_")) );}

	})

	?>
	DoADRE_DispatchCalcPhi();

}

CudaDeviceFunction void DoADRE_InitFromExternal() { 
	<?R


	dre_loop( function(i) {
		?>
		phi[<?%s i-1 ?>] = Init_<?%s DREs[i] ?>_External(0,0);
		<?R
	})

	ode_loop( function(i) {
		?>
		phi[<?%s NumberOfDREs+i-1 ?>] = Init_<?%s ODEs[i] ?>_External(0,0);
		<?R		
	})


	if (QIntegrator == 'Trapezoid') { 
		?> 
		DispatchCalcQ();
		<?R

	}
	
	
	dre_loop( function(i) {
		
		if (QIntegrator == 'Trapezoid') { ?> DoADRE_Init_eq(Init_<?%s DREs[i] ?>_External(0,0) - 0.5*adre_q[<?%s i-1 ?>]); <?R }
		if (QIntegrator == 'Heun' || QIntegrator == 'Euler') { ?> DoADRE_Init_eq(Init_<?%s DREs[i] ?>_External(0,0)); <?R }
		
		C(fs[[i]], adre_f_tmp)
	})

	ode_loop( function(i) {	
		
		if (QIntegrator == 'Trapezoid') { C(odes[[i]], PV(paste('Init', ODEs[i],'External(0,0)' , sep="_")) - 0.5*adre_qs[NumberOfDREs+i] ); }
		if (QIntegrator == 'Heun' || QIntegrator == 'Euler') { C(odes[[i]], PV(paste('Init', ODEs[i],'External(0,0)' , sep="_")) );}

	})

	?>
	DoADRE_DispatchCalcPhi();

}


	
CudaDeviceFunction void  DoADRE_Run() {
	DoADRE_DispatchCalcPhi();
	DoADRE_DispatchCalcQ();



    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Wall:
		DoADRE_BounceBack();
		return;
		break;
	}

	switch (NodeType & NODE_COLLISION) {  
		case NODE_TRT_M:
			<?R
			dre_loop( function(i) {
				C(adre_f_tmp,fs[[i]])
				?>
				DoADRE_relax_and_collide_TRT_M(Diffusivity_<?%s DREs[i] ?>, q[<?%s i-1 ?>]);
				<?R
				C(fs[[i]], adre_f_tmp)
			})
			?>
			break;
		case NODE_SRT_DF:
    	default:
			<?R
			dre_loop( function(i) {
				C(adre_f_tmp,fs[[i]])
				?>
				DoADRE_relax_and_collide_SRT_DF(Diffusivity_<?%s DREs[i] ?>, q[<?%s i-1 ?>]);
				<?R
				C(fs[[i]], adre_f_tmp)
			})
			?>
			break;      
	}


	
	<?R
	ode_loop( function(i) {
		accessor = PV( paste('ode_', i, '(0,0)', sep=''))
		C(odes[[i]], accessor  + adre_qs[NumberOfDREs+i] );
	})
	?>

 }



CudaDeviceFunction void DoADRE_BounceBack()
{
	<?R 
		dre_loop( function(i) {
			gname = paste("dre",i,sep="_")
			FullBounceBack()
		})

?>
}


 CudaDeviceFunction void DoADRE_Init_eq(real_t Init_Phi_Tilde) 
 {

	<?R
		Init_Phi_Tilde = PV('Init_Phi_Tilde')
		U = as.matrix(Density[Density$group=='dre_1',c("dx","dy","dz")])
		feq = MRT_feq(U, Init_Phi_Tilde, c(0,0,0), ortogonal=FALSE)
		C(adre_f_tmp, feq)

	?>

 }

CudaDeviceFunction void DoADRE_relax_and_collide_SRT_DF(real_t diffusivity, const real_t q) 
{


	real_t omega_ade = 1.0/(3*diffusivity+0.5);
	real_t tilde_phi = <?%s  C(sum(adre_f_tmp)) ?>;

	<?R

		omega = PV('omega_ade')
		tilde_phi = PV('tilde_phi')
		q = PV('q')

		AdvVel = PV(c('AdvectX','AdvectY','AdvectZ'))

		U = as.matrix(Density[Density$group=='dre_1',c("dx","dy", "dz")])
		feq = MRT_feq(U, tilde_phi, tilde_phi*AdvVel, ortogonal=FALSE)
		qeq = MRT_feq(U, q, c(0,0,0), ortogonal=FALSE)

		C(adre_f_tmp, adre_f_tmp - omega*(adre_f_tmp-feq) + qeq)

	?>
}

CudaDeviceFunction void DoADRE_relax_and_collide_TRT_M(real_t diffusivity, real_t Q) 
{	

	// see eq. 7 from
	// "Optimal Stability of Advection-Diffusion Lattice Boltzmann Models 
	//  with Two Relaxation Times for Positive/Negative Equilibrium"
	// by I. Ginzburg, D. d’Humières, A. Kuzmin, 2010

	real_t omega_ade = 1.0/(3*diffusivity+0.5);
	real_t omega_even = 2.*(2.-omega_ade)/(omega_ade*(4.*adre_magic_parameter-1.)+2.);
	// real_t omega_even = 1.;

	// **to match notations **
	vector_t u; // disable advection
	u.x = 0;
	u.y = 0;
	u.z = 0;
	real_t f000 = adre_f_tmp[0];
	real_t f100 = adre_f_tmp[1];
	real_t f200 = adre_f_tmp[2];
	real_t f010 = adre_f_tmp[3];
	real_t f110 = adre_f_tmp[4];
	real_t f210 = adre_f_tmp[5];
	real_t f020 = adre_f_tmp[6];
	real_t f120 = adre_f_tmp[7];
	real_t f220 = adre_f_tmp[8];
	// end of **to match notations **

	//=== THIS IS AUTOMATICALLY GENERATED CODE ===
	real_t uxuy = u.x*u.y;
	real_t ux2 = u.x*u.x;
	real_t uy2 = u.y*u.y;
	real_t Sigma2 = 0.3333333333333333;
	
	real_t tilde_phi = f000 + f010 + f020 + f100 + f110 + f120 + f200 + f210 + f220;
	//raw moments from density-probability functions
	real_t m000 = f000 + f010 + f020 + f100 + f110 + f120 + f200 + f210 + f220;
	real_t m100 = f100 + f110 + f120 - f200 - f210 - f220;
	real_t m010 = f010 - f020 + f110 - f120 + f210 - f220;
	real_t m200 = f100 + f110 + f120 + f200 + f210 + f220;
	real_t m020 = f010 + f020 + f110 + f120 + f210 + f220;
	real_t m110 = f110 - f120 - f210 + f220;
	real_t m210 = f110 - f120 + f210 - f220;
	real_t m120 = f110 + f120 - f210 - f220;
	real_t m220 = f110 + f120 + f210 + f220;

	//raw equilibrium moments 
	real_t mf_eq_000 = tilde_phi;
	real_t mf_eq_100 = tilde_phi*u.x;
	real_t mf_eq_010 = tilde_phi*u.y;
	real_t mf_eq_200 = tilde_phi*(Sigma2 + ux2);
	real_t mf_eq_020 = tilde_phi*(Sigma2 + uy2);
	real_t mf_eq_110 = tilde_phi*uxuy;
	real_t mf_eq_210 = tilde_phi*u.y*(Sigma2 + ux2);
	real_t mf_eq_120 = tilde_phi*u.x*(Sigma2 + uy2);
	real_t mf_eq_220 = tilde_phi*(Sigma2*Sigma2 + Sigma2*ux2 + Sigma2*uy2 + ux2*uy2);

	real_t mq_eq_000 = Q;
	real_t mq_eq_100 = Q*u.x;
	real_t mq_eq_010 = Q*u.y;
	real_t mq_eq_200 = Q*(Sigma2 + ux2);
	real_t mq_eq_020 = Q*(Sigma2 + uy2);
	real_t mq_eq_110 = Q*uxuy;
	real_t mq_eq_210 = Q*u.y*(Sigma2 + ux2);
	real_t mq_eq_120 = Q*u.x*(Sigma2 + uy2);
	real_t mq_eq_220 = Q*(Sigma2*Sigma2 + Sigma2*ux2 + Sigma2*uy2 + ux2*uy2);

	//collide
	real_t m_star_000 = -m000*(omega_even - 1.) + mf_eq_000*omega_even + mq_eq_000;
	real_t m_star_100 = -m100*(omega_ade - 1.) + mf_eq_100*omega_ade + mq_eq_100;
	real_t m_star_010 = -m010*(omega_ade - 1.) + mf_eq_010*omega_ade + mq_eq_010;
	real_t m_star_200 = -m200*(omega_even - 1.) + mf_eq_200*omega_even + mq_eq_200;
	real_t m_star_020 = -m020*(omega_even - 1.) + mf_eq_020*omega_even + mq_eq_020;
	real_t m_star_110 = -m110*(omega_even - 1.) + mf_eq_110*omega_even + mq_eq_110;
	real_t m_star_210 = -m210*(omega_ade - 1.) + mf_eq_210*omega_ade + mq_eq_210;
	real_t m_star_120 = -m120*(omega_ade - 1.) + mf_eq_120*omega_ade + mq_eq_120;
	real_t m_star_220 = -m220*(omega_even - 1.) + mf_eq_220*omega_even + mq_eq_220;

	//back to density-probability functions
	f000 = m_star_000 - m_star_020 - m_star_200 + m_star_220;
	f100 = 1/2.*m_star_100 - 1/2.*m_star_120 + 1/2.*m_star_200 - 1/2.*m_star_220;
	f200 = -1/2.*m_star_100 + 1/2.*m_star_120 + 1/2.*m_star_200 - 1/2.*m_star_220;
	f010 = 1/2.*m_star_010 + 1/2.*m_star_020 - 1/2.*m_star_210 - 1/2.*m_star_220;
	f110 = 1/4.*m_star_110 + 1/4.*m_star_120 + 1/4.*m_star_210 + 1/4.*m_star_220;
	f210 = -1/4.*m_star_110 - 1/4.*m_star_120 + 1/4.*m_star_210 + 1/4.*m_star_220;
	f020 = -1/2.*m_star_010 + 1/2.*m_star_020 + 1/2.*m_star_210 - 1/2.*m_star_220;
	f120 = -1/4.*m_star_110 + 1/4.*m_star_120 - 1/4.*m_star_210 + 1/4.*m_star_220;
	f220 = 1/4.*m_star_110 - 1/4.*m_star_120 - 1/4.*m_star_210 + 1/4.*m_star_220;
	
	// **to match notations **
	adre_f_tmp[0] = f000;
	adre_f_tmp[1] = f100;
	adre_f_tmp[2] = f200;
	adre_f_tmp[3] = f010;
	adre_f_tmp[4] = f110;
	adre_f_tmp[5] = f210;
	adre_f_tmp[6] = f020;
	adre_f_tmp[7] = f120;
	adre_f_tmp[8] = f220;
	// end of **to match notations **
}

CudaDeviceFunction void DoADRE_DispatchCalcPhi() 
{	

    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Wall:

		<?R


		dre_loop( function(i) {
			?>
			phi[<?%s i-1 ?>] = 0;
			<?R
		})

		ode_loop( function(i) {
			?>
			phi[<?%s NumberOfDREs+i-1 ?>] = 0;
			<?R		
		})

		?>

		return;
		break;
	}

	<?R 
	if (QIntegrator == 'Trapezoid') {
	?> 
		CalcPhi();
	<?R

	}
	if (QIntegrator == 'Heun' || QIntegrator == 'Euler') {
		dre_loop( function(i) {
			C( PV( paste( 'phi[', i-1 ,']', sep='' ) ), sum(fs[[i]]))
		})
	}
	
	?>


}
CudaDeviceFunction void DoADRE_DispatchCalcQ() 
{	
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Wall:
		<?R


		dre_loop( function(i) {
			?>
			q[<?%s i-1 ?>] = 0;
			<?R
		})

		ode_loop( function(i) {
			?>
			q[<?%s NumberOfDREs+i-1 ?>] = 0;
			<?R		
		})

		?>
		return;
		break;
	}

	<?R

	if (QIntegrator == 'Trapezoid' || QIntegrator == 'Euler') { 
		?> 
			DoADRE_CalcQ(phi,q); 
		<?R
	}


	if (QIntegrator == 'Heun') { 
		?> 
			real_t q_tmp[<?%s NumberOfODEs + NumberOfDREs ?>];
			real_t phi_euler[<?%s NumberOfODEs + NumberOfDREs ?>];
			DoADRE_CalcQ(phi,q_tmp);
		<?R

		dre_loop( function(i) {
			?>
			phi_euler[<?%s i-1 ?>] = phi[<?%s i-1 ?>] + q_tmp[<?%s i-1 ?>];
			<?R
		})

		ode_loop( function(i) {
			?>
			phi_euler[<?%s NumberOfDREs+i-1 ?>] = = phi[<?%s NumberOfDREs+i-1 ?>] + q_tmp[<?%s NumberOfDREs+i-1 ?>];
			<?R		
		})
		?> 
			DoADRE_CalcQ(phi_euler,q);
		<?R

		dre_loop( function(i) {
			?>
			q[<?%s i-1 ?>] = ( q[<?%s i-1 ?>] + q_tmp[<?%s i-1 ?>] ) / 2;
			<?R
		})

		ode_loop( function(i) {
			?>
			q[<?%s NumberOfDREs+i-1 ?>] = ( q[<?%s NumberOfDREs+i-1 ?>] + q_tmp[<?%s NumberOfDREs+i-1 ?>] ) / 2;
			<?R		
		})

	}

	?>

}



<?RT models/reaction/d2q9_reaction_diffusion_system/ReactionTerms.c.Rt ?>
