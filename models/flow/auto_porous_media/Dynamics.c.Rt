<?R 
	#setwd('/home/mdzik/_TCLB/TCLB')
	#source('CLB/auto_porous_media_d3q19_TRT_GinzburgEqOrd1/Dynamics.c.code.R')

	source("conf.R")
	c_header();

	f = PV(DensityAll$name[DensityAll$group=="f"])
	rho0 =  PV("rho0")
	p =  PV("p")
    if (D3){
        V = PV("V",c("x","y","z"))
        Force = PV("dF",c("X","Y","Z"))
        J = rho0 * V
    # Extracting velocity set
        U = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy","dz")])
    } else {
        V = PV("V",c("x","y"))
        Force = PV("dF",c("X","Y"))
        J = rho0 * V
    # Extracting velocity set
        U = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy")])
    }

# C = function (x, y, ..., eq = " = ", sep) 
# {
#     x = ToC(x, ...)
#     if (missing(y)) {
#         if (missing(sep)) 
#             sep = ""
#         cat(x, sep = sep)
#     }
#     else {
#         if (missing(sep)) 
#             sep = ";\n"
#         y = ToC(y, ...)
#         sel = y != x
#         if (any(sel)) cat(paste0(x[sel], eq, y[sel], sep), sep = "")
#     }
# }


# Calculating equlibrium density set
	source("lib/feq.R")
	source("lib/boundary.R")
	source("lib/FMT.R")

	EQ_NO = MRT_eq(U, p, J, ortogonal=FALSE, order=2);


	M = EQ_NO$mat
	if (Options$TRT) {

	} else if (Options$BGK) {
		M = diag(nrow(M))
	} else if (Options$WMRT) {
		A = get.M.matrix(EQ_NO$Req)
		R = diag(nrow = ncol(A))
		R[1:nrow(A),] = qr.R(qr(A))
		R = R / diag(R)
		M = EQ_NO$mat %*% solve(R)
	} else {

	}

	
	EQ = MRT_eq(U, p, rho0*V, ortogonal=FALSE, mat=M);
	ZERO = PV(c('0'))
	EQ_FORCE = MRT_eq(U, ZERO, rho0*Force, ortogonal=FALSE, mat=M);


	

?>



#define rho0 1

real_t AdvectX, AdvectY, AdvectZ;

CudaDeviceFunction real_t getP() {
    if (IamWall) {
        return 1/0;
    } else {
        return ((<?R C(sum(f)) ?>)-1.0)/3.0;
    }
}

CudaDeviceFunction vector_t getU() {
    if(IamWall){
        vector_t u;
        u.x = 1/0;
        u.y = 1/0;
        u.z = 1/0;
        return u;
    } else {
        vector_t u;
		<?R C(PV(c("u.x","u.y", "u.z")), f %*% U ) ?>
		const real_t k = (rho0 + 0.5 * Viscosity / Permability);
		u.x = (u.x + ForceX/2.)/k;
        u.y = (u.y + ForceY/2.)/k;
        u.z = (u.z + ForceZ/2.)/k;
        return u;
    }
    
}



CudaDeviceFunction real_t getPermability(){
	return Permability;
}

CudaDeviceFunction real_t getReactiveFlux(){
		const real_t phi = getPHI();

		const real_t EffectiveSurfaceArea = 4*Porosity*(1-Porosity);
		real_t flux = EffectiveSurfaceArea*LinearReactionRate*(1 - phi);

		if (flux*SolidFluidReactionsRate > (1-InitialPorosity)) {
			flux = - (1-InitialPorosity) / SolidFluidReactionsRate;
		}
		return flux; // negative signe when flux is limited
}

CudaDeviceFunction real_t getPorosity(){
    if(IamWall){
        return 1/0;
    } else {
        return Porosity;
    }
}

CudaDeviceFunction real_t getInitialPermability(){
	return InitialPermability;
}

CudaDeviceFunction real_t getInitialPorosity(){
	return InitialPorosity;
}


CudaDeviceFunction vector_t getBrinkmanForce(){
    
	vector_t force  = getU();
	<?R C(PV(c("force.x","force.y", "force.z")), 0-PV(c("force.x","force.y", "force.z")) * PV('Viscosity') *  PV('Permability')^-1  )?>
	return force;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
		ret.y = 0;
        return ret;
}

CudaDeviceFunction void BounceBack()
{
<?R FullBounceBack(group='f') ?>
}


CudaDeviceFunction void RunBoundaries() {

	<?R
		f_neighbours = Density$nicename[Density$group =="f"]
		dre_1_neighbours = Density$nicename[Density$group =="dre_1"]
	?>
	const real_t k = (rho0 + 0.5 * Viscosity / Permability);
	real_t _phi_tmp;
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Wall:
		BounceBack();
        DoADRE_BounceBack();
        break;
<?R if ( Options$d2q9 ) { ?>        
	case NODE_WDirichlet:
		{
			const real_t BCVelocity = Velocity*k - ForceX / 2;
			<?R ZouHeRewrite(EQ, PV(DensityAll$name[DensityAll$group=='f']) , c(-1, 0), "first_moment", rhs=PV('BCVelocity')) ?>
		}
		{<?R 
			U_ADE = as.matrix(Density[Density$group=='dre_1',c("dx","dy")])
			EQ_ADRE = MRT_eq(U_ADE, PV("Init_PHI"), PV("Init_PHI")*PV(c('AdvectX','AdvectY')), ortogonal=FALSE)
			ZouHeRewrite(EQ_ADRE, PV(DensityAll$name[DensityAll$group=='dre_1']) , c(-1, 0), "pressure", PV("Init_PHI")) 
			?>
		}
        break;
        
	case NODE_ENeuman:
		{<?R ZouHeRewrite(EQ, PV(DensityAll$name[DensityAll$group=='f']) , c(1, 0 ), "pressure") ?>}
		<?R
			C(PV(DensityAll$name[DensityAll$group=='dre_1']), PV(paste0(dre_1_neighbours,"(",-Density$dx[Density$group=="dre_1"]-1,",",-Density$dy[Density$group=="dre_1"],")")))
			C(PV("_phi_tmp"), sum(PV(DensityAll$name[DensityAll$group=='dre_1'])))
		?>
			if (_phi_tmp > 1) {
				<?R 
					C(	PV(DensityAll$name[DensityAll$group=='dre_1']), PV(DensityAll$name[DensityAll$group=='dre_1']) * PV("_phi_tmp")^-1 )
				?>
			}
		
        break;		
        
<?R } ?>        
<?R if ( Options$FlowInX ) { ?>        
	case NODE_WDirichlet:
		{
			const real_t BCVelocity = Velocity*k - ForceX / 2;
			<?R ZouHeRewrite(EQ, PV(DensityAll$name[DensityAll$group=='f']) , c(-1, 0, 0), "first_moment", rhs=PV('BCVelocity')) ?>
		}
		{<?R 
			U_ADE = as.matrix(Density[Density$group=='dre_1',c("dx","dy", "dz")])
			EQ_ADRE = MRT_eq(U_ADE, PV("Init_PHI"), PV("Init_PHI")*PV(c('AdvectX','AdvectY','AdvectZ')), ortogonal=FALSE)
			ZouHeRewrite(EQ_ADRE, PV(DensityAll$name[DensityAll$group=='dre_1']) , c(-1, 0, 0), "pressure", PV("Init_PHI")) 
			?>
		}
        break;
        
	case NODE_ENeuman:
		{<?R ZouHeRewrite(EQ, PV(DensityAll$name[DensityAll$group=='f']) , c(1, 0, 0), "pressure") ?>}
		<?R
			# C(PV(DensityAll$name[DensityAll$group=='f']), PV(paste0(f_neighbours,"(",-Density$dx[Density$group=="f"]-1,",",-Density$dy[Density$group=="f"],",",-Density$dz[Density$group=="f"],")")))
			C(PV(DensityAll$name[DensityAll$group=='dre_1']), PV(paste0(dre_1_neighbours,"(",-Density$dx[Density$group=="dre_1"]-1,",",-Density$dy[Density$group=="dre_1"],",",-Density$dz[Density$group=="dre_1"],")")))
			C(PV("_phi_tmp"), sum(PV(DensityAll$name[DensityAll$group=='dre_1'])))
		?>
			if (_phi_tmp > 1) {
				<?R 
					C(	PV(DensityAll$name[DensityAll$group=='dre_1']), PV(DensityAll$name[DensityAll$group=='dre_1']) * PV("_phi_tmp")^-1 )
				?>
			}
		
        break;		
        
<?R } ?>
<?R if (Options$FlowInZ) { ?>        

	case NODE_IDirichlet:
		{
			const real_t BCVelocity = Velocity*k - ForceZ / 2;
			<?R ZouHeRewrite(EQ, PV(DensityAll$name[DensityAll$group=='f']) , c(0, 0, -1), "first_moment", rhs=PV('BCVelocity')) ?>
		}
		{<?R 
			U_ADE = as.matrix(Density[Density$group=='dre_1',c("dx","dy", "dz")])
			EQ_ADRE = MRT_eq(U_ADE, PV("Init_PHI"), PV("Init_PHI")*PV(c('AdvectX','AdvectY','AdvectZ')), ortogonal=FALSE)
			ZouHeRewrite(EQ_ADRE, PV(DensityAll$name[DensityAll$group=='dre_1']) , c(0, 0, -1), "pressure", PV("Init_PHI")) 
			?>
		}
        break;

	case NODE_ONeuman:
		{<?R ZouHeRewrite(EQ, PV(DensityAll$name[DensityAll$group=='f']) , c(0, 0, 1), "pressure") ?>}
		<?R

			C(PV(DensityAll$name[DensityAll$group=='dre_1']), PV(paste0(dre_1_neighbours,"(",-Density$dx[Density$group=="dre_1"],",",-Density$dy[Density$group=="dre_1"],",",-Density$dz[Density$group=="dre_1"]-1,")")))

        C(PV("_phi_tmp"), sum(PV(DensityAll$name[DensityAll$group=='dre_1'])))
		?>
			if (_phi_tmp > 1) {
				<?R 
					C(	PV(DensityAll$name[DensityAll$group=='dre_1']), PV(DensityAll$name[DensityAll$group=='dre_1']) * PV("_phi_tmp")^-1 )
				?>
			}
		
        
        break;		
<?R } ?>
        
    }		
}

CudaDeviceFunction void Run() {
    RunBoundaries();
    switch (NodeType & NODE_COLLISION) {
	case NODE_COLLISION:
		Collision_MTW_RT();
        DoADRE_Run();
		break;
    }

}

CudaDeviceFunction void SetEquilibrum(real_t p, real_t Vx, real_t Vy, real_t Vz)
{

	<?R
		C(f, EQ$Req %*% solve(EQ$mat));
	?>
}

CudaDeviceFunction void Init() {
		
		Porosity = InitialPorosity;
		Permability = InitialPorosity;

	    SetEquilibrum(1.0,0,0,0);
		DoADRE_Init();
}


CudaDeviceFunction void InitFromExternal() { 
	SetEquilibrum(1.0,0,0,0);
	DoADRE_InitFromExternal();
}


CudaDeviceFunction void GlobasPorosityDissolutionTimeStep() { 
	InitialPorosity = Porosity;
    InitialPermability =  KarmanKozenyCoefficient * Porosity*Porosity*Porosity / ((1-Porosity)*(1-Porosity)+1E-8);
}


CudaDeviceFunction void Collision_MTW_RT()
{	
	
<?R
	

  Omega = PV(rep("omega",nrow(U)))
  LambdaForce = PV(rep("LambdaPlus",nrow(U)))

  if (Options$TRT) {
	Omega[EQ$order %% 2 == 1] = PV("omega2")
	LambdaForce[EQ$order %% 2 == 1] = PV("LambdaMinus")

  } else if (Options$BGK) {
  
  } else if (Options$WMRT) {

  } else {
  	Omega[EQ$order > 2] = PV(1)
  }

  #if (any(EQ$order < 2)) Omega[EQ$order < 2] = PV(1)
  

  meq = EQ$Req + LambdaForce*(EQ_FORCE$feq %*% EQ$mat)
  

  m = PV("m",1:ncol(EQ$mat)-1)
  cat("real_t",paste(ToC(m),collapse=","),";\n")
  C(m, f %*% EQ$mat)
	#real_t omega = 1/(3*Viscosity+0.5); #symmetric relaxation
	#real_t omega2 = (2.0 - omega)/(1 + 2*(Magic-0.25)*omega); #non-symmetric relaxation

	# Stokes‐Brinkman Flow Simulation Based on 3‐D μ‐CT Images of Porous Rock Using Grayscale Pore Voxel Permeability
	# 10.1029/2018WR024179
	# after (Ginzburg et al., 2015)
?>
	const real_t Lambda = Magic;
	const real_t B = 1. / Permability;
	const real_t LambdaPlus = 9. * (4. + B) / ( 4. *( 3.+2.*B*Lambda ) ) * Viscosity;
	const real_t LambdaMinus = Lambda / 3. /  Viscosity;

	// const real_t LambdaMinus =  3. *  Viscosity;
	//const real_t LambdaPlus =  3. *  Viscosity;

	const real_t omega = 1./(  LambdaPlus + 0.5 ); //symmetric relaxation
	const real_t omega2 = 1./(  LambdaMinus + 0.5 ); //non-symmetric relaxation


	real_t p, Vx, Vy, Vz, dFX, dFY, dFZ;
	const real_t k = 1./(rho0 + 0.5 * Viscosity / Permability);
		
<?R
 if (D3) {
    Vs = PV(c("Vx","Vy","Vz"))
    Forces = PV(c("ForceX","ForceY","ForceZ"))
    C(PV(c("p","Vx","Vy","Vz")), m %*% solve(EQ$mat) %*% cbind(1,U))
    C(Vs, (Vs + Forces*0.5) * PV(c('k')))
    C(PV(c("dFX","dFY","dFZ")), Forces - Vs*PV("Viscosity")*PV("Permability")^-1   )
    C(PV(c("AdvectX", "AdvectY", "AdvectZ")),Vs) #For reaction coupling    
  } else {
   Vs = PV(c("Vx","Vy"))
   Forces = PV(c("ForceX","ForceY"))
   C(PV(c("p","Vx","Vy")), m %*% solve(EQ$mat) %*% cbind(1,U))
   C(Vs, (Vs + Forces*0.5) * PV(c('k')))
   C(PV(c("dFX","dFY")), Forces - Vs*PV("Viscosity")*PV("Permability")^-1   )
   C(PV(c("AdvectX", "AdvectY")),Vs) #For reaction coupling       
   C(PV(c("AdvectZ","dFZ", "Vz")), 0)
  }
  


  C(m, m - meq)
  C(m, m*(1-Omega))
  C(m, m + meq)
  C(f, m %*% solve(EQ$mat))


?>

// Do Objectives/Logs

    switch (NodeType & NODE_OBJECTIVE) {
        case NODE_Outlet:
           AddToPressureLoss(-p); //only static pressure!!, simplified TODO
        break;
        case NODE_Inlet:
           AddToPressureLoss(p); //only static pressure!!, simplified TODO
       break;
    }

    AddToFlux(<?R C(Vs%*%Vs)  ?>);

}



// This should go at the end to avoid name conflicts in R
<?RT models/reaction/d2q9_reaction_diffusion_system/Dynamics.c.Rt ?>

<?R 
	if (Qname == 'DissolutionReaction_ForImplicitSteadyState') {
?>


	CudaDeviceFunction void DoADRE_CalcPhi() 
	{	
		real_t _q, _phi, _phis;
		_phis = <?%s  C(sum(fs[[1]])) ?>;

		DoADRE_CalcQ(&_phis, &_q);
		_phi = _phis + 0.5 * _q;

		for (int i =0; i < 10; i++){
			DoADRE_CalcQ(&_phi, &_q);
			_phi = _phis + 0.5 * _q;
			//printf("%f %f %f\n", _phi, _phis,  _q);
		}

		phi[0] = _phi;

	}
	CudaDeviceFunction void DoADRE_CalcQ(const real_t* _phi, real_t* _q) 
	{	
		if ((_phi[0] > 1) || (_phi[0] < 0)) {
			_q[0] = 0; 
			return;
		}// Limiter 
		
		// Predictor
		const real_t EffectiveSurfaceArea = 4*Porosity*(1-Porosity);
		real_t flux = EffectiveSurfaceArea*LinearReactionRate*(1 - _phi[0]);

		if (flux*SolidFluidReactionsRate > (1-InitialPorosity)) {
			flux = (1-InitialPorosity) / SolidFluidReactionsRate;
		}
		_q[0] = flux;

		
		if (ImpliciteReactionIntegration == 1) {
			Porosity = InitialPorosity + SolidFluidReactionsRate*flux;
        	Permability =  KarmanKozenyCoefficient * Porosity*Porosity*Porosity / ((1-Porosity)*(1-Porosity)+1E-8);
		}

		//printf("%f %f %f %f %f\n", flux, Porosity, Permability, InitialPorosity, InitialPermability);
		//Permability = Porosity / InitialPorosity * InitialPermability;
	}
<?R		
	}
?>
